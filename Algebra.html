<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>Algebra API documentation</title>
<meta name="description" content="Filename:
Algebra.py
Author:
Rafel Amer (rafel.amer AT upc.edu)
Copyright:
Rafel Amer 2020--2021
Disclaimer: This program is provided &#34;as is&#34;, …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Algebra</code></h1>
</header>
<section id="section-intro">
<p>Filename:
Algebra.py
Author:
Rafel Amer (rafel.amer AT upc.edu)
Copyright:
Rafel Amer 2020&ndash;2021
Disclaimer: This program is provided "as is", without warranty of any kind,
either expressed or implied, including, but not linmited to, the
implied warranties of merchantability and fitness for a particular
purpose.
It has been written to generate random models of exams for the
subject of Linear Algebra at ESEIAAT, Technic University of Catalonia
License:
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.</p>
<pre><code>            See &lt;https://www.gnu.org/licenses/&gt;
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/python3
# -*- coding: utf-8
&#34;&#34;&#34;
Filename:   Algebra.py
Author:     Rafel Amer (rafel.amer AT upc.edu)
Copyright:  Rafel Amer 2020--2021
Disclaimer: This program is provided &#34;as is&#34;, without warranty of any kind,
            either expressed or implied, including, but not linmited to, the
            implied warranties of merchantability and fitness for a particular
            purpose.
            It has been written to generate random models of exams for the
            subject of Linear Algebra at ESEIAAT, Technic University of Catalonia
License:    This program is free software: you can redistribute it and/or modify
            it under the terms of the GNU General Public License as published by
            the Free Software Foundation, either version 3 of the License, or
            (at your option) any later version.

                See https://www.gnu.org/licenses/
&#34;&#34;&#34;

import random
import math
import copy
import collections
import itertools
import re
from sympy import *
from sympy.solvers.solveset import linsolve
from sympy.vector import Vector
from functools import reduce
from math import gcd
from sympy import Basic, Function, Symbol
from sympy.printing.printer import Printer
from sympy.printing.latex import print_latex
from sympy.core.basic import Basic
from itertools import permutations

var(&#39;p q u v&#39;)
ddict = collections.OrderedDict([(p**2,1),(q**2,2),(u**2,3),(v**2,4),
                                ((p,q),5),((p,u),6),((p,v),7),
                                ((q,u),8),((q,v),9),((u,v),10),
                                ((q,p),5),((u,p),6),((v,p),7),
                                ((u,q),8),((v,q),9),((v,u),10),
                                (p,11),(q,12), (u,13), (v,14)])


class Impresora(Printer):
    &#34;&#34;&#34;
    La funció latex() del sympy té la mania d&#39;escriure les variables x, y, z i t
    en l&#39;ordre t, x, y i z. L&#39;única manera que, de moment, he trobat per resoldre
    aquest inconvenient és definir la classe Impresora i la funció mylatex().
    Ho he trobat a StackOverflow.
    &#34;&#34;&#34;
    printmethod = &#39;impresora&#39;
    #
    #
    #
    def _print_Add(self,expr):
        expr_args=expr.args

        def new_place(el):
            if el in ddict:
                return ddict[el]
            else:
                return len(ddict)+1

        def get_place(el):
            p, q, r, s = symbols(&#39;p q u v&#39;)
            if isinstance(el,Pow):
                return new_place(el)
            if el.is_integer:
                return new_place(el)
            elif el.is_symbol:
                return new_place(el)
            if len(el.args) == 2:
                if el.args[0].is_symbol and el.args[1].is_symbol:
                    k = -1
                    for i in range(0,2):
                        if el.args[i] not in [p,q,r,s]:
                            k = i
                    if k &gt;= 0:
                        k = (k+1) % 2
                        return new_place(el.args[k])
                    return new_place(el.args)
                q = el.args[len(el.args)-1]
                if q.is_symbol or q.is_integer or q.is_rational:
                    return new_place(q)
                elif q.args[0].is_symbol:
                    return new_place(q)
                else:
                    return 0
            elif len(el.args) == 3:
                k = -1
                for i in range(0,2):
                    if el.args[i+1] not in [p,q,r,s]:
                        k = i
                if k &gt;= 0:
                    k = (k+1) % 2
                    return new_place(el.args[k+1])
                return new_place(el.args[1:])
            else:
                return 0

        def write_coeff(el):
            if isinstance(el,Pow):
                return &#34; + %s&#34; % latex(el)
            if el.is_integer:
                if el &gt; 0:
                    return &#34; + %s&#34; % el
                else:
                    return &#34; %s&#34; % el
            elif el.is_symbol:
                return &#34; + %s&#34; % el
            elif len(el.args) == 2 and el.args[0].is_symbol and el.args[1].is_symbol:
                return &#34; + %s&#34; % latex(el)
            elif len(el.args) &gt; 0:
                if el.args[len(el.args)-1].is_symbol:
                    if el.args[0].is_rational or el.args[0].is_integer:
                        if el.args[0] &gt; 0:
                            return &#34; + %s&#34; % latex(el)
                        else:
                            return &#34; %s&#34; % latex(el)
                    else:
                        return &#34; %s&#34; % latex(el)
                else:
                    if el.args[0].is_rational or el.args[0].is_integer:
                        if el.args[0] &gt; 0:
                            return &#34; + %s&#34; % latex(el)
                    return &#34; %s&#34; % latex(el)
            else:
                return &#34; %s&#34; % el
        list_place = [get_place(a) for a in expr.args]
        expr_args = list(zip(*sorted(zip(list_place,expr_args))))[1]
        to_print = [write_coeff(a) for a in expr_args]
        to_print[0] = str(latex(expr_args[0]))
        return &#34;&#34;.join(a for a in to_print)

def mylatex(e):
    p, q, r, s = symbols(&#39;p q u v&#39;)
    e = str(e)
    e = e.replace(&#39;x&#39;,&#39;p&#39;)
    e = e.replace(&#39;y&#39;,&#39;q&#39;)
    e = e.replace(&#39;z&#39;,&#39;u&#39;)
    e = e.replace(&#39;t&#39;,&#39;v&#39;)
    e = sympify(e)
    if not isinstance(e,Add):
        e = latex(e)
    else:
        e = Impresora().doprint(e)
    e = e.replace(&#39;p&#39;,&#39;x&#39;)
    e = e.replace(&#39;q&#39;,&#39;y&#39;)
    e = e.replace(&#39;u&#39;,&#39;z&#39;)
    e = e.replace(&#39;v&#39;,&#39;t&#39;)
    return e

def mcd_llista(list):
    &#34;&#34;&#34;
    Retorna el màxim comú divisor d&#39;una llista d&#39;enters
    &#34;&#34;&#34;
    return reduce(gcd, list)

def mcm_llista(list):
    &#34;&#34;&#34;
    Retorna el mínim comú múltiple d&#39;una llista d&#39;enters
    &#34;&#34;&#34;
    if len(list) == 0:
        return 1
    mcm = list[0]
    for i in list[1:]:
        mcm = mcm * i // gcd(mcm, i)
    return mcm

def mti(i,j):
    &#34;&#34;&#34;
    Funció auxiliar per crear una matriu triangular superior i uns
    o menys uns a la diagonal
    Retorna zero si el coeficients està per sota de la diagonal principal
    &#34;&#34;&#34;
    values = (-1,1)
    if i &gt; j:
        return 0
    elif i == j:
        return values[random.randint(0,1)]
    else:
        return random.randint(-1,2)

def mts(i,j,values):
    &#34;&#34;&#34;
    Funció auxiliar per crear una matriu triangular inferior i uns
    o menys uns a la diagonal
    Retorna zero si el coeficients està per sobre de la diagonal principal
    &#34;&#34;&#34;
    if i &lt; j:
        return 0
    elif i == j:
        return  values[i]
    else:
        return random.randint(-2,1)

def norma_maxim(m):
    &#34;&#34;&#34;
    Retorna el màxim en valor absolut d&#39;entre els coeficients d&#39;una matriu
    del tipus Matrix del sympy
    &#34;&#34;&#34;
    f, c = m.shape
    n = 0
    for i in range(f):
        for j in range(c):
            if abs(m[i,j]) &gt; n:
                n = abs(m[i,j])
    return n

def nzeros(m):
    &#34;&#34;&#34;
    Retorna el nombre de zeros d&#39;una matriu del tipus Matrix del sympy
    &#34;&#34;&#34;
    f, c = m.shape
    z = 0
    for i in range(f):
        for j in range(c):
            if m[i,j] == 0:
                z += 1
    return z

def nnegatius(m):
    &#34;&#34;&#34;
    Retorna el nombre d&#39;elements negatius d&#39;una matriu del tipus Matrix del sympy
    &#34;&#34;&#34;
    f, c = m.shape
    z = 0
    for i in range(f):
        for j in range(c):
            if m[i,j] &lt; 0:
                z += 1
    return z

def matriu_latex(m,format=None,ampliada=False,tipus=&#34;p&#34;):
    &#34;&#34;&#34;
    Retorna l&#39;expressió en latex d&#39;una matriu del tipus Matrix del sympy
    Parametres:
        format:   format de les columnes de la matriu. Per defecte &#34;r&#34;
        ampliada: si es vol separar amb una línia vertical l&#39;última
                  columna de la matriu
    &#34;&#34;&#34;
    f, c = m.shape
    vert = &#34;&#34;
    if ampliada:
        cols = c - 1
        vert = &#34;|r&#34;
    else:
        cols = c
    if format is None:
        text = &#34;\\begin{TIPUSmatrix}{*{%d}r%s} LINES\\end{TIPUSmatrix}&#34; % (cols,vert)
    else:
        text = &#34;\\begin{TIPUSmatrix}{%s} LINES\\end{TIPUSmatrix}&#34; % format
    text = text.replace(&#39;TIPUS&#39;,tipus)
    lines = []
    for i in range(f):
        line = []
        for j in range(c):
            line.append(latex(m[i,j]))
        lines.append(&#34; &amp; &#34;.join(map(str,line)))
    return (text.replace(&#39;LINES&#39;,&#34;\\\\ &#34;.join(lines)))

def matriu_mathematica(m):
    &#34;&#34;&#34;
    Retorna l&#39;expressió en Mathematica d&#39;una matriu del tipus Matrix del sympy
    &#34;&#34;&#34;
    r = re.compile(r&#39;sqrt\((\d+)\)&#39;)
    f, c = m.shape
    lines = []
    slines = &#34;{LINES}&#34;
    for i in range(f):
        line = []
        sline = &#34;{LINE}&#34;
        for j in range(c):
            line.append(m[i,j])
        sline = sline.replace(&#39;LINE&#39;,&#34;,&#34;.join(map(str,line)))
        sline = r.sub(r&#39;Sqrt[\g&lt;1&gt;]&#39;,sline)
        lines.append(sline)
    return (slines.replace(&#39;LINES&#39;,&#34;,&#34;.join(lines)))

def primer_no_nul(list):
    &#34;&#34;&#34;
    Retorna l&#39;índex del primer coeficient no nul d&#39;una llista
    &#34;&#34;&#34;
    if list is None or len(list) == 0:
        return None
    for i in range(len(list)):
        if list[i] != 0:
            return i
    return None

def vectors_latex(l,sep=False):
    &#34;&#34;&#34;
    Retorna la llista de vectors l escrita en latex
    Paràmetres:
        l: llista de vectors o punts
        sep: Si és False, retorna (1,2,3),(3,5,2),(1,-2,3)
             Si és True, retorna $(1,2,3)$, $(3,5,2)$ i $(1,-2,3)$
    &#34;&#34;&#34;
    if not sep:
        return &#34;,&#34;.join([str(k) for k in l])
    if len(l) == 1:
        return f&#34;${l[0]}$&#34;
    f = l[:-1]
    txt = &#34;, &#34;.join([f&#34;${k}$&#34; for k in f])
    txt += f&#34; i ${l[-1]}$&#34;
    return txt

def vaps_veps_amb_signe(result,signe=1):
    &#34;&#34;&#34;
    Donada una matriu A del sympy, result ha de ser el resultat de la funció
    r = A.eigenvects(). Aleshores aquesta funció retorna la llista valors propis
    positius (signe &gt; 0) o negatius (signe &lt; 0) i els seus vectors propis.
    Paràmetres:
        result: resultat de la funció eigenvects() del sympy
        signe: positiu o negatiu, en funció de quins valors i vectors propis es volen
    &#34;&#34;&#34;
    vaps = []
    veps = []
    for l, m, us in result:
        if l * signe &lt;= 0:
            continue
        for k in range(m):
            vaps.append(l)
            n1 = Matriu(us[k])
            vep = n1.vectors_columna()[0]
            vep.simplificar()
            veps.append(vep)
    return (vaps,veps)

def vaps_veps(result,ortogonals=False):
    &#34;&#34;&#34;
    Retorna la llista valors propis i els seus vectors propis.
    Paràmetres:
        result: resultat de la funció eigenvects() del sympy
    &#34;&#34;&#34;
    vaps = []
    veps = []
    for l, m, us in result:
        if ortogonals and m &gt; 1:
            vs = [Matriu(us[k]).vectors_columna()[0] for k in range(m)]
            b = SubespaiVectorial(vs).base_ortogonal()
            veps.extend(b)
            vaps.extend(m*[l])
        else:
            for k in range(m):
                vaps.append(l)
                n1 = Matriu(us[k])
                vep = n1.vectors_columna()[0]
                vep.simplificar()
                veps.append(vep)
    return (vaps,veps)


class Radicals(object):
    &#34;&#34;&#34;
    Classe per treure factor comú en expressions on hi apareixen arrels quadrades
    &#34;&#34;&#34;
    def __init__(self):
        self.quadrats = []
        self.enters = []
        self.fraccions = []
    #
    #
    #
    def busca_quadrats(self,el):
        &#34;&#34;&#34;
        Afegeix els termes que apareixen dins d&#39;arrels quadrades a la llista
        self.quadrats
        Paràmetres:
            el: expressió del sympy
        &#34;&#34;&#34;
        if isinstance(el,Pow) and el.args[1] == Rational(1,2):
            if el.args[0] not in self.quadrats:
                self.quadrats.append(el.args[0])
        elif isinstance(el,int) or isinstance(el,Integer):
            if el not in self.enters:
                self.enters.append(el)
        else:
            for k in el.args:
                self.busca_quadrats(k)
    #
    #
    #
    def busca_fraccions(self,el):
        &#34;&#34;&#34;
        Afegeix els termes que apareixen als denominadors a la llista
        self.fraccions
        Paràmetres:
            el: expressió del sympy
        &#34;&#34;&#34;
        if isinstance(el,Pow):
            return
        if isinstance(el,int) or isinstance(el,Integer):
            return
        if isinstance(el,Rational):
            if el.q not in self.fraccions:
                self.fraccions.append(el.q)
        for k in el.args:
            self.busca_fraccions(k)
    #
    #
    #
    def mcd(self):
        &#34;&#34;&#34;
        Retorna el màxim comú divisor dels elements de la llista self.quadrats
        &#34;&#34;&#34;
        if len(self.quadrats) == 0:
            a = 1
        else:
            a = mcd_llista(self.quadrats)
        if len(self.enters) == 0:
            b = 1
        else:
            b = mcd_llista(self.enters)
        return (a,b)
    #
    #
    #
    def mcm(self):
        &#34;&#34;&#34;
        Retorna el mínim comú múltiple dels elements de la llista self.faccions
        &#34;&#34;&#34;
        if len(self.fraccions) == 0:
            return 1
        return mcm_llista(self.fraccions)

class Vector(object):
    &#34;&#34;&#34;
    Classe que ens permetrà representar vectors i punts
    Atributs:
        dimensio: el nombre de components o longitud del vector
        components: llista amb les components del vector
        big: si ha d&#39;escrire \left( ... \right)
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,*args):
        if len(args) == 0:
            return None
        if len(args) == 1:
            if isinstance(args[0],list) or isinstance(args[0],tuple):
                return super(Vector,cls).__new__(cls)
        else:
            if isinstance(args[0],list) or isinstance(args[0],tuple):
                return None
            return super(Vector,cls).__new__(cls)
        return None
    #
    #
    #
    def __init__(self,*args):
        &#34;&#34;&#34;
        Constructor.
        Paràmetres:
           c: Una única llista de nombres o una llista de paràmetres
              que han de ser nombres
        Exemples:
           u = Vector([2,3,1,2])
           v = Vector(3,1,-2)
        &#34;&#34;&#34;
        if len(args) == 1:
            c = args[0]
        else:
            c = list(args)
        self.dimensio = len(c)
        self.components = list(c)
        self.big = False
    #
    #
    #
    @classmethod
    def nul(cls,dim):
        &#34;&#34;&#34;
        Retorna el vector nul de longitud dim
        &#34;&#34;&#34;
        l = [0 for i in range(dim)]
        return cls(l)
    #
    #
    #
    @classmethod
    def aleatori(cls,l=3,maxim=5,nuls=True,positius=False):
        &#34;&#34;&#34;
        Retorna un vector aleatori de longitud l
        Paràmetres:
           l: longitud del vector
           maxim: Nombre màxin que pot contenir en valor absolut
           nuls: Si pot contenir el valor 0 o no
           positius: Si els coeficients han de set tots positius
        &#34;&#34;&#34;
        if positius:
            c = [random.randint(1,maxim) for i in range(l)]
            values = [i for i in range(1,maxim + 1)]
            m = maxim
        else:
            c = [random.randint(-maxim,maxim) for i in range(l)]
            values = [i for i in range(1,maxim + 1)] + [-i for i in range(1,maxim + 1)]
            m = 2 * maxim - 1
        if not nuls:
            for i in range(l):
                if c[i] == 0:
                    c[i] = values[random.randint(0,m)]
        return cls(c)
    #
    #
    #
    def set_big(self,big=True):
        &#34;&#34;&#34;
           Activa o desactiva l&#39;opció \left( ... \right)
        &#34;&#34;&#34;
        self.big = big
    #
    #
    #
    def tots_enters(self):
        &#34;&#34;&#34;
        Retorna True si totes les components del vector són nombres enters
        &#34;&#34;&#34;
        for k in self.components:
            if not (isinstance(k,Integer) or isinstance(k,int)):
                return False
        return True
    #
    #
    #
    def factor_comu(self):
        &#34;&#34;&#34;
        En cas que totes les components del vector sigui enteres o racionals,
        torna el racional que es pot treure factor comú i el vector simplificat.
        Si hi ha components que no són ni enteres ni racionals, torna 1 i el mateix
        vector
        &#34;&#34;&#34;
        l = []
        s = []
        square = False
        other = False
        for k in self.components:
            if isinstance(k,Rational):
                l.append(k.q)
                s.append(False)
            elif isinstance(k,int) or isinstance(k,Integer):
                l.append(1)
                s.append(False)
            elif isinstance(k**2,Rational):
                square = True
                k2 = k**2
                l.append(k2.q)
                s.append(True)
            elif isinstance(k,Add):
                for a in k.args:
                    if isinstance(a,Rational):
                        l.append(a.q)
                        s.append(False)
                    elif isinstance(a,int) or isinstance(a,Integer):
                        l.append(1)
                        s.append(False)
                    elif isinstance(a**2,Rational):
                        square = True
                        a2 = a**2
                        l.append(a2.q)
                        s.append(True)
                    elif isinstance(a,Mul):
                        for b in a.args:
                            if isinstance(b,Rational):
                                l.append(b.q)
                                s.append(False)
            elif isinstance(k,Mul):
                for a in k.args:
                    if isinstance(a,Rational):
                        l.append(a.q)
                        s.append(False)
           # elif k in self.incognites:
           #     pass
            else:
                other = True
        if other:
            return 1, self
        if square:
            for k in range(len(l)):
                if not s[k]:
                    l[k] = l[k]**2
        m = mcm_llista(l)
        if square:
            m = sqrt(m)
        if isinstance(self,Punt):
            return m, Punt([m*k for k in self.components])
        return m, Vector([m*k for k in self.components])
    #
    #
    #
    def es_proporcional(self,other):
        &#34;&#34;&#34;
        Retorna si és proporcional al vector &#34;other&#34;
        Paràmetres:
          other: un altre vector
        &#34;&#34;&#34;
        if not isinstance(other,Vector):
            return None
        m = Matriu.from_vectors_columna([self,other])
        return m.rang() == 1
    #
    #
    #
    def __repr__(self):
        &#34;&#34;&#34;
        Retorna l&#39;expressió en latex del vector
        &#34;&#34;&#34;
        x, y, z, t = symbols(&#39;x y z t&#39;)
        x1, x2, x3, x4, x5, x6, x7, x8 = symbols(&#39;x1 x2 x3 x4 x5 x6 x7 x8&#39;)
        incognites = [x,y,z,t,x1,x2,x3,x4,x5,x6,x7,x8]
        l = []
        s = []
        square = False
        other = False
        for k in self.components:
            if isinstance(k,Rational):
                l.append(k.q)
                s.append(False)
            elif isinstance(k,int) or isinstance(k,Integer):
                l.append(1)
                s.append(False)
            elif isinstance(k**2,Rational):
                square = True
                k2 = k**2
                l.append(k2.q)
                s.append(True)
            elif isinstance(k,Add):
                for a in k.args:
                    if isinstance(a,Rational):
                        l.append(a.q)
                        s.append(False)
                    elif isinstance(a,int) or isinstance(a,Integer):
                        l.append(1)
                        s.append(False)
                    elif isinstance(a**2,Rational):
                        square = True
                        a2 = a**2
                        l.append(a2.q)
                        s.append(True)
                    elif isinstance(a,Mul):
                        for b in a.args:
                            if isinstance(b,Rational):
                                l.append(b.q)
                                s.append(False)
            elif isinstance(k,Mul):
                for a in k.args:
                    if isinstance(a,Rational):
                        l.append(a.q)
                        s.append(False)
            elif k in incognites:
                pass
            else:
                other = True
        if other:
            s = &#34;,&#34;.join([latex(k) for k in self.components])
            return f&#34;\\left({s}\\right)&#34;
        if square:
            for k in range(len(l)):
                if not s[k]:
                    l[k] = l[k]**2
        m = mcm_llista(l)
        if square:
            m = sqrt(m)
        l = [m*k for k in self.components]
        s = &#34;&#34;
        if m != 1:
            s = f&#34;\\deufrac{{1}}{{{latex(m)}}}&#34;
        r = &#34;,&#34;.join([latex(k) for k in l])
        if self.big:
            return f&#34;{s}\\left({r}\\right)&#34;
        return f&#34;{s}({r})&#34;
    #
    #
    #
    def __add__(self,other):
        &#34;&#34;&#34;
        Defineix la suma de vectors.
        Paràmetres:
            other: un altre vector
        Exemple:
            u1 = Vector(3,2,1,3)
            u2 = Vector(-2,4,-3,1)
            v = u1 + u2
        &#34;&#34;&#34;
        if not isinstance(other,Vector) and not isinstance(other,Punt):
            return None
        if self.dimensio != other.dimensio:
            return None
        c1 = self.components
        c2 = other.components
        c = []
        for i in range(self.dimensio):
            c.append(c1[i] + c2[i])
        if isinstance(self,Punt) or isinstance(other,Punt):
            return Punt(c)
        return Vector(c)
    #
    #
    #
    def __sub__(self,other):
        &#34;&#34;&#34;
        Defineix la resta de vectors.
        Paràmetres:
            other: un altre vector
        Exemple:
            u1 = Vector(3,2,1,3)
            u2 = Vector(-2,4,-3,1)
            v = u1 - u2
        &#34;&#34;&#34;
        if not isinstance(other,Vector):
            return None
        if self.dimensio != other.dimensio:
            return None
        c1 = self.components
        c2 = other.components
        c = []
        for i in range(self.dimensio):
            c.append(c1[i] - c2[i])
        if isinstance(self,Punt) and isinstance(other,Vector):
            return Punt(c)
        return Vector(c)
    #
    #
    #
    def __neg__(self):
        &#34;&#34;&#34;
        Retorna l&#39;oposat d&#39;un vector.
        Exemple:
            u1 = Vector(3,2,1,3)
            u2 = - u1
        &#34;&#34;&#34;
        p = [-k for k in self.components]
        if isinstance(self,Punt):
            return Punt(p)
        return Vector(p)
    #
    #
    #
    def __mul__(self,other):
        &#34;&#34;&#34;
        Defineix el producte d&#39;un escalar per un vector i el
        producte d&#39;una vector per una matriu.
        També el producte escalar de dos vectors
        Paràmetres:
            other: un escalar, un vector o una matriu (classe Matriu)
        Exemples:
            u1 = Vector(3,2,1,3)
            u2 = Vector(-2,4,-3,1)
            v = 5 * u1 - 4 * u2
            a = Matriu.aleatoria(f=4,c=2)
            u = v * a
            w = Vector(3,3,1,2)
            p = v * w
        &#34;&#34;&#34;
        types = [Rational,float,int,Float,Pow,Add,Mul]
        for t in types:
            if isinstance(other,t):
                if isinstance(self,Punt):
                    return Punt([other * x for x in self.components])
                return Vector([other * x for x in self.components])
        if isinstance(other,Matriu):
            if self.dimensio != other.files:
                return None
            u = Matrix(1,self.dimensio,self.components)
            v = u * other.matriu
            f, c = v.shape
            r = []
            for i in range(c):
                r.append(v[0,i])
            return Vector(r)
        if isinstance(other,Vector):
            if other.dimensio != self.dimensio:
                return None
            l = [self[i]*other[i] for i in range(self.dimensio)]
            return sum(l)
        return None
    #
    #
    #
    __rmul__ = __mul__
    #
    #
    #
    def __getitem__(self,i):
        &#34;&#34;&#34;
        Permet indexar els elements d&#39;un vector.
        Paràmetres:
            i : índex
        Exemple:
            v = Vector(3,2,1,3,5)
            x = v[2] + v[3]
        &#34;&#34;&#34;
        try:
            return self.components[i]
        except:
            return None
    #
    #
    #
    def __setitem__(self,i,value):
        &#34;&#34;&#34;
        Permet assignar valors mitjançant índexs.
        Paràmetres:
            i     : índex
            valor : valor vàlid del sympy
        Exemple:
            v = Vector.aleatori(l=4)
            v[0] = 3
        &#34;&#34;&#34;
        try:
            self.components[i] = value
        except:
            pass
    #
    #
    #
    def __eq__(self,other):
        &#34;&#34;&#34;
        Determina si dos vectors són iguals
        Paràmetres:
            other: un altre vector
        Exemple:
            u = Vector(1,2,3)
            v = Vector(1,2,3)
            if u == v:
                pass
        &#34;&#34;&#34;
        if self.dimensio != other.dimensio:
            return False
        for k in range(self.dimensio):
            if self[k] != other[k]:
                return False
        return True
    #
    #
    #
    def dot(self,other):
        &#34;&#34;&#34;
        Retorna el producte escalar de dos vectors.
        Paràmetres:
            other: un altre vector
        Exemple:
            u = Vector.aleatori(l=3)
            v = Vector.aleatori(l=3)
            p = u.dot(v)
        &#34;&#34;&#34;
        if not isinstance(other,Vector):
            return None
        if self.dimensio != other.dimensio:
            return None
        s = 0
        for i in range(self.dimensio):
            s += self.components[i] * other.components[i]
        return s
    #
    #
    #
    def length(self):
        &#34;&#34;&#34;
        Retorna la longitud o mòdul del vector
        &#34;&#34;&#34;
        s = 0
        for i in range(self.dimensio):
            s += self.components[i]**2
        return sqrt(s)
    #
    #
    #
    def normalitzar(self):
        &#34;&#34;&#34;
        Converteix el vector en unitari
        Exemple:
            u = Vector(1,2,3)
            u.normalitzar()
        &#34;&#34;&#34;
        l = self.length()
        self.components = [k / l for k in self.components]
    #
    #
    #
    def normalitzat(self):
        &#34;&#34;&#34;
        Retorna el vector unitari en la direcció i sentit del vector
        Exemple:
            u = Vector(1,2,3)
            v = u.normalitzat()
        &#34;&#34;&#34;
        l = self.length()
        return Vector([k / l for k in self.components])
    #
    #
    #
    def maxim(self):
        &#34;&#34;&#34;
        Retorna el màxim dels valors absoluts de les seves components
        Exemple:
            u = Vector.aleatori(l=5,maxim=4,nuls=False)
            m = u.maxim()
        &#34;&#34;&#34;
        m = 0
        for k in self.components:
            v = abs(k)
            if v &gt; m:
                m = v
        return m
    #
    #
    #
    def simplificar(self,positiu=False):
        &#34;&#34;&#34;
        Simplifica el vector, és a dir, converteix les seves components en una
        llista d&#39;enters amb mcd igual a 1.
        Només té sentit si totes les components del vector són nombres enters
        o racionals
        Exemple:
            u = Vector(-1,2,2,Rational(3,2))
            u.simplificar()
        &#34;&#34;&#34;
        if self.length() == 0:
            return
        d = []
        for i in range(self.dimensio):
            k = self.components[i]
            if isinstance(k,Rational):
                d.append(k.q)
            elif isinstance(k,int):
                pass
            elif isinstance(k,Integer):
                pass
            else:
                return
        mcm = mcm_llista(d)
        if mcm &lt; 0:
            mcm *= -1
        v = [mcm * x for x in self.components]
        mcd = mcd_llista(v)
        v = [simplify(k // mcd) for k in v]
        k = 0
        while v[k] == 0 and k &lt; len(v) - 1:
            k += 1
        if positiu and v[k] &lt; 0:
            v = [-x for x in v]
        self.components = list(v)
    #
    #
    #
    def radsimplificar(self):
        &#34;&#34;&#34;
        Simplifica el vector quan alguna de les seves components té radicals
        Exemple:
            u = Vector(sqrt(2),-3*sqrt(2),-sqrt(2))
            u.radsimplificar()
        &#34;&#34;&#34;
        r = Radicals()
        for k in self.components:
            r.busca_quadrats(k)
        a, b = r.mcd()
        if abs(b) != 1:
            for k in range(self.dimensio):
                self.components[k] /= b
        if len(r.quadrats) &lt;=  1:
            for k in range(self.dimensio):
                n = sqrt(a) * self.components[k]
                self.components[k] = simplify(n.expand())
            self.simplificar()
            return
        for k in range(self.dimensio):
            n = sqrt(a) * self.components[k] / a
            self.components[k] = simplify(n.expand())
        r = Radicals()
        for k in self.components:
            r.busca_fraccions(k)
        m = r.mcm()
        if m != 1:
            for k in range(self.dimensio):
                self.components[k] *= m
        self.simplificar()
    #
    #
    #
    def cross(self,other,simplificar=False):
        &#34;&#34;&#34;
        Retorna un nou vector que és el producte vectorial de dos vectors:
        Si simplificar és True, simplifica el vector resultant
        Paràmetres:
            other: un altre vector
            simplificar: si es vol simplificar el resultat o no
        Exemple:
            u = Vector.aleatori(l=3)
            v = Vector.aleatori(l=3)
            w = u.cross(v,simplificar=True)
        &#34;&#34;&#34;
        if not isinstance(other,Vector):
            return None
        if self.dimensio != other.dimensio or self.dimensio != 3:
            return None
        v1 = self.components
        v2 = other.components
        v = [v1[1] * v2[2] - v1[2] * v2[1],- v1[0] * v2[2] + v1[2] * v2[0],v1[0] * v2[1] - v1[1] * v2[0]]
        vec = Vector(v)
        if simplificar:
            vec.simplificar()
        return vec
    #
    #
    #
    def latex(self,unitari=False):
        &#34;&#34;&#34;
        Retorna l&#39;expressió en latex del vector.
        Paràmetres:
            unitari: si unitari és True, el retorna dividit per la seva longitud
        &#34;&#34;&#34;
        if unitari:
            f,v = self.factor_comu()
            l = v.length()
            if l == 1:
                return str(v)
            return f&#34;\\deufrac{{1}}{{{latex(l)}}}{str(v)}&#34;
        return str(self)
    #
    #
    #
    def components_en_base(self,base=None):
        &#34;&#34;&#34;
        Retorna un nou vector amb les components del vector (donem per fet
        que estan en la base canònica) en la base &#34;base&#34;
        Paràmetres:
            base: una base (classe Base)
        &#34;&#34;&#34;
        if base is None:
            return Vector(self.components)
        if not isinstance(base,Base):
            return None
        if self.dimensio != base.dimensio:
            return None
        c = base.matriu()
        return c.inversa() * self
    #
    #
    #
    def reordena_aleatoriament(self):
        &#34;&#34;&#34;
        Retorna un nou vector amb les components reordenades aleatoriament
        &#34;&#34;&#34;
        p = list(range(self.dimensio))
        random.shuffle(p)
        r = [self.components[i] for i in p]
        return Vector(r)
    #
    #
    #
    def nzeros(self):
        &#34;&#34;&#34;
        Retorna el nombre de zeros del vector
        &#34;&#34;&#34;
        n = 0
        for i in self.components:
            if i == 0:
                n += 1
        return n
    #
    #
    #
    def punt(self):
        &#34;&#34;&#34;
        Retorna el Punt corresponent a aquest vector
        &#34;&#34;&#34;
        return Punt(self.components)
    #
    #
    #
    def perpendicular(self):
        &#34;&#34;&#34;
        Retorna una llista de vectors perpendiculars linealment independents
        &#34;&#34;&#34;
        A = Matriu.from_vectors_fila([self])
        return A.nucli()
    #
    #
    #
    def as_quaternio(self):
        &#34;&#34;&#34;
        Retorna l&#39;expressió en LaTeX d&#39;un vector de dimensió 4 en format
        quaternió
        &#34;&#34;&#34;
        i, j, k = symbols(&#34;i j k&#34;)
        if self.dimensio != 4:
            return None
        f, v = self.factor_comu()
        s = &#34;&#34;
        if f != 1:
            s = f&#34;\\deufrac{{1}}{{{latex(f)}}}&#34;
        r = latex(v[1]*i + v[2]*j + v[3]*k)
        if v[0] != 0:
            return f&#34;{s}\\left({latex(v[0])} + {r}\\right)&#34;
        return f&#34;{s}\\left({r}\\right)&#34;
    #
    #
    #
    def diff(self,t,n=1):
        &#34;&#34;&#34;
        Retorna l&#39;enèssima derivada del vector
        &#34;&#34;&#34;
        d = [c.diff(t,n) for c in self.components]
        return Vector(d)
    #
    #
    #
    def subs(self,x,y):
        &#34;&#34;&#34;
        Retorna el vector que s&#39;obté substiuint el símbol x per y
        &#34;&#34;&#34;
        d = [c.subs(x,y) for c in self.components]
        return Vector(d)
    #
    #
    #
    def clona(self):
        &#34;&#34;&#34;
        Retorma una còpia del vector
        &#34;&#34;&#34;
        return Vector(self.components)

class Punt(Vector):
    &#34;&#34;&#34;
    Classe per treballar amb punts.
    Internament un punt és el mateix que un vector
    &#34;&#34;&#34;
    def __new__(cls,*args):
        &#34;&#34;&#34;
        Constructor.
        Paràmetres:
           c: Llista de nombres
        &#34;&#34;&#34;
        if len(args) == 0:
            return None
        if len(args) == 1:
            if isinstance(args[0],list) or isinstance(args[0],tuple):
                return super(Vector,cls).__new__(cls)
        else:
            for k in args:
                if isinstance(k,list) or isinstance(k,tuple):
                    return None
            return super(Vector,cls).__new__(cls)
        return None
    #
    #
    #
    def __init__(self,*args):
        Vector.__init__(self,*args)
    #
    #
    #
    def coordenades_en_referencia(self,ref):
        &#34;&#34;&#34;
        Retorna les coordenades del punt en la referència &#34;ref&#34;
        Paràmetres:
            ref: referència de la classe ReferenciaAfi
        &#34;&#34;&#34;
        if not isinstance(ref,ReferenciaAfi):
            return None
        if self.dimensio != ref.dimensio:
            return None
        op = self - ref.origen
        return Punt(op.components_en_base(ref.base).components)


class Base(object):
    &#34;&#34;&#34;
    Classe que ens permetrà representar bases de R^n
    Atributs:
        vecs: una llista de n vectors de R^n
        dimensio: el valor de n
        unitaria: En funcio de si volem imprimir els seus
                  vectors unitaris o no
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,vecs,unitaria=False):
        &#34;&#34;&#34;
        Contructor.
        Paràmetres:
           vecs: llista de vectors
           unitaria: True o False.
                     Serveix per si volem imprimir o fer servir els seus
                     vectors com a unitaris
        Exemple:
            base = Base([Vector(1,1),Vector(-1,1)],unitaria=True)
            print(base)
            print(base.vecs)
        &#34;&#34;&#34;
        if len(vecs) == 0:
            return None
        if not isinstance(vecs[0],Vector):
            return None
        d = vecs[0].dimensio
        for v in vecs:
            if not isinstance(v,Vector):
                return None
            if v.dimensio != d:
                return None
        m = Matriu.from_vectors_columna(vecs)
        if m.files != d:
            return None
        if m.rank() != len(vecs):
            return None
        return super(Base,cls).__new__(cls)
    #
    #
    #
    def __init__(self,vecs,unitaria=False):
        self.unitaria = unitaria
        self.vecs = vecs
        self.dimensio = vecs[0].dimensio
    #
    #
    #
    def es_unitaria(self):
        &#34;&#34;&#34;
        Retorna si la base és unitària. Notem que els vectors no es guarden
        com a unitaris.
        &#34;&#34;&#34;
        return self.unitaria
    #
    #
    #
    def es_ortogonal(self):
        &#34;&#34;&#34;
        Retorna si la base és ortogonal
        &#34;&#34;&#34;
        d = len(self.vecs)
        for i in range(d):
            for j in range(i+1,d):
                if self.vecs[i].dot(self.vecs[j]) != 0:
                    return False
        return True
    #
    #
    #
    def set_unitaria(self):
        &#34;&#34;&#34;
        Si la matriu és ortogonal, la passa a unitària
        &#34;&#34;&#34;
        if not self.es_ortogonal():
            return
        self.unitaria = True
    #
    #
    #
    def te_orientacio_positiva(self):
        &#34;&#34;&#34;
        Retorna si té orientació positiva
        &#34;&#34;&#34;
        m = Matriu.from_vectors_columna(self.vecs)
        return m.determinant() &gt; 0
    #
    #
    #
    def orientacio_positiva(self):
        &#34;&#34;&#34;
        Fa que tingui orientació positiva canviant, si cal, de signe l&#39;últim
        vector
        &#34;&#34;&#34;
        if not self.te_orientacio_positiva():
            self.vecs[-1] = - self.vecs[-1]
    #
    #
    #
    def matriu(self):
        &#34;&#34;&#34;
        Retorna la matriu de la classe Matriu que té per columnes
        els vectors de la base
        &#34;&#34;&#34;
        if not self.unitaria:
            return Matriu.from_vectors_columna(self.vecs)
        unitaris = [(1 / v.length()) * v for v in self.vecs]
        return Matriu.from_vectors_columna(unitaris)
    #
    #
    #
    @classmethod
    def from_matriu(cls,m):
        &#34;&#34;&#34;
        Crea una nova base a partir d&#39;una matriu de la classe Matriu
        Si la matriu no és quadrada o no té rang màxim, retorna None
        &#34;&#34;&#34;
        if m.files != m.columnes:
            return None
        if m.rank() != m.columnes:
            return None
        return cls(m.vectors_columna())
    #
    #
    #
    def __repr__(self):
        &#34;&#34;&#34;
        Retorna l&#39;expressió en latex de la base
        &#34;&#34;&#34;
        if not self.unitaria:
            base = &#34;,&#34;.join(map(str,self.vecs))
            return f&#34;\\{{{base}\\}}&#34;
        base = &#34;,&#34;.join([v.latex(True) for v in self.vecs])
        return f&#34;\\left\\{{{base}\\right\\}}&#34;
    #
    #
    #
    def vectors(self,unitaris=False):
        &#34;&#34;&#34;
        Retorna els vectors la base
        Paràmetres:
            unitaris: si és True, els divideix per la seva longitud
        &#34;&#34;&#34;
        if not unitaris:
            return self.vecs
        return [v/v.length() for v in self.vecs]
    #
    #
    #
    def vectors_latex(self):
        &#34;&#34;&#34;
        Retorna l&#39;expressió en latex dels vector de la base, sense les claus
        inicial i final
        &#34;&#34;&#34;
        if not self.unitaria:
            base = &#34;,&#34;.join(map(str,self.vecs))
        else:
            base = &#34;,&#34;.join([v.latex(unitari=True) for v in self.vecs])
        return f&#34;{base}&#34;
    #
    #
    #
    def vector_de_components(self,vec):
        &#34;&#34;&#34;
        Retorna un nou vector expressat en la base canònica del vector
        que en aquesta base té components &#34;vec&#34;
        Paràmetres:
            vec: vector
        &#34;&#34;&#34;
        if not isinstance(vec,Vector):
            return None
        if vec.dimensio != self.dimensio:
            return None
        c = self.matriu()
        return c * vec
    #
    #
    #
    def components_del_vector(self,vec,base=None):
        &#34;&#34;&#34;
        Retorna un nou vector expressat en aquesta base del vector
        que en la base &#34;base&#34; té components &#34;vec&#34;
        Paràmetres:
            vec: components en la base &#34;base&#34;
            base: Base
        &#34;&#34;&#34;
        if not isinstance(vec,Vector):
            return None
        if base is not None:
            if vec.dimensio != base.dimensio:
                return None
            uc = base.vector_de_components(vec)
        else:
            uc = vec
        c = self.matriu()
        return c.inversa() * uc
    #
    #
    #
    def canvi_de_base_a_la_base(self,B,p1=1,p2=0):
        &#34;&#34;&#34;
        Retorna en format latex l&#39;expressió del canvi de base de la base
        actual a la base B
        Paràmetres:
            p1: primes que s&#39;escriuran a les components en la base actual
            p2: primes que s&#39;escriuran a les components en la base B
        &#34;&#34;&#34;
        if not isinstance(B,Base):
            return None
        if self.dimensio != B.dimensio:
            return None
        c = self.matriu()
        d = B.matriu()
        A = d.inversa() * c
        if self.dimensio &lt;= 4:
            x, y, z, t = symbols(&#39;x y z t&#39;)
            components = [x,y,z,t]
        else:
            x1, x2, x3, x4, x5, x6, x7, x8 = symbols(&#39;x1 x2 x3 x4 x5 x6 x7 x8&#39;)
            components = [x1,x2,x3,x4,x5,x6,x7,x8]
        components = components[0:self.dimensio]
        ps1 = &#34;&#34;
        ps2 = &#34;&#34;
        if p1 &gt; 0:
            ps1 = p1 * &#34;&#39;&#34;
        if p2 &gt; 0:
            ps2 = p2 * &#34;&#39;&#34;
        cself = &#34; \\\\ &#34;.join([latex(k) + ps1 for k in components])
        cB = &#34; \\\\ &#34;.join([latex(k) + ps2 for k in components])
        s = &#34;\\begin{pmatrix}{c} &#34; + cB + &#34;\\end{pmatrix} = \n&#34;
        s += f&#34;{A}\n&#34;
        s += &#34;\\begin{pmatrix}{c} &#34; + cself + &#34;\\end{pmatrix}&#34;
        return s
    #
    #
    #
    @classmethod
    def ortogonal(cls,ordre=3,maxim=5,unitaria=False):
        &#34;&#34;&#34;
        Retorna una base ortogonal &#34;aleatòria&#34;
        Paràmetres:
            ordre: dimensió
            maxim: màxim per a les components dels vectors de la base
            unitaria: si és True, la base serà ortonormal
        &#34;&#34;&#34;
        trobat = False
        while not trobat:
            m = Matriu.invertible(ordre=ordre,maxim=4,mzeros=0,unitaria=True)
            L = []
            for v in m.vectors_columna():
                a = Matriu.from_vectors_columna([v])
                L.append(a.matriu)
            Q = GramSchmidt(L)
            base = []
            for m in Q:
                m = Matriu(m)
                v = m.vectors_columna()[0]
                v.simplificar()
                base.append(v)
            m = 0
            for v in base:
                a = v.maxim()
                if a &gt; m:
                    m = a
            trobat = m &lt;= maxim
        return cls(base,unitaria)
    #
    #
    #
    @classmethod
    def aleatoria(cls,dimensio=3,maxim=5,unitaria=False,mzeros=-1):
        &#34;&#34;&#34;
        Retorna una base aleàtoria
        Paràmetres:
           dimensio: Dimensió de l&#39;espai corresponent
           maxim: Nombre màxim de les components dels seus vectors
           unitaria: Si el determinant ha de ser 1 o -1
           mzeros: Nombre màxim de zeros entre les components dels seus vectors
        &#34;&#34;&#34;
        C = Matriu.invertible(ordre=dimensio,unitaria=unitaria,maxim=maxim,mzeros=mzeros)
        return cls(C.vectors_columna())
    #
    #
    #
    @classmethod
    def canonica(cls,dimensio=3):
        &#34;&#34;&#34;
        Retorna la base canònica
        Paràmetres:
           dimensio: Dimensió de l&#39;espai corresponent
        &#34;&#34;&#34;
        C = Matriu(eye(dimensio))
        return cls(C.vectors_columna())
    #
    #
    #
    def quadrats_longituds(self):
        &#34;&#34;&#34;
        Retorna els quadrats de les longituds dels vectors de la base sense tenir
        en compte si la base és unitària
        &#34;&#34;&#34;
        return [v.length()**2 for v in self.vecs]


class Matriu:
    &#34;&#34;&#34;
    Classe que ens permetrà representar matrius. El problema de la classe
    Matrix del sympy és que només es poden multiplicar per elements del tipus
    Matrix.
    Ens insteressa poder multiplicar Matrius per Vectors
    Atributs:
        dimensio: nombre de files de la matriu
        columnes: nombre de columnes de la matriu
        matriu: matriu de la classe Matrix del sympy
        format: format LateX per a la matriu
        diagonalitzable: si és o no diagonalitzable

        Només s&#39;utilitzen quan generem una matriu diagonalitzble
          vaps: llista de vectors propis de la matriu
          veps: llista de vectors propis de la matriu
    &#34;&#34;&#34;
    #
    #
    #
    def __init__(self,matrix=eye(3)):
        &#34;&#34;&#34;
        Constructor.
        Paràmetres:
          matrix: matriu del tipus Matrix de sympy
                  per defecte és la matriu unitat d&#39;ordre 3
        &#34;&#34;&#34;
        f, c = matrix.shape
        self.files = f
        self.columnes = c
        self.matriu = matrix
        self.vaps = None
        self.veps = None
        self.format = None
        self.diagonalitzable = None
    #
    #
    #
    def set_vaps(self,vaps):
        &#34;&#34;&#34;
        Assigna un llista de valors propis a la variable self.vaps
        Paràmetres:
            vaps: llista de nombres
        &#34;&#34;&#34;
        self.vaps = vaps
    #
    #
    #
    def set_veps(self,veps):
        &#34;&#34;&#34;
        Assigna un llista de vectors propis simplificats a la variable self.veps
        Paràmetres:
            vaps: llista de vectors
        &#34;&#34;&#34;
        for v in veps:
            v.simplificar()
        self.veps = veps
    #
    #
    #
    @classmethod
    def aleatoria(cls,f=3,c=3,maxim=5,nuls=True):
        &#34;&#34;&#34;
        Genera una matriu aleatoria.
        Paràmetres:
            f: nombre de files de la matriu
            c: nombre de columnes de la matriu
            maxim: tots els elements tindran valor absolut menor que &#34;maxim&#34;
            nuls: la matriu pot contenir coeficients nuls o no
        &#34;&#34;&#34;
        m = Matrix(f,c,lambda i, j : random.randint(-maxim,maxim))
        if not nuls:
            values = [i for i in range(1,maxim + 1)] + [-i for i in range(1,maxim + 1)]
            for i in range(f):
                for j in range(c):
                    if m[i,j] == 0:
                        m[i,j] = values[random.randint(0,2 * maxim - 1)]
        if nnegatius(m) &gt; (f*c)/2:
            m *= -1
        return cls(m)
    #
    #
    #
    @classmethod
    def transformacio_elemental(cls,ordre,i,j,s,t):
        &#34;&#34;&#34;
        Retorna la matriu corresponent a la transformació elemental
        F_i \sim s F_i + t F_j
        &#34;&#34;&#34;
        a = eye(ordre)
        a[i,:] = s * a[i,:] + t * a[j,:]
        return cls(a)
    #
    #
    #
    def anula_coeficient_amb_pivot(self,fc,fp):
        &#34;&#34;&#34;
        Aplicar la transformació elemental
        F_fc \sim s F_fc - t F_fp
        on s i t s&#39;obtenen de la forma següent:
           1. s és el primer coeficient no nul de la fila fp, que ocuparà la columna col
           2. t és el coeficient que ocupa la fila fc, columna col
           3. Si s i t són enters, els dividim pel seu màxim comú divisor
        Retornem la transformació elemental feta en forma de tupla (s,t)
        &#34;&#34;&#34;
        k = primer_no_nul(self.matriu[fp,:])
        if k is None:
            return 1, None
        if self.matriu[fc,k] == 0:
            return 2, None
        if primer_no_nul(self.matriu[fc,:]) != k:
            return 3, None
        s = self.matriu[fp,k]
        t = self.matriu[fc,k]
        if isinstance(s,int) or isinstance(s,Integer):
             if isinstance(t,int) or isinstance(t,Integer):
                 d = mcd_llista([t,s])
                 if abs(d) != 1:
                     s /= d
                     t /= d
        if s &lt; 0:
            s, t = -s, -t
        self.matriu[fc,:] = s * self.matriu[fc,:] - t * self.matriu[fp,:]
        return 0, (s,t)
    #
    #
    #
    def norma_maxim(self):
        &#34;&#34;&#34;
        Retorna la norma del màxim de la matriu
        &#34;&#34;&#34;
        return norma_maxim(self.matriu)
    #
    #
    #
    def nzeros(self):
        &#34;&#34;&#34;
        Retorna el nombre de zeros de la matriu
        &#34;&#34;&#34;
        return nzeros(self.matriu)
    #
    #
    #
    def nnegatius(self):
        &#34;&#34;&#34;
        Retorna el nombre de coeficients negatius de la matriu
        &#34;&#34;&#34;
        return nnegatius(self.matriu)
    #
    #
    #
    def max_diagonal(self):
        &#34;&#34;&#34;
        Retorna el màxim en valor absolut dels coeficients de la diagonal
        Si la matriu no és quadrada retorna None
        &#34;&#34;&#34;
        if self.files == 0 or self.columnes == 0:
            return 0
        max = 0
        m = min(self.files,self.columnes)
        for i in range(m):
            k = abs(self.matriu[i,i])
            if k &gt; max:
                max = k
        return max
    #
    #
    #
    def rank(self):
        &#34;&#34;&#34;
        Retorna el rang de la matriu
        &#34;&#34;&#34;
        return self.matriu.rank()
    #
    #
    #
    def rang(self):
        &#34;&#34;&#34;
        Retorna el rang de la matriu
        &#34;&#34;&#34;
        return self.matriu.rank()
    #
    #
    #
    def determinant(self):
        &#34;&#34;&#34;
        Retorna el determiant de la matriu
        &#34;&#34;&#34;
        return self.matriu.det()
    #
    #
    #
    def det(self):
        &#34;&#34;&#34;
        Retorna el determiant de la matriu
        &#34;&#34;&#34;
        return self.matriu.det()
    #
    #
    #
    def clona(self):
        &#34;&#34;&#34;
        Retorma una còpia de la matriu
        &#34;&#34;&#34;
        return Matriu(self.matriu[:,:])
    #
    #
    #
    def set_format(self,format):
        &#34;&#34;&#34;
        Estableix el format LaTeX amb que s&#39;escriurà la matriu
        &#34;&#34;&#34;
        self.format = format
    #
    #
    #
    def latex(self,format=None,tipus=&#39;p&#39;):
        &#34;&#34;&#34;
        Retorna la representació en LaTeX de la matriu
        &#34;&#34;&#34;
        if format is None:
            format = self.format
        return matriu_latex(self.matriu,format,tipus)
    #
    #
    #
    def polinomi_caracteristic(self):
        &#34;&#34;&#34;
        Retorna el polinomi característic de la matriu
        &#34;&#34;&#34;
        lamda = symbols(&#39;lamda&#39;)
        p = (-1)**(self.files) * self.matriu.charpoly(lamda)
        return latex(p.as_expr())
    #
    #
    #
    def __getitem__(self,tup):
        &#34;&#34;&#34;
        Permet indexar els elements d&#39;una matriu.
        Paràmetres:
            tup: tupla d&#39;índexs
        Exemple:
        m = Matriu.aleatoria()
        k = m[2,1]
        &#34;&#34;&#34;
        i, j = tup
        try:
            return self.matriu[i,j]
        except:
            return None
    #
    #
    #
    def __setitem__(self,tup,value):
        &#34;&#34;&#34;
        Permet assignar valors mitjançant índexs.
        Paràmetres:
            tup: tupla d&#39;índexs
            valor: valor assignat
        Exemple:
            m = Matriu.aleatoria()
            m[2,1] = 5
        &#34;&#34;&#34;
        i, j = tup
        self.matriu[i,j] = value
    #
    #
    #
    def __add__(self,other):
        &#34;&#34;&#34;
        Defineix la suma de matrius.
        Paràmetres:
            other: una altra matriu
        Exemple:
            a1 = Matriu.aleatoria()
            a2 = Matriu.aleatoria())
            b = a1 + a2
        &#34;&#34;&#34;
        if not isinstance(other,Matriu):
            return None
        if self.files != other.files:
            return None
        if self.columnes != other.columnes:
            return None
        m = self.matriu + other.matriu
        return Matriu(m)
    #
    #
    #
    def __sub__(self,other):
        &#34;&#34;&#34;
        Defineix la resta de matrius.
        Paràmetres:
            other: una altra matriu
        Exemple:
            a1 = Matriu.aleatoria()
            a2 = Matriu.aleatoria())
            b = a1 - a2
        &#34;&#34;&#34;
        if not isinstance(other,Matriu):
            return None
        if self.files != other.files:
            return None
        if self.columnes != other.columnes:
            return None
        m = self.matriu - other.matriu
        return Matriu(m)
    #
    #
    #
    def __neg__(self):
        &#34;&#34;&#34;
        Retorna l&#39;oposada de la matriu
        &#34;&#34;&#34;
        return Matriu(-self.matriu)
    #
    #
    #
    def __rmul__(self,other):
        &#34;&#34;&#34;
        Defineix el producte d&#39;un escalar per una matriu
        Paràmetrers:
            other: un escalar
        Exemple:
            a = Matriu.aleatoria(f=4,c=3,maxim=7,nuls=False)
            c = 4 * a
        &#34;&#34;&#34;
        types = [Rational,float,int,Float,Pow,Add,Mul]
        for t in types:
            if isinstance(other,t):
                return Matriu(other * self.matriu)
        return None
    #
    #
    #
    def __mul__(self,other):
        &#34;&#34;&#34;
        Defineix el producte de matrius i el producte d&#39;una matriu per un vector
        Paràmetrers:
            other: un vector (classe Vector) o un matriu (classe Matriu)
        Exemple:
            a1 = Matriu.aleatoria()
            a2 = Matriu.aleatoria()
            b = a1 * a2
            v = Vector(2,1,-1)
            w = a1 * v
        &#34;&#34;&#34;
        if isinstance(other,Matriu):
            if self.columnes != other.files:
                return None
            m = self.matriu * other.matriu
            return Matriu(m)
        if isinstance(other,Vector):
            if self.columnes != other.dimensio:
                return None
            u = Matrix(other.dimensio,1,other.components)
            v = self.matriu * u
            f, c = v.shape
            c = []
            for i in range(f):
                c.append(v[i,0])
            return Vector(c)
        return None
    #
    #
    #
    def transposada(self):
        &#34;&#34;&#34;
        Retorna la transposada de la matriu
        &#34;&#34;&#34;
        return Matriu(self.matriu.T)
    #
    #
    #
    def __repr__(self):
        &#34;&#34;&#34;
        Retorna l&#39;expressió en LaTeX de la matriu
        &#34;&#34;&#34;
        l = []
        s = []
        square = False
        for i in range(self.files):
            for j in range(self.columnes):
                k = self.matriu[i,j]
                if isinstance(k,Rational):
                    l.append(k.q)
                    s.append(False)
                elif isinstance(k,int) or isinstance(k,Integer):
                    l.append(1)
                    s.append(False)
                elif isinstance(k**2,Rational):
                    square = True
                    k2 = k**2
                    l.append(k2.q)
                    s.append(True)
                elif isinstance(k,Add):
                    for a in k.args:
                        if isinstance(a,Rational):
                            l.append(a.q)
                            s.append(False)
                        elif isinstance(a,int) or isinstance(a,Integer):
                            l.append(1)
                            s.append(False)
                        elif isinstance(a**2,Rational):
                            square = True
                            a2 = a**2
                            l.append(a2.q)
                            s.append(True)
                else:
                    return matriu_latex(self.matriu,format=self.format)
        if square:
            for k in range(len(l)):
                if not s[k]:
                    l[k] = l[k]**2
        m = mcm_llista(l)
        if square:
            m = sqrt(m)
        l = []
        for i in range(self.files):
            for j in range(self.columnes):
                l.append(m * self.matriu[i,j])
        s = &#34;&#34;
        if m != 1:
            s = f&#34;\\deufrac{{1}}{{{latex(m)}}}&#34;
        m = Matrix(self.files,self.columnes,l)
        return s + matriu_latex(m,format=self.format)
    #
    #
    #
    def __eq__(self,other):
        &#34;&#34;&#34;
        Compara si dues matriu són iguals
        Paràmetres:
            other: una altra matriu
        Exemple:
            a1 = Matriu.aleatoria()
            a2 = Matriu.aleatoria()
            if a1 == a2:
                pass
        &#34;&#34;&#34;
        if self.files != other.files:
            return False
        if self.columnes != other.columnes:
            return False
        for i in range(self.files):
            for j in range(self.columnes):
                if self.matriu[i,j] != other.matriu[i,j]:
                    return False
        return True
    #
    #
    #
    @classmethod
    def diagonal(cls,vals):
        &#34;&#34;&#34;
        Retorna una matriu diagonal amb valors &#34;vals&#34; a la diagonal
        Paràmetres:
            vals: llista d&#39;escalars o vector (class Vector o Punt)
        &#34;&#34;&#34;
        if isinstance(vals,Vector):
            vals = vals.components
        if not isinstance(vals,list) and not isinstance(vals,tuple):
            return None
        d = len(vals)
        if d == 0:
            return None
        m = diag(*vals)
        return cls(m)
    #
    #
    #
    @classmethod
    def amb_rang(cls,f=3,c=3,r=3,maxim=5,mzeros=-1):
        &#34;&#34;&#34;
        Retorna una matriu aleatoria amb rang r.
        Paràmetres:
          f: nombre de files de la matriu
          c: nombre de columnes de la matriu
          r: rang de la matriu
          maxim: tots els elements tindran valor absolut menor que &#34;maxim&#34;
          mzeros: nombre màxim de zeros. Si és -1, no hi ha màxim
        &#34;&#34;&#34;
        values = [-1,1,2]
        trobat = False
        while not trobat:
            mc = cls.invertible(f,maxim=2,mzeros=2,unitaria=True)
            md = cls.invertible(c,maxim=2,mzeros=2,unitaria=True)
            m = Matrix.zeros(f,c)
            for k in range(r):
                m[k,k] = values[random.randint(0,2)]
            n = mc.matriu * m * md.matriu
            if mzeros &gt;= 0 and nzeros(n) &gt; mzeros:
                continue
            trobat = norma_maxim(n) &lt;= maxim
        if nnegatius(n) &gt; f*c/2:
            n *= -1
        return cls(n)
    #
    #
    #
    def inversa(self):
        &#34;&#34;&#34;
        Retorna una nova matriu que és la inversa de l&#39;actual
        &#34;&#34;&#34;
        return Matriu(self.matriu**(-1))
    #
    #
    #
    def adjunta(self):
        &#34;&#34;&#34;
        Retorna una nova matriu que és l&#39;adjunta de l&#39;actual
        &#34;&#34;&#34;
        return Matriu(self.matriu.adjugate().T)
    #
    #
    #
    @classmethod
    def invertible(cls,ordre=3,maxim=5,mzeros=-1,unitaria=False):
        &#34;&#34;&#34;
        Retorna una matriu quadrada aleatoria invertible.
        Paràmetres:
            ordre: nombre de files i columnes de la matriu
            maxim: tots els elements tindran valor absolut menor que &#34;maxim&#34;
            mzeros: si nzeros &gt;= 0, nombre màxim de zeros que tindrà la matrius
                    si nzeros &lt; 0, el nombre de zeros no està limitat
            unitaria: si volem que el determinant sigui 1 o -1
        &#34;&#34;&#34;
        opcions = []
        for i in range(1,13):
            opcions += [i for j in range(0,2**(13-i))] + [-i for j in range(0,2**(13-i))]
        unitats = (-1,1)
        els = len(opcions)
        random.shuffle(opcions)
        trobat = False
        while not trobat:
            if unitaria:
                values = [unitats[random.randint(0,1)] for i in range(ordre)]
            else:
                values = [opcions[random.randint(0,els-1)] for i in range(ordre)]
            ti = Matrix(ordre,ordre,lambda i, j : mti(i,j))
            ts = Matrix(ordre,ordre,lambda i, j : mts(i,j,values))
            m = ti * ts
            if norma_maxim(m) &gt; maxim:
                continue
            if mzeros &gt;= 0 and nzeros(m) &gt; mzeros:
                continue
            trobat = True
        if nnegatius(m) &gt; ordre**2/2:
            m *= -1
        return cls(m)
    #
    #
    #
    @classmethod
    def diagonalitzable(cls,ordre=3,maxim=5,mzeros=-1,mvaps=3,vapsnuls=False,vapsrepetits=True):
        &#34;&#34;&#34;
        Retorna una matriu quadrada aleatoria diagonalitzable.
        Paràmetres:
            ordre: nombre de files i columnes de la matriu
            maxim: tots els elements tindran valor absolut menor o igual que &#34;maxim&#34;
            mzeros: si nzeros &gt;= 0, nombre màxim de zeros que tindrà la matrius
                    si nzeros &lt; 0, el nombre de zeros no està limitat
            mvaps: tots els valors propis tindran valor absolut menor o igual que &#34;mvaps&#34;
            vapsnuls: si hi pot aparèixer el valor propi nul
            vapsrepetits: si hi pot aparèixer valors propis repetits
        &#34;&#34;&#34;
        trobat = False
        while not trobat:
            c = Matriu.invertible(ordre=ordre,maxim=3,mzeros=0,unitaria=True)
            v = [-i for i in range(1,mvaps+1)] + [i for i in range(1,mvaps+1)]
            if vapsnuls:
                vaps = [random.randint(-mvaps,mvaps) for i in range(ordre)]
            else:
                vaps = [v[random.randint(0,2*mvaps-1)] for i in range(ordre)]
            if not vapsnuls and 0 in vaps:
                continue
            if len(set(vaps)) == 1:
                continue
            if not vapsrepetits and len(set(vaps)) != ordre:
                continue
            if vapsrepetits and len(set(vaps)) == ordre:
                continue
            vaps.sort()
            d = diag(*vaps)
            a = c.matriu * d * c.matriu**(-1)
            if norma_maxim(a) &gt; maxim:
                continue
            if mzeros &gt;= 0 and nzeros(a) &gt; mzeros:
                continue
            trobat = True
        m = cls(a)
        m.set_vaps(vaps)
        m.set_veps(c.vectors_columna())
        m.diagonalitzable = True
        return m
    #
    #
    #
    def diagonalitza(self,ortogonals=False):
        &#34;&#34;&#34;
           Calcula els valors propis i els vectors propis de la matriu i els
           guarda a les variables self.vaps i self.veps. Actualitza el camp
           self.diagonalitzable
        &#34;&#34;&#34;
        if self.files != self.columnes:
            return
        e = self.matriu.eigenvects()
        self.vaps, self.veps = vaps_veps(e,ortogonals=ortogonals)
        self.diagonalitzable = False
        if len(self.vaps) == self.files:
            self.diagonalitzable = True
    #
    #
    #
    @classmethod
    def gram(cls,ordre=3,maxim=5,mzeros=-1):
        &#34;&#34;&#34;
        Retorna una matriu quadrada aleatoria que serà d&#39;un producte escalar,
        és a dir, una matriu de Gram
        Paràmetres:
            ordre: nombre de files i columnes de la matriu
            maxim: tots els elements tindran valor absolut menor o igual que &#34;maxim&#34;
            mzeros: si nzeros &gt;= 0, nombre màxim de zeros que tindrà la matrius
                    si nzeros &lt; 0, el nombre de zeros no està limitat
        &#34;&#34;&#34;
        trobat = False
        while not trobat:
            c = Matriu.invertible(ordre,maxim=5)
            g = c.transposada() * c
            if mzeros &gt;= 0 and g.nzeros() &gt; mzeros:
                continue
            if g.norma_maxim() &gt; maxim:
                continue
            trobat = True
        return cls(g.matriu)
    #
    #
    #
    @classmethod
    def matriu_fila(cls,v):
        &#34;&#34;&#34;
        Retorna una nova matriu fila a partir de les components del vector v
        Paràmetres:
            v: vector o punt
        &#34;&#34;&#34;
        if not isinstance(v,Vector):
            return None
        m = Matrix(1,v.dimensio,v.components)
        return cls(m)
    #
    #
    #
    @classmethod
    def matriu_columna(cls,v):
        &#34;&#34;&#34;
        Retorna una nova matriu columna a partir de les components del vector v
        Paràmetres:
            v: vector o punt
        &#34;&#34;&#34;
        if not isinstance(v,Vector):
            return None
        m = Matrix(v.dimensio,1,v.components)
        return cls(m)
    #
    #
    #
    @classmethod
    def from_vectors_fila(cls,vecs):
        &#34;&#34;&#34;
        Retorna una nova matriu a partir d&#39;una llista de vectors.
        Les components dels vectors seran les files de la nova matriu
        Paràmetres:
            v: llista de vectors o punts
        &#34;&#34;&#34;
        if len(vecs) == 0:
            return None
        if not isinstance(vecs[0],Vector):
            return None
        c = vecs[0].dimensio
        f = len(vecs)
        l = []
        for v in vecs:
            if not isinstance(v,Vector):
                return None
            if v.dimensio != c:
                return None
            l += v.components
        m = Matrix(f,c,l)
        return cls(m)
    #
    #
    #
    @classmethod
    def from_vectors_columna(cls,vecs):
        &#34;&#34;&#34;
        Retorna una nova matriu a partir d&#39;una llista de vectors.
        Les components dels vectors seran les columnes de la nova matriu
        Paràmetres:
            v: llista de vectors o punts
        &#34;&#34;&#34;
        if not (isinstance(vecs,list) or isinstance(vecs,tuple)):
            return None
        if len(vecs) == 0:
            return None
        if not isinstance(vecs[0],Vector):
            return None
        c = vecs[0].dimensio
        f = len(vecs)
        l = []
        for v in vecs:
            if not isinstance(v,Vector):
                return None
            if v.dimensio != c:
                return None
            l += v.components
        m = Matrix(f,c,l)
        return cls(m.T)
    #
    #
    #
    @classmethod
    def identitat(cls,ordre):
        &#34;&#34;&#34;
        Retorna la matriu identitat
        Paràmetres:
            ordre: ordre de la matriu identitat
        &#34;&#34;&#34;
        return cls(eye(ordre))
    #
    #
    #
    def vectors_columna(self,simplificar=False):
        &#34;&#34;&#34;
        Retorna una llista amb els vectors columna de la matriu
        Paràmetres:
            simplificar: si és True retornarà els vectors simplificats
        &#34;&#34;&#34;
        vecs = []
        m = self.matriu
        for i in range(self.columnes):
            v = [m[j,i] for j in range(self.files)]
            u = Vector(v)
            if simplificar:
                u.simplificar()
            vecs.append(u)
        return vecs
    #
    #
    #
    def vectors_fila(self,simplificar=False):
        &#34;&#34;&#34;
        Retorna una llista amb els vectors fila de la matriu
        Paràmetres:
            simplificar: si és True retornarà els vectors simplificats
        &#34;&#34;&#34;
        vecs = []
        m = self.matriu
        for i in range(self.files):
            v = [m[i,j] for j in range(self.columnes)]
            u = Vector(v)
            if simplificar:
                u.simplificar()
            vecs.append(u)
        return vecs
    #
    #
    #
    def nucli(self):
        &#34;&#34;&#34;
        Retorna una llista de vectors que formen una base del nucli de la matriu
        &#34;&#34;&#34;
        n = self.matriu.nullspace()
        vecs = []
        for i in range(len(n)):
            m = Matriu(n[i])
            vecs += m.vectors_columna()
        for v in vecs:
            v.simplificar()
        return vecs
    #
    #
    #
    def es_simetrica(self):
        &#34;&#34;&#34;
        Retorna True si és simètrica
        &#34;&#34;&#34;
        return self == self.transposada()
    #
    #
    #
    def es_diagonal(self):
        &#34;&#34;&#34;
        Retorna True si és una matriu diagonal
        &#34;&#34;&#34;
        for i in range(self.files):
            for j in range(self.columnes):
                if i != j and self.matriu[i,j] != 0:
                    return False
        return True
    #
    #
    #
    def intercanvia_columnes(self,i,j):
        &#34;&#34;&#34;
        Retorna una matriu amb les columnes i i j permutades
        Paràmetres:
            i, j: índexs de les columnes
        &#34;&#34;&#34;
        if i &gt;= self.columnes or j &gt;= self.columnes:
            return None
        if i == j:
            return Matriu(self.matriu)
        c = self.vectors_columna()
        k = c[i]
        c[i] = c[j]
        c[j] = k
        return Matriu.from_vectors_columna(c)
    #
    #
    #
    def reordena_aleatoriament_columnes(self):
        &#34;&#34;&#34;
        Retorna una nova matriu amb les columnes reordenades aleatòriament
        &#34;&#34;&#34;
        c = self.vectors_columna()
        p = list(range(self.columnes))
        random.shuffle(p)
        d = [c[i] for i in p]
        return Matriu.from_vectors_columna(d)
    #
    #
    #
    def reordena_aleatoriament_files(self):
        &#34;&#34;&#34;
        Retorna una nova matriu amb les files reordenades aleatòriament
        &#34;&#34;&#34;
        c = self.vectors_fila()
        p = list(range(self.files))
        random.shuffle(p)
        d = [c[i] for i in p]
        return Matriu.from_vectors_fila(d)
    #
    #
    #
    def inserta_fila(self,pos,fila):
        &#34;&#34;&#34;
        Retorna una nova matriu amb la fila &#34;fila&#34; insertada a la posició &#34;pos&#34;
        Paràmetrers:
            fila: nova fila de la matriu
            pos: posició que ha d&#39;ocupar la nova fila
        &#34;&#34;&#34;
        if not isinstance(fila,Vector):
            return None
        if fila.dimensio != self.columnes:
            return None
        if pos &gt; self.files:
            pos = self.files
        files = self.vectors_fila()
        files.insert(pos,fila)
        return Matriu.from_vectors_fila(files)
    #
    #
    #
    def inserta_columna(self,pos,columna):
        &#34;&#34;&#34;
        Retorna una nova matriu amb la columna &#34;columna&#34; insertada a la posició &#34;pos&#34;
        Paràmetrers:
            columna: nova columna de la matriu
            pos: posició que ha d&#39;ocupar la nova columna
        &#34;&#34;&#34;
        if not isinstance(columna,Vector):
            return None
        if columna.dimensio != self.files:
            return None
        if pos &gt; self.columnes:
            pos = self.columnes
        columnes = self.vectors_columna()
        columnes.insert(pos,columna)
        return Matriu.from_vectors_columna(columnes)
    #
    #
    #
    def factor_comu(self):
        &#34;&#34;&#34;
        Retorna quin factor comú podem treure de la matriu
        &#34;&#34;&#34;
        d = []
        for i in range(self.files):
            for j in range(self.columnes):
                k = self[i,j]
            if (isinstance(k,int) or isinstance(k,Integer)):
                d.append(k)
            else:
                return 1
        return (mcd_llista(d))
    #
    #
    #
    def simplificar(self):
        &#34;&#34;&#34;
        Simplifica la matriu, és a dir, converteix les seves entrades en una
        llista d&#39;enters amb mcd igual a 1.
        Només té sentit si totes les components del vector són nombres enters
        o racionals
        &#34;&#34;&#34;
        d = []
        for i in range(self.columnes):
            for j in range(self.files):
                if isinstance(self.matriu[i,j],Rational):
                    d.append(self.matriu[i,j].q)
                elif isinstance(self.matriu[i,j],int):
                    pass
                elif isinstance(self.matriu[i,j],Integer):
                    pass
                else:
                    return
        mcm = mcm_llista(d)
        m = mcm * self.matriu
        d = []
        for i in range(self.columnes):
            for j in range(self.files):
                d.append(m[i,j])
        mcd = mcd_llista(d)
        for i in range(self.columnes):
            for j in range(self.files):
                self.matriu[i,j] = m[i,j] // mcd
        if self.matriu[0,0] &lt; 0:
            self.matriu = - self.matriu
    #
    #
    #
    def submatriu(self,files,columnes):
        &#34;&#34;&#34;
        Retorna la submatriu determinada per les files &#34;files&#34; i les
        columnes &#34;columnes&#34;.
        Paràmetrers:
            files: llista de files
            columnes: llista de columnes
        &#34;&#34;&#34;
        if not (isinstance(files,list) or isinstance(files,tuple)):
            return None
        if not (isinstance(columnes,list) or isinstance(columnes,tuple)):
            return None
        if max(columnes) &gt;= self.columnes or min(columnes) &lt; 0:
            return None
        if max(files) &gt;= self.files or min(files) &lt; 0:
            return None
        m = self.matriu[files,columnes]
        return Matriu(m)
    #
    #
    #
    def subs(self,l):
        &#34;&#34;&#34;
        Aplica una llista de substitucions
        Paràmetres:
            l: llista de substitucions
        &#34;&#34;&#34;
        for i in range(self.columnes):
            for j in range(self.files):
                for d in l:
                    self[i,j] = self[i,j].subs(d)
    #
    #
    #
    def sistema_propi(self):
        &#34;&#34;&#34;
        Retorna el sistema d&#39;equacions en format latex corresponent al
        càlcul dels valors propis de la matriu
        &#34;&#34;&#34;
        if self.columnes &lt;= 4:
            x, y, z, t = symbols(&#39;x y z t&#39;)
            unknowns = [x,y,z,t]
        else:
            x1, x2, x3, x4, x5, x6, x7, x8 = symbols(&#39;x1 x2 x3 x4 x5 x6 x7 x8&#39;)
            unknowns = [x1,x2,x3,x4,x5,x6,x7,x8]
        unknowns = unknowns[0:self.columnes]
        A = self * Vector(unknowns)
        eqs = [f&#34;{latex(A[i])} &amp;= \\lambda {unknowns[i]}&#34; for i in range(A.dimensio)]
        eqs = &#34; \\\\ &#34;.join(eqs)
        return f&#34;\\left.\\aligned {eqs} \\endaligned\\;\\right\\}}&#34;


class EquacioLineal:
    &#34;&#34;&#34;
    Classe per treballar amb equacions lineals.
    Atributs:
        equacio: terme de l&#39;esquerra en la equacio &#34;eq = 0&#34;
        unknowns: incògnites que apareixen a l&#39;equació
        amp: True o False
        prime: nombre de primes que escriurem a l&#39;equació
    &#34;&#34;&#34;
    #
    #
    #
    def __init__(self,eq,amp=False,prime=0):
        &#34;&#34;&#34;
        Constructor.
        Paràmentres:
           eq: expressió lineal que ha de contenir tots els termes, aleshores
               l&#39;equació serà &#34;eq = 0&#34;. Només guardem la part &#34;eq&#34;
           amp: quan escrivim l&#39;equació en latex ha d&#39;aparèixer &amp;= o només =
           prime: nombre de primes que s&#39;han de posar a les incògnites

         Per exemple:
         x, y, z, t = symbols(&#39;x y z t&#39;)
         eq = 2*x-3*y+4*z-3*t-4
         e = EquacioLineal(eq)
        &#34;&#34;&#34;
        x, y, z, t = symbols(&#39;x y z t&#39;)
        x1, x2, x3, x4, x5, x6, x7, x8 = symbols(&#39;x1 x2 x3 x4 x5 x6 x7 x8&#39;)
        incognites = [x,y,z,t,x1,x2,x3,x4,x5,x6,x7,x8]
        self.equacio = eq
        self.amp = amp
        d = self.equacio.as_coefficients_dict()
        self.unknowns = []
        for k in incognites:
            if diff(eq,k) != 0:
                self.unknowns.append(k)
        self.prime = prime
    #
    #
    #
    @classmethod
    def coeficients(cls,a,b,amp=False,prime=0):
        &#34;&#34;&#34;
        Retorna una nova equació amb coeficients de les incògnites el vector &#34;a&#34; i
        terme independent b
        Paràmetres:
            a: Vector amb els coeficients de les incògnites
            b: terme independents
            amp: si és True l&#39;equació s&#39;escriurà amb el &amp;= per al LaTeX
            prime: nombre de primes que s&#39;escriuran a les incògnites
        &#34;&#34;&#34;
        if not isinstance(a,Vector):
            return None
        if a.dimensio &lt;= 4:
            x, y, z, t = symbols(&#39;x y z t&#39;)
            unknowns = [x,y,z,t]
        else:
            x1, x2, x3, x4, x5, x6, x7, x8 = symbols(&#39;x1 x2 x3 x4 x5 x6 x7 x8&#39;)
            unknowns = [x1,x2,x3,x4,x5,x6,x7,x8]
        eq = 0
        for k in range(a.dimensio):
            eq += a[k] * unknowns[k]
        eq = simplify((eq - b).expand())
        return cls(eq,amp,prime)
    #
    #
    #
    def set_coeficient_positiu(self,incogs):
        &#34;&#34;&#34;
        Busca el primer coeficient no nul d&#39;entre les incògnites &#34;incogs&#34;, si el primer
        que troba és negatiu, canvia l&#39;equació de signe

        canvia de signe tota l&#39;equació, de
        manera que el coeficients de &#34;k&#34; passa a ser positiu
        &#34;&#34;&#34;
        d = self.equacio.as_coefficients_dict()
        for k in incogs:
            if d[k] == 0:
                continue
            if d[k] &lt; 0:
                self.equacio *= -1
                return
            return
    #
    #
    #
    def terme_independent(self):
        &#34;&#34;&#34;
        Retorna el terme independent de l&#39;equació
        &#34;&#34;&#34;
        d = self.equacio.as_coefficients_dict()
        return -d[1]

    #
    #
    #
    def __repr__(self):
        &#34;&#34;&#34;
        Retorna l&#39;expressió en latex de l&#39;equació.
        Si els coeficients són enters o racionals, treu el denominador comú
        &#34;&#34;&#34;
        t = symbols(&#39;t&#39;)
        x1, x2, x3, x4, x5, x6, x7, x8 = symbols(&#39;x1 x2 x3 x4 x5 x6 x7 x8&#39;)
        incgs = {x1, x2, x3, x4, x5, x6, x7, x8}
        other = False
        d = self.equacio.as_coefficients_dict()
        l = list(d.values())
        m = []
        for k in l:
            if isinstance(k,Rational):
                m.append(k.q)
            elif isinstance(k,int) or isinstance(k,Integer):
                pass
            else:
                other = True
        if not other:
            mcm = mcm_llista(m)
            v = [mcm * x for x in l]
            mcd = mcd_llista(v)
            factor = Rational(mcm,mcd)
            eq = 0
            terme = 0
            for k in d.keys():
                if k.is_symbol and k not in self.unknowns:
                    terme += factor * d[k] * k
                else:
                    d[k] = factor * d[k]
                    eq += d[k] * k
        else:
            eq = self.equacio
        eq -= d[1]
        if t in self.unknowns:
            str = mylatex(eq)
        else:
            if len(incgs &amp; set(self.unknowns)) &gt; 0:
                str = latex(simplify(eq.expand()))
            else:
                str = mylatex(simplify(eq.expand()))
        if self.amp:
            str = f&#34;{str} &amp;= {latex(-d[1] - terme)}&#34;
        else:
            str = f&#34;{str} = {latex(-d[1] - terme)}&#34;
        if self.prime &gt; 0:
            s = self.prime * &#34;&#39;&#34;
            for i in self.unknowns:
                str = str.replace(latex(i),latex(i) + s)
        return str
    #
    #
    #
    def __add__(self,other):
        &#34;&#34;&#34;
        Suma d&#39;equacions
        Paràmetres:
            other: una altra equació
        &#34;&#34;&#34;
        if not isinstance(other,EquacioLineal):
            return None
        if self.prime != other.prime:
            return None
        eq = self.equacio + other.equacio
        return EquacioLineal(eq,self.amp or other.amp)
    #
    #
    #
    def __sub__(self,other):
        &#34;&#34;&#34;
        Resta d&#39;equacions
        Paràmetres:
            other: una altra equació
        &#34;&#34;&#34;
        if not isinstance(other,EquacioLineal):
            return None
        if self.prime != other.prime:
            return None
        eq = self.equacio - other.equacio
        return EquacioLineal(eq,self.amp or other.amp)
    #
    #
    #
    def __mul__(self,other):
        &#34;&#34;&#34;
        Producte d&#39;un escalar per una equació
        Paràmetres:
            other: un escalar
        &#34;&#34;&#34;
        types = [Rational,float,int,Float,Pow,Add,Mul]
        for t in types:
            if isinstance(other,t):
                return EquacioLineal(other * self.equacio,self.amp)
        return None
    #
    #
    #
    __rmul__ = __mul__
    #
    #
    #
    def to_sistema_equacions(self):
        &#34;&#34;&#34;
        Retorna un sistema d&#39;equacions (class SistemaEquacions) que té com a única
        equació l&#39;actual
        &#34;&#34;&#34;
        x, y, z, t = symbols(&#39;x y z t&#39;)
        unknowns = [x,y,z,t]
        n = -1
        for u in self.unknowns:
            m = unknowns.index(u)
            if m &gt; n:
                n = m
        if n &gt;= 0:
            return SistemaEquacions.from_equacions([self.equacio],n+1,self.prime)
        x1, x2, x3, x4, x5, x6, x7, x8 = symbols(&#39;x1 x2 x3 x4 x5 x6 x7 x8&#39;)
        unknowns = [x1,x2,x3,x4,x5,x6,x7,x8]
        for u in self.unknowns:
            m = unknowns.index(u)
            if m &gt; n:
                n = m
        return SistemaEquacions.from_equacions([self.equacio],n+1,self.prime)
    #
    #
    #
    def resol(self,unknown):
        &#34;&#34;&#34;
        Resol l&#39;equació aïllant la incògnita &#39;unknown&#39;
        &#34;&#34;&#34;
        return solve(self.equacio,unknown)[0]


class SistemaEquacions:
    &#34;&#34;&#34;
    Classe per treballar amb sistemes d&#39;equacions lineals
    Atributs:
      A: matriu dels coeficients de les incógnites
      B: vector de termes independents
      equacions: llista de EquacioLineal
      nombre: nombre d&#39;equacions
      solucio: solucio del sistema d&#39;equacions
      secundaries: incògnites secundàries a la solució
      parametrica: solucio paramètrica del sistema d&#39;equacions
      parametres: paràmetres que apareixen a la solució paramètrica
      unknowns: llista d&#39;incògnites
      prime: nombre de primes que escriurem a l&#39;equació
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,a,b,unknowns=None,prime=0):
        &#34;&#34;&#34;
        Constructor.
        Paràmetres:
          a: matriu dels coeficients de les incògnites
          b: Termes independents
        &#34;&#34;&#34;
        if not isinstance(a,Matriu):
            return None
        if not isinstance(b,Vector):
            return None
        if a.files != b.dimensio:
            return None
        if unknowns is not None:
            if not (isinstance(unknowns,list) or isinstance(unknowns,tuple)):
                return None
            if len(unknowns) != a.columnes:
                return None
        return super(SistemaEquacions,cls).__new__(cls)
    #
    #
    #
    def __init__(self,a,b,unknowns=None,prime=0):
        self.A = a
        self.B = b
        self.solucio = None
        self.parametrica = None
        self.parametres = []
        self.secundaries = []
        eq = []
        files = a.vectors_fila()
        for k in range(self.A.files):
            eq.append(EquacioLineal.coeficients(files[k],b[k],amp=True,prime=0))
        self.equacions = eq
        self.nombre = len(eq)
        if unknowns is not None:
            self.unknowns = unknowns
        else:
            if self.A.columnes &lt;= 4:
                x, y, z, t = symbols(&#39;x y z t&#39;)
                unknowns = [x,y,z,t]
            else:
                x1, x2, x3, x4, x5, x6, x7, x8 = symbols(&#39;x1 x2 x3 x4 x5 x6 x7 x8&#39;)
                unknowns = [x1,x2,x3,x4,x5,x6,x7,x8]
            self.unknowns = unknowns[0:self.A.columnes]
        self.prime = prime
    #
    #
    #
    @classmethod
    def from_equacions(cls,eqs,nombre,prime=0):
        &#34;&#34;&#34;
        Retorna un sistema d&#39;equacions amb equacions &#34;eqs&#34;
        Paràmetres:
            eqs: llista de EquacioLineal
            nombre: nombre d&#39;incògnites
            prime: nombre de primes que s&#39;escriuran a les incògnites
        &#34;&#34;&#34;
        if nombre &lt;= 4:
            x, y, z, t = symbols(&#39;x y z t&#39;)
            unknowns = [x,y,z,t]
        else:
            x1, x2, x3, x4, x5, x6, x7, x8 = symbols(&#39;x1 x2 x3 x4 x5 x6 x7 x8&#39;)
            unknowns = [x1,x2,x3,x4,x5,x6,x7,x8]
        unknowns = unknowns[0:nombre]
        t = []
        vecs = []
        for e in eqs:
            if isinstance(e,EquacioLineal):
                d = e.equacio.as_coefficients_dict()
            else:
                d = e.as_coefficients_dict()
            c = []
            for k in unknowns:
                c.append(d[k])
            t.append(-d[1])
            vecs.append(Vector(c))
        a = Matriu.from_vectors_fila(vecs)
        b = Vector(t)
        return cls(a,b,prime=prime)
    #
    #
    #
    def __repr__(self):
        &#34;&#34;&#34;
        Retorna l&#39;expressió en latex del sistema d&#39;equacions
        &#34;&#34;&#34;
        p = &#34;&#34;
        eqs = list(map(str,self.equacions))
        if self.prime &gt; 0:
            p = self.prime * &#34;&#39;&#34;
        if len(eqs) == 0:
            return &#34;&#34;
        if len(eqs) == 1:
            for k in self.unknowns:
                eqs[0] = eqs[0].replace(latex(k),latex(k) + p)
            return eqs[0].replace(&#39;&amp;&#39;,&#39;&#39;)
        eqs = &#34; \\\\ &#34;.join(eqs)
        for k in self.unknowns:
            eqs = eqs.replace(latex(k),latex(k) + p)
        return f&#34;\\left.\\aligned {eqs} \\endaligned\\;\\right\\}}&#34;
    #
    #
    #
    def matriu_incognites(self):
        &#34;&#34;&#34;
        Retorna la matriu dels coeficients de les incògnites expressada
        en LaTeX
        &#34;&#34;&#34;
        return f&#34;{self.A}&#34;
    #
    #
    #
    def matriu_ampliada(self):
        &#34;&#34;&#34;
        Retorna la matriu ampliada del sistema d&#39;equacions expressada
        en LaTeX
        &#34;&#34;&#34;
        c = self.A.inserta_columna(self.A.columnes,self.B)
        return matriu_latex(c.matriu,ampliada=True)
    #
    #
    #
    def resol(self,unknowns=None):
        &#34;&#34;&#34;
        Resol el sistema d&#39;equacions utilitzant la funció linsolve del sympy.
        El resultat és una llista d&#39;expressions on hi poden aparèixer les
        incògnites del sistema com a paràmetres
        &#34;&#34;&#34;
        t1, t2, t3, t4, t5, t6, t7, t8 = symbols(&#39;t1 t2 t3 t4 t5 t6 t7 t8&#39;)
        params = [t1,t2,t3,t4,t5,t6,t7,t8]
        count = 0
        subs = {}
        system = (self.A.matriu,Matrix(self.B.dimensio,1,self.B.components))
        X = Vector(self.unknowns)
        system = self.A * X - self.B
        if unknowns is not None:
            s = solve(system.components,*unknowns)
        else:
            s = solve(system.components,*self.unknowns)
        self.solucio = []
        self.parametres = []
        self.secundaries = []
        for k in self.unknowns:
            try:
                self.solucio.append(s[k])
            except:
                self.solucio.append(k)
                subs[k] = params[count]
                self.parametres.append(subs[k])
                self.secundaries.append(k)
                count += 1
        self.parametrica = []
        for k in self.solucio:
            for u, v in subs.items():
                k = k.subs(u,v)
            self.parametrica.append(k)
        return self.solucio
    #
    #
    #
    def solucio_latex(self,linia=False,unknowns=None):
        &#34;&#34;&#34;
        Retorna l&#39;expressió en LaTex de la solució del sistema d&#39;equacions
        Paràmetres:
            linia: si és True escriu la solució en una línia, en cas contrari
                   ho fa com un sistema d&#39;equacions
        &#34;&#34;&#34;
        if self.solucio is None:
            self.resol(unknowns)
        if len(self.solucio) == 0:
            return &#34;&#34;
        eqs = []
        for i in range(self.A.columnes):
            if self.solucio[i] == self.unknowns[i]:
                continue
            d = self.solucio[i].as_coefficients_dict()
            l = list(d.values())
            m = []
            for k in range(len(l)):
                if isinstance(l[k],Rational):
                    m.append(l[k].q)
                elif isinstance(l[k],int):
                    pass
                else:
                    return &#34;&#34;
            if len(m) == 0:
                factor = 1
            else:
                factor = mcm_llista(m)
            eq = 0
            for k in d.keys():
                d[k] = factor * d[k]
                eq += d[k] * k
            if factor == 1:
                eqs.append(f&#34;{self.unknowns[i]} &amp;= {mylatex(eq)}&#34;)
            else:
                eqs.append(f&#34;{self.unknowns[i]} &amp;= \\frac{{{mylatex(eq)}}}{{{factor}}}&#34;)
        if len(eqs) == 1:
            return eqs[0].replace(&#39;&#39;,&#39;&#39;)
        if not linia:
            eqs = &#34; \\\\ &#34;.join(eqs)
            return f&#34;\\left.\\aligned {eqs} \\endaligned\\;\\right\\}}&#34;
        eqs = &#34; $, $&#34;.join(eqs)
        eqs = eqs.replace(&#39;&amp;&#39;,&#39;&#39;)
        return f&#34;$ {eqs} $&#34;


class EquacioParametrica:
    &#34;&#34;&#34;
    Classe per treballar amb equacions paramètriques
    Atributs:
        equacio: l&#39;equació paramètrica
        b: terme independent de l&#39;equaqció
        coefs: coeficients dels paràmetres
        unknown: incògina de l&#39;equació paramètrica
    &#34;&#34;&#34;
    #
    #
    #
    def __init__(self,eq,amp=True):
        &#34;&#34;&#34;
        Contructor.
        Paràmetres:
          eq: equació paramètrica. Ha de ser del tipus
              -x + 2*t1 - 3*t2 + t3 - 4
             amb el signe menys a la incògnita
          amp: True o False en funció si hem d&#39;escriure &amp;= o només = en la representació
               en LaTeX de l&#39;equació
        &#34;&#34;&#34;
        x, y, z, t = symbols(&#39;x y z t&#39;)
        x1, x2, x3, x4, x5, x6, x7, x8 = symbols(&#39;x1 x2 x3 x4 x5 x6 x7 x8&#39;)
        unknowns = [x1,x2,x3,x4,x5,x6,x7,x8] + [x,y,z,t]
        self.equacio = eq
        self.amp = amp
        d = eq.as_coefficients_dict()
        self.b = 0
        self.coefs = {}
        self.params = []
        for k in d.keys():
            if k == 1:
                self.b = d[k]
            elif k in unknowns:
                self.unknown = k
            else:
                if k not in self.params:
                    self.params.append(k)
                self.coefs[k] = d[k]
        self.params.sort(key=latex)
    #
    #
    #
    @classmethod
    def coeficients(cls,a,b,p=0,total=1,amp=True):
        &#34;&#34;&#34;
        Genera una equació amb coeficients dels paràmtres el vector &#34;a&#34;, terme
        independent b i incògnita número p d&#39;un total de &#34;total&#34;.
        Paràmetres:
            a: vector amb els coeficients dels paràmetres
            b: terme independent
            p: índex que representa la incògnita
            total: nombre total d&#39;incònites
        Exemple:
           e = EquacioParametrica(Vector(3,-2,1),5,1,4) genera l&#39;equació
                        - y + 3*t1 - 2*t2 + t3 + 5
           e = EquacioParametrica(Vector(3,-2,1,3],-5,3,7) genera l&#39;equació
               - x3 + 3*t1 - 2*t2 + t3 + 3*t4 + 7*t5 - 5
        Observació:
            si hi ha un màxim de quatre incògnites, son (x,y,z,t)
            si n&#39;hi ha més, són (x1,x2,x3,x4,...)
        &#34;&#34;&#34;
        if not isinstance(a,Vector):
            return None
        if p &gt;= total:
            return None
        if total &lt;= 4:
            x, y, z, t = symbols(&#39;x y z t&#39;)
            unknowns = [x,y,z,t]
        else:
            x1, x2, x3, x4, x5, x6, x7, x8 = symbols(&#39;x1 x2 x3 x4 x5 x6 x7 x8&#39;)
            unknowns = [x1,x2,x3,x4,x5,x6,x7,x8]
        t1, t2, t3, t4, t5, t6, t7, t8 = symbols(&#39;t1 t2 t3 t4 t5 t6 t7 t8&#39;)
        parameters = [t1,t2,t3,t4,t5,t6,t7,t8]
        eq = - unknowns[p]
        cls.unknown = unknowns[p]
        for k in range(a.dimensio):
            eq += a[k] * parameters[k]
        eq += b
        return cls(eq,amp)
    #
    #
    #
    def __repr__(self):
        &#34;&#34;&#34;
        Retorna l&#39;expessió en LaTeX de l&#39;equació paramètrica
        &#34;&#34;&#34;
        t1, t2, t3, t4, t5, t6, t7, t8 = symbols(&#39;t1 t2 t3 t4 t5 t6 t7 t8&#39;)
        x1, x2, x3, x4, x5, x6, x7, x8 = symbols(&#39;x1 x2 x3 x4 x5 x6 x7 x8&#39;)
        x, y, z, t = symbols(&#39;x y z t&#39;)
        if self.amp:
            s = f&#34;{latex(self.unknown)} &amp;= &#34;
        else:
            s = f&#34;{latex(self.unknown)} = &#34;
        d = []
        if isinstance(self.b,Rational):
            d.append(self.b.q)
        for k,v in self.coefs.items():
            if isinstance(v,Rational):
                d.append(v.q)
        if len(d) == 0:
            factor = 1
        else:
            factor = mcm_llista(d)
        if factor != 1:
            s += f&#34;\\frac{{NUMERADOR}}{{{factor}}}&#34;
        else:
            s += &#34;NUMERADOR&#34;
        e = 0
        first = None
        for k in self.params:
            try:
                self.coefs[k]
            except:
                continue
            if first is None and self.coefs[k] != 0:
                first = k
            e += factor * self.coefs[k] * k
        f = &#34;&#34;
        if first is not None and self.b != 0:
            if self.coefs[first] &gt; 0:
                f = f&#34;{factor*self.b} + &#34;
            else:
                f = f&#34;{factor*self.b} &#34;
        s = s.replace(&#39;NUMERADOR&#39;,f + latex(e))
        return s


class EquacionsParametriques(object):
    &#34;&#34;&#34;
    Classe per treballar amb sistemes d&#39;equacions paramètriques
    Atributs:
        A: matriu dels coeficients dels paràmetres
        B: vector dels termes independents
        equacions: llista de EquacioParametrica
        nombre: nombre d&#39;equacions
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,a,b,amp=True):
        &#34;&#34;&#34;
        Contructor.
        Genera les equacions X = b + a.T on X són les incògnites i T els paràmetres

        Paràmetres:
          a: matriu dels coeficients dels paràmetres
          b: vector de termes independents
          amp: True o False en funció si s&#39;ha d&#39;escriure &amp;= o només = en la representació
               en LaTeX del sistema
        &#34;&#34;&#34;
        if not isinstance(a,Matriu):
            return None
        if not isinstance(b,Vector):
            return None
        if a.files != b.dimensio:
            return None
        return super(EquacionsParametriques,cls).__new__(cls)
    #
    #
    #
    def __init__(self,a,b,amp=True):
        self.A = a
        self.B = b
        eq = []
        files = a.vectors_fila()
        for k in range(self.A.files):
            eq.append(EquacioParametrica.coeficients(files[k],b[k],k,self.A.files,amp))
        self.equacions = eq
        self.nombre = len(eq)
    #
    #
    #
    def __repr__(self):
        &#34;&#34;&#34;
        Retorna la representació en LaTeX del sistema d&#39;equacions paramètriques
        &#34;&#34;&#34;
        l = list(map(str,self.equacions))
        eqs = &#34; \\\\ &#34;.join(l)
        return f&#34;\\left.\\aligned {eqs} \\endaligned\\;\\right\\}}&#34;
    #
    #
    #
    def eliminar_parametres(self,prime=0):
        &#34;&#34;&#34;
        Retorna el SistemaEquacions que s&#39;obté en eliminar els paràmetres dels
        sistema
        &#34;&#34;&#34;
        L, U, _ = self.A.matriu.LUdecomposition()
        r = U.rank()
        v = Vector([e.unknown for e in self.equacions])
        t = Matrix(self.nombre,1,(v - self.B).components)
        t = (L**(-1) * t)[r:]
        return SistemaEquacions.from_equacions(t,self.A.files,prime)


class PlaVectorial(object):
    &#34;&#34;&#34;
    Classe per treballar amb plans vectorials
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,u1,u2):
        &#34;&#34;&#34;
        Constructor.
        Paràmetres:
            u1, u2: generadors del pla
        &#34;&#34;&#34;
        if not isinstance(u1,Vector):
            return None
        if not isinstance(u2,Vector):
            return None
        if u1.dimensio != 3 or u2.dimensio != 3:
            return None
        m = Matriu.from_vectors_columna([u1,u2])
        if m.rank() != 2:
            return None
        return super(PlaVectorial,cls).__new__(cls)
    #
    #
    #
    def __init__(self,u1,u2):
        self.u1 = u1
        self.u2 = u2
    #
    #
    #
    def __repr__(self):
        &#34;&#34;&#34;
        Retorna l&#39;expressió en LaTeX dels dos vectors generadors
        &#34;&#34;&#34;
        return f&#34;{self.u1}, {self.u2}&#34;
    #
    #
    #
    def equacio_implicita(self,base=None,prime=0):
        &#34;&#34;&#34;
        Retorna l&#39;equació implícita del pla en la base &#34;base&#34; en format LaTeX.
        Normalment, si la base no és la canònica es posa prime &gt; 0 perquè el resultat
        sigui de l&#39;estil 2x&#39;-3y&#39;+4z&#39;= 0
        Paràmetres:
            base: una base (classe Base). Si és None, serà la canònica
            prime: nombre de primes que s&#39;escriuran a les incògnites
        &#34;&#34;&#34;
        if base is None:
            w = self.u1.cross(self.u2)
            return EquacioLineal.coeficients(w,0,False)
        if not isinstance(base,Base):
            return None
        v1 = self.u1.components_en_base(base)
        v2 = self.u2.components_en_base(base)
        w = v1.cross(v2)
        return EquacioLineal.coeficients(w,0,False,prime)
    #
    #
    #
    @classmethod
    def from_matriu(cls,m):
        &#34;&#34;&#34;
        Crea el pla vectorial generat per les columnes de la matriu &#34;m&#34;
        Paràmetres:
            m: matriu. Ha de tenir 3 files, dues columnes i rang 2
        &#34;&#34;&#34;
        if not isinstance(m,Matriu):
            return None
        if m.files != 3 or m.columnes != 2 or m.rank() != 2:
            return None
        v = m.vectors_columna()
        return cls(v[0],v[1])
    #
    #
    #
    @classmethod
    def amb_associat(cls,w):
        &#34;&#34;&#34;
        Genera el pla vectorial que té vector perpendicular &#34;w&#34;
        Paràmetres:
            v: vector no nul de dimensió 3
        &#34;&#34;&#34;
        if not isinstance(w,Vector):
            return None
        if w.dimensio != 3:
            return None
        if w.length() == 0:
            return None
        a = Matriu.from_vectors_fila([w])
        l = a.nucli()
        return cls(l[0],l[1])
    #
    #
    #
    def base_ortogonal(self):
        &#34;&#34;&#34;
        Retorna una base ortogonal del pla vectorial
        &#34;&#34;&#34;
        v1 = self.u1
        u2 = self.u2
        v2 = v1.dot(v1) * u2 - v1.dot(u2) * v1
        v2.simplificar()
        return Base([v1,v2])
    #
    #
    #
    def projeccio_ortogonal(self,u):
        &#34;&#34;&#34;
        Retorna la projecció ortogonal del vector u sobre el pla.
        Paràmetres:
          u: Vector
        &#34;&#34;&#34;
        if not isinstance(u,Vector):
            return None
        if u.dimensio != 3:
            return None
        b = self.base_ortogonal()
        v1, v2 = b.vecs
        t1 = Rational(u.dot(v1),v1.dot(v1))
        t2 = Rational(u.dot(v2),v2.dot(v2))
        return t1 * v1 + t2 * v2
    #
    #
    #
    def simetric(self,u):
        &#34;&#34;&#34;
        Retorna el simètric del vector u respecte al pla.
        Paràmetres:
          u: Vector
        &#34;&#34;&#34;
        if not isinstance(u,Vector):
            return None
        if u.dimensio != 3:
            return None
        return 2*self.projeccio_ortogonal(u) - u
    #
    #
    #
    def conte(self,u):
        &#34;&#34;&#34;
        Retorna si el vector u pertany al pla.
        Paràmetres:
          u: Vector
        &#34;&#34;&#34;
        if not isinstance(u,Vector):
            return None
        if u.dimensio != 3:
            return None
        m = Matriu.from_vectors_columna([self.u1,self.u2,u])
        return m.det() == 0
    #
    #
    #
    def es_associat(self,u):
        &#34;&#34;&#34;
        Retorna si el vector és perpendicular al pla.
        Paràmetres:
          u: Vector
        &#34;&#34;&#34;
        if not isinstance(u,Vector):
            return None
        if u.dimensio != 3:
            return None
        if u.length() == 0:
            return False
        w = self.u1.cross(self.u2)
        m = Matriu.from_vectors_columna([w,u])
        return m.rang() == 1
    #
    #
    #
    def ortogonal(self):
        &#34;&#34;&#34;
        Retorna el suplementari ortogonal
        &#34;&#34;&#34;
        a = Matriu.from_vectors_fila([self.u1,self.u2])
        return RectaVectorial(a.nucli()[0])
    #
    #
    #
    def associat(self,base=None):
        &#34;&#34;&#34;
        Retorna les components del vector associat en la base &#34;base&#34;
        Paràmetres:
            base: element de la clase Base
        &#34;&#34;&#34;
        w = self.u1.cross(self.u2)
        w.simplificar()
        if base is None:
            return w
        if not isinstance(base,Base):
            return None
        w = base.components_del_vector(w)
        w.simplificar()
        return w


class RectaVectorial(object):
    &#34;&#34;&#34;
    Classe per treballar amb rectes vectorials, dimensió 2 o 3
    Atributs:
        u: generador de la recta vectorial
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,u):
        &#34;&#34;&#34;
        Constructor.
        Paràmetres:
            u: vector amb dimensió 2 o 3
        &#34;&#34;&#34;
        if not isinstance(u,Vector):
            return None
        if u.dimensio not in [2,3]:
            return None
        return super(RectaVectorial,cls).__new__(cls)
    #
    #
    #
    def __init__(self,u):
        self.u = u
    #
    #
    #
    def equacions_implicites(self,base=None,prime=0,aleatori=True):
        &#34;&#34;&#34;
        Retorna l&#39;equació implícita (dimensió 2) o el sistema d&#39;equacions implícites
        (dimensió 3) en la base &#34;base&#34;.
        Paràmetres:
            base: Base en la que calculem les equacions implícites
            prime: Quantes primes volem posar a les equacions
            aleatori: només s&#39;aplica a dimensió 3 i genera unes equacions implícites no trivials
        &#34;&#34;&#34;
        if base is None:
            a = Matriu.matriu_fila(self.u)
        else:
            a = Matriu.matriu_fila(self.u.components_en_base(base))
        l = a.nucli()
        if len(l) == 1:
            return EquacioLineal.coeficients(l[0],0,False,prime)
        a = Matriu.from_vectors_fila(l)
        b = Vector.nul(len(l))
        if aleatori:
            m = Matriu.amb_rang(f=2,c=2,r=2,maxim=3,mzeros=0)
            a = m * a
        return SistemaEquacions(a,b,prime=prime)
    #
    #
    #
    def equacio_continua(self,base=None,prime=0):
        &#34;&#34;&#34;
        Retorna l&#39;expressió en LaTeX de l&#39;equació contínua de la recta vectorial
        en la base &#34;base&#34;.
        Paràmetres:
            base: base del pla o de l&#39;espai vectorial (classe Base)
            prime: nombre de primes amb el que s&#39;escriuran les incògnites
        &#34;&#34;&#34;
        if base is None:
            v = Vector(self.u.components)
        else:
            v = self.u.components_en_base(base)
        v.simplificar()
        x, y, z = symbols(&#39;x y z&#39;)
        incg = [x,y,z]
        eq = []
        p = &#34;&#34;
        if prime &gt; 0:
            p = prime * &#34;&#39;&#34;
        for i in range(v.dimensio):
            if v[i] == 1:
                eq.append(latex(incg[i]) + p)
            else:
                eq.append(f&#34;\\frac{{{latex(incg[i]) + p}}}{{{v[i]}}}&#34;)
        return &#34; = &#34;.join(eq)
    #
    #
    #
    def projeccio_ortogonal(self,u):
        &#34;&#34;&#34;
        Retorna la projecció ortogonal del vector u sobre la recta.
        Paràmetres:
          u: Vector
        &#34;&#34;&#34;
        if not isinstance(u,Vector):
            return None
        if u.dimensio != self.u.dimensio:
            return None
        v = self.u
        t = u.dot(v)/v.dot(v)
        return t * v
    #
    #
    #
    def simetric(self,u):
        &#34;&#34;&#34;
        Retorna el simètric del vector u respecte a la recta.
        Paràmetres:
          u: Vector
        &#34;&#34;&#34;
        if not isinstance(u,Vector):
            return None
        if u.dimensio != self.u.dimensio:
            return None
        return 2*self.projeccio_ortogonal(u) - u
    #
    #
    #
    def ortogonal(self):
        &#34;&#34;&#34;
        Retorna el suplementari ortogonal
        &#34;&#34;&#34;
        a = Matriu.from_vectors_fila([self.u])
        n = a.nucli()
        if len(n) == 1:
            return RectaVectorial(n[0])
        return PlaVectorial(n)


class ReferenciaAfi(object):
    &#34;&#34;&#34;
    Classe per treballar amb referències afins de P^n
    Atributs:
        origen: origen de la referència (classe Punt)
        base: base de la referència (classe Base)
        dimensio: dimensió de l&#39;espai corresponent
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,origen,base):
        &#34;&#34;&#34;
        Constructor.
        Paràmetres:
            origen: origen de la referència
            base: base de la referència
        &#34;&#34;&#34;
        if not isinstance(origen,Punt):
            return None
        if not isinstance(base,Base):
            return None
        if origen.dimensio != base.dimensio:
            return None
        return super(ReferenciaAfi,cls).__new__(cls)
    #
    #
    #
    def __init__ (self,origen,base):
        self.origen = origen
        self.base = base
        self.dimensio = origen.dimensio
    #
    #
    #
    def __repr__(self):
        &#34;&#34;&#34;
        Retorna l&#39;expressió en LaTeX de la referència
        &#34;&#34;&#34;
        return f&#34;\\left\\{{{self.origen};{self.base.vectors_latex()}\\right\\}}&#34;
    #
    #
    #
    @classmethod
    def aleatoria(cls,dimensio=3,maxim=3,mzeros=0,unitaria=False):
        &#34;&#34;&#34;
        Retorna una referència aleatòria
        Paràmetres:
            dimensio: dimensió de l&#39;espai corresponent
            maxim: Màxim nombre que hi apareix
            mzeros: Màxim nombre de zeros que apareixen a la base
            unitaria: si és True la matriu del canvi de base tindrà determinant 1 o -1
        &#34;&#34;&#34;
        origen = Punt.aleatori(l=dimensio,maxim=maxim,nuls=False)
        m = Matriu.invertible(ordre=dimensio,maxim=maxim,mzeros=mzeros,unitaria=unitaria)
        base = Base.from_matriu(m)
        return cls(origen,base)
    #
    #
    #
    @classmethod
    def canonica(cls,dimensio=3):
        &#34;&#34;&#34;
        Retorna la referència canònica
        Paràmetres:
            dimensio: dimensió de l&#39;espai corresponent
        &#34;&#34;&#34;
        origen = Punt.nul(dimensio)
        base = Base.canonica(dimensio)
        return cls(origen,base)
    #
    #
    #
    def punt_de_coordenades(self,punt):
        &#34;&#34;&#34;
        Retorna un nou punt expressat en la referència canònica del
        punt que en aquesta referencia té coordenades &#34;punt&#34;
        Paràmetres:
            punt: coordenades d&#39;un punt en la referència actual
        &#34;&#34;&#34;
        if not isinstance(punt,Punt):
            return None
        if punt.dimensio != self.dimensio:
            return None
        if not self.base.unitaria:
            c = self.base.matriu()
        else:
            unitaris = [(1 / v.length()) * v for v in self.base.vecs]
            c = Matriu.from_vectors_columna(unitaris)
        p = self.origen + c * punt
        return Punt(p.components)
    #
    #
    #
    def coordenades_del_punt(self,punt,ref=None):
        &#34;&#34;&#34;
        Retorna un nou punt expressat en aquesta referència del punt
        que en la referència &#34;ref&#34; té coordenades &#34;punt&#34;.
        Si ref és None, serà la referència canònica
        Paràmetres:
            punt: coordenades en la referència &#34;ref&#34;
            ref: ReferenciaAfi
        &#34;&#34;&#34;
        if not isinstance(punt,Punt):
            return None
        if ref is not None:
            if not isinstance(ref,ReferenciaAfi):
                return None
            if ref.dimensio != punt.dimensio:
                return None
            pc = ref.punt_de_coordenades(punt)
        else:
            pc = punt
        p = self.base.components_del_vector(pc - self.origen)
        return Punt(self.base.components_del_vector(pc - self.origen).components)
    #
    #
    #
    def canvi_coordenades(self,prime1=0,prime2=1):
        &#34;&#34;&#34;
        Restorna en format latex l&#39;expressió del canvi de coordenades de la referència
        actual a la referència canònica
        Paràmetres:
            prime1: primes que s&#39;escriuran a les coordenades en la referència canònica
            prime2: primes que s&#39;escriuran a les coordenades en la referència actual
        &#34;&#34;&#34;
        if self.dimensio &lt;= 3:
            x, y, z = symbols(&#39;x y z&#39;)
            coords = [x,y,z]
        else:
            x1, x2, x3, x4, x5, x6, x7, x8 = symbols(&#39;x1 x2 x3 x4 x5 x6 x7 x8&#39;)
            coords = [x1, x2, x3, x4, x5, x6, x7, x8]
        coords = coords[0:self.dimensio]
        p1 = &#34;&#34;
        p2 = &#34;&#34;
        if prime1 &gt; 0:
            p1 = prime1 * &#34;&#39;&#34;
        if prime2 &gt; 0:
            p2 = prime2 * &#34;&#39;&#34;
        o = &#34; \\\\ &#34;.join([latex(k) + p1 for k in coords])
        d = &#34; \\\\ &#34;.join([latex(k) + p2 for k in coords])
        m = Matriu.matriu_columna(self.origen)
        s = &#34;\\begin{pmatrix}{c} &#34; + o + &#34;\\end{pmatrix} = \n&#34;
        s += f&#34;{m} + \n&#34;
        s += f&#34;{self.base.matriu()}\n&#34;
        s += &#34;\\begin{pmatrix}{c} &#34; + d + &#34;\\end{pmatrix}&#34;
        return s
    #
    #
    #
    def canvi_de_referencia_a_la_referencia(self,R,p1,p2):
        &#34;&#34;&#34;
        Retorna en format latex l&#39;expressió del canvi de coordenades de la referència
        actual a la referència R
        Paràmetres:
            p1: primes que s&#39;escriuran a les coordenades en la referència actual
            p2: primes que s&#39;escriuran a les coordenades en la referència R
        &#34;&#34;&#34;
        if not isinstance(R,ReferenciaAfi):
            return None
        if self.dimensio != R.dimensio:
            return None
        if self.dimensio &lt;= 3:
            x, y, z = symbols(&#39;x y z&#39;)
            coords = [x,y,z]
        else:
            x1, x2, x3, x4, x5, x6, x7, x8 = symbols(&#39;x1 x2 x3 x4 x5 x6 x7 x8&#39;)
            coords = [x1, x2, x3, x4, x5, x6, x7, x8]
        coords = coords[0:self.dimensio]
        o = R.coordenades_del_punt(Punt(0,0),self)
        c = R.base.matriu()
        d = self.base.matriu()
        A = c.inversa() * d
        ps1 = &#34;&#34;
        ps2 = &#34;&#34;
        if p1 &gt; 0:
            ps1 = p1 * &#34;&#39;&#34;
        if p2 &gt; 0:
            ps2 = p2 * &#34;&#39;&#34;
        cs = &#34; \\\\ &#34;.join([latex(k) + ps1 for k in coords])
        cr = &#34; \\\\ &#34;.join([latex(k) + ps2 for k in coords])
        m = Matriu.matriu_columna(o)
        s = &#34;\\begin{pmatrix}{c} &#34; + cr + &#34;\\end{pmatrix} = \n&#34;
        s += f&#34;{m} + \n&#34;
        s += f&#34;{A}\n&#34;
        s += &#34;\\begin{pmatrix}{c} &#34; + cs + &#34;\\end{pmatrix}&#34;
        return s
    #
    #
    #
    def referencia_inversa(self):
        &#34;&#34;&#34;
        Retorna una referència que es correspon amb el canvi de coordenades de
        de la referència canònica a l&#39;actual
        &#34;&#34;&#34;
        p = Punt.nul(self.dimensio)
        q = p.coordenades_en_referencia(self)
        m = self.base.matriu().inversa()
        b = Base.from_matriu(m)
        return ReferenciaAfi(q,b)
    #
    #
    #
    def vectors(self,unitaris=False):
        &#34;&#34;&#34;
        Retorna els vectors de la base de la referència
        Paràmetres:
            unitaris: si és True els retorna dividits per la seva longitud
        &#34;&#34;&#34;
        return self.base.vectors(unitaris)


class PlaAfi(object):
    &#34;&#34;&#34;
    Classe per treballar amb plans afins.
    Atributs:
        u1, u2: vectors directors del pla
        p: punt de pas
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,p,u1,u2,ref=None):
        &#34;&#34;&#34;
        Constructor.
        Paràmetres:
            p: punt de pas
            u1, u2: generadors del pla
            ref: referència en que estan expressats u1, u2 i p
        &#34;&#34;&#34;
        if not isinstance(u1,Vector):
            return None
        if not isinstance(u2,Vector):
            return None
        if not isinstance(p,Punt):
            return None
        if u1.dimensio != 3 or u2.dimensio != 3:
            return None
        if p.dimensio != 3:
            return None
        if ref is not None:
            if not isinstance(ref,ReferenciaAfi):
                return None
            if ref.dimensio != 3:
                return None
        m = Matriu.from_vectors_columna([u1,u2])
        if m.rank() != 2:
            return None
        return super(PlaAfi,cls).__new__(cls)
    #
    #
    #
    def __init__(self,p,u1,u2,ref=None):
        if ref is None:
            self.u1 = u1
            self.u2 = u2
            self.p = p
        else:
            self.u1 = ref.base.vector_de_components(u1)
            self.u2 = ref.base.vector_de_components(u2)
            self.p = ref.punt_de_coordenades(p)
    #
    #
    #
    @classmethod
    def aleatori(cls):
        m = Matriu.amb_rang(f=2,c=3,r=2,maxim=4,mzeros=0)
        v = m.vectors_fila()
        p = Punt.aleatori(l=3,maxim=3,nuls=False)
        return cls(p,v[0],v[1])
    #
    #
    #
    @classmethod
    def amb_associat(cls,w,p):
        &#34;&#34;&#34;
        Genera el pla afí que té vector perpendicular &#34;w&#34; i passa pel punt p
        Paràmetres:
            w: vector associat
            p: punt de pas
        &#34;&#34;&#34;
        if not isinstance(w,Vector):
            return None
        if not isinstance(p,Punt):
            return None
        a = Matriu.from_vectors_fila([w])
        l = a.nucli()
        return cls(p,l[0],l[1])
    #
    #
    #
    def punt_de_coordenades_enteres(self,p=None,u=None,v=None):
        &#34;&#34;&#34;
        Retorna, si és possible, un punt de coordenades enteres del pla afí
        que passa pel punt p i té vectors directors u i v
        &#34;&#34;&#34;
        if p is None:
            p = self.p
        if u is None:
            u = self.u1
        if v is None:
            v = self.u2
        if p.tots_enters():
            return p
        t, _ = p.factor_comu()
        if isinstance(t,int) or isinstance(t,Integer):
            return p
        for i in range(1,t.q):
            for j in range(1,t.q):
                r = (p + Rational(i,t.q) * u + Rational(j,t.q) * v).punt()
                if r.tots_enters():
                    return r
                r = (p + Rational(i,t.q) * u - Rational(j,t.q) * v).punt()
                if r.tots_enters():
                    return r
                r = (p - Rational(i,t.q) * u + Rational(j,t.q) * v).punt()
                if r.tots_enters():
                    return r
                r = (p - Rational(i,t.q) * u - Rational(j,t.q) * v).punt()
                if r.tots_enters():
                    return r
        return p
    #
    #
    #
    @classmethod
    def from_equacio_implicita(cls,eq):
        &#34;&#34;&#34;
        Retorna el pla afí que té equació implícita eq
        Paràmetres:
            eq: EquacioLineal
        &#34;&#34;&#34;
        if not isinstance(eq,EquacioLineal):
            return None
        s = eq.to_sistema_equacions()
        s.resol()
        t1, t2 = symbols(&#39;t1 t2&#39;)
        p1 = Punt([v.subs(t1,1).subs(t2,1) for v in s.parametrica])
        p2 = Punt([v.subs(t1,1).subs(t2,0) for v in s.parametrica])
        p3 = Punt([v.subs(t1,0).subs(t2,1) for v in s.parametrica])
        u = p2-p1
        v = p3-p1
        u.simplificar()
        v.simplificar()
        return cls(p1,u,v)
    #
    #
    #
    def __repr__(self):
        &#34;&#34;&#34;
        Retorna l&#39;equació vectorial del pla en LaTeX
        &#34;&#34;&#34;
        q = self.punt_de_coordenades_enteres()
        return f&#34;(x,y,z)={q}+t_1{self.u1}+t_2{self.u2}&#34;
    #
    #
    #
    def equacio_implicita(self,ref=None,prime=0):
        &#34;&#34;&#34;
        Retorna l&#39;expressió de l&#39;equació implícita del pla en la referència &#34;ref&#34;
        Paràmetres:
            ref: referència afí
            prime: nombre de primes que s&#39;escriuran a les incògnites
        &#34;&#34;&#34;
        if ref is None:
            w = self.u1.cross(self.u2)
            return EquacioLineal.coeficients(w,w.dot(self.p),False)
        if not isinstance(ref,ReferenciaAfi):
            return None
        c = self.p.coordenades_en_referencia(ref)
        v1 = self.u1.components_en_base(ref.base)
        v2 = self.u2.components_en_base(ref.base)
        w = v1.cross(v2)
        w.simplificar()
        return EquacioLineal.coeficients(w,w.dot(c),False,prime)
    #
    #
    #
    def base_ortogonal(self):
        &#34;&#34;&#34;
        Retorna una base orogonal (vectors directors perpendiculars) del pla
        &#34;&#34;&#34;
        v1 = self.u1
        u2 = self.u2
        v2 = v1.dot(v1) * u2 - v1.dot(u2) * v1
        v2.simplificar()
        return [v1,v2]
    #
    #
    #
    def associat(self,base=None):
        &#34;&#34;&#34;
        Retorna un vector perpendicular al pla expressat en la base &#34;base&#34;
        Paràmetres:
            base: base de l&#39;espai vectorial. Si és None, serà la canònica
        &#34;&#34;&#34;
        w = self.u1.cross(self.u2,simplificar=True)
        if base is None:
            return w
        return w.components_en_base(base)
    #
    #
    #
    def interseccio(self,other):
        &#34;&#34;&#34;
        Retorna la intersecció del pla amb una altre pla o una recta.
        El resultat pot ser None, una recta o un pla.
        Paràmetes:
          other. PlaAfi o RectaAfi
        &#34;&#34;&#34;
        if isinstance(other,PlaAfi):
            m = Matriu.from_vectors_columna([self.associat(),other.associat()])
            if m.rang() == 1:
                if other.conte(self.p):
                    return self
                return None
            e1 = self.equacio_implicita()
            e2 = other.equacio_implicita()
            s = SistemaEquacions.from_equacions([e1,e2],3)
            return RectaAfi.from_equacions_implicites(s)
        if isinstance(other,RectaAfi):
            return other.interseccio(self)
        return None
    #
    #
    #
    def distancia(self,other):
        &#34;&#34;&#34;
        Retorna la distància entre el pla actual i un punt, una recta o un altre pla
        Paràmetres:
            other: un punt (classe Punt), una recta (classe RectaAfi) o
            un pla (class PlaAfi)
        &#34;&#34;&#34;
        if isinstance(other,Punt):
            v = self.p - other
            w = self.u1.cross(self.u2,simplificar=True)
            return abs(v.dot(w))/w.length()
        if isinstance(other,PlaAfi):
            w1 = self.associat()
            w2 = other.associat()
            w = w1.cross(w2)
            if w.length() == 0:
                return self.distancia(other.p)
            return 0
        if isinstance(other,RectaAfi):
            return other.distancia(self)
        return None
    #
    #
    #
    def projeccio_ortogonal(self,punt):
        &#34;&#34;&#34;
        Retorna la projecció ortogonal del punt &#34;punt&#34; sobre el pla
        Paràmetres:
          punt: Punt
        &#34;&#34;&#34;
        P = PlaVectorial(self.u1,self.u2)
        if not isinstance(punt,Punt):
            return None
        if punt.dimensio != 3:
            return None
        return (self.p + P.projeccio_ortogonal(punt - self.p)).punt()
    #
    #
    #
    def simetric(self,punt):
        &#34;&#34;&#34;
        Retorna el simètric del punt &#34;punt&#34; respecte al pla
        Paràmetres:
          punt: Punt
        &#34;&#34;&#34;
        return 2*self.projeccio_ortogonal(punt) - punt
    #
    #
    #
    def conte(self,punt):
        &#34;&#34;&#34;
        Retorna si el punt &#34;punt&#34; pertany al pla
        Paràmetres:
          punt: Punt
        &#34;&#34;&#34;
        if not isinstance(punt,Punt):
            return None
        if punt.dimensio != self.p.dimensio:
            return None
        m = Matriu.from_vectors_columna([self.u1,self.u2,self.p - punt])
        return m.rang() == 2


class RectaAfi(object):
    &#34;&#34;&#34;
    Classe per treballar amb rectes afins, dimensió 2 o 3
    Atributs:
        u: generador de la recta vectorial
        p: punt de pas
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,p,u,ref=None):
        &#34;&#34;&#34;
        Constructor.
        Paràmetres:
            p: punt de pas
            u: vector director de la recta
            ref: referència en que estan expressats u i p
        &#34;&#34;&#34;
        if not isinstance(u,Vector):
            return None
        if not isinstance(p,Punt):
            return None
        if p.dimensio != u.dimensio:
            return None
        if p.dimensio not in [2,3]:
            return None
        if ref is not None:
            if not isinstance(ref,ReferenciaAfi):
                return None
            if ref.dimensio != p.dimensio:
                return None
        return super(RectaAfi,cls).__new__(cls)
    #
    #
    #
    def __init__(self,p,u,ref=None):
        if ref is None:
            self.u = u
            self.p = p
        else:
            self.u = ref.base.vector_de_components(u)
            self.p = ref.punt_de_coordenades(p)
    #
    #
    #
    def __repr__(self):
        &#34;&#34;&#34;
        Retorna l&#39;equació vectorial de la recta en LaTeX
        &#34;&#34;&#34;
        q = self.punt_de_coordenades_enteres()
        if self.u.dimensio == 2:
            return f&#34;(x,y)={q}+t{self.u}&#34;
        else:
            return f&#34;(x,y,z)={q}+t{self.u}&#34;
    #
    #
    #
    @classmethod
    def aleatoria(cls,dim=3,maxim=None):
        &#34;&#34;&#34;
        Retorna una recta afí aleatòria
        Paràmetres:
             dim: dimensió
             maxim: màxim de les coordenades del punt i les components dels
                    vector director

        &#34;&#34;&#34;
        if maxim is None:
            v = Vector.aleatori(l=dim,maxim=3,nuls=False)
            p = Punt.aleatori(l=dim,maxim=4,nuls=False)
        else:
            v = Vector.aleatori(l=dim,maxim=maxim,nuls=False)
            p = Punt.aleatori(l=dim,maxim=maxim,nuls=False)
        return cls(p,v)
    #
    #
    #
    @classmethod
    def from_equacions_implicites(cls,s):
        &#34;&#34;&#34;
        Retorna la recta afí que té equacions implícites s
        Paràmetres:
            s: SistemaEquacions
        &#34;&#34;&#34;
        if not isinstance(s,SistemaEquacions):
            return None
        if s.A.files != 2 or s.A.columnes != 3 or s.A.rang() != 2:
            return None
        s.resol()
        t1 = symbols(&#39;t1&#39;)
        p1 = Punt([v.subs(t1,0) for v in s.parametrica])
        p2 = Punt([v.subs(t1,1) for v in s.parametrica])
        u = p2-p1
        u.simplificar()
        return cls(p1,u)
    #
    #
    #
    def punt_de_coordenades_enteres(self,p=None,u=None):
        &#34;&#34;&#34;
        Retorna, si és possible, un punt de coordenades enteres de la recta
        que passa pel punt p i té vector director u
        &#34;&#34;&#34;
        if p is None:
            p = self.p
        if u is None:
            u = self.u
        if p.tots_enters():
            return p
        t, _ = p.factor_comu()
        if isinstance(t,Rational):
            for i in range(1,t.q):
                r = (p + Rational(i,t.q) * u).punt()
                if r.tots_enters():
                    return r
                r = (p - Rational(i,t.q) * u).punt()
                if r.tots_enters():
                    return r
        return p
    #
    #
    #
    def equacio_continua(self,ref=None,prime=0):
        &#34;&#34;&#34;
        Retorna l&#39;expressió en latex de l&#39;equqció contínua de la recta afí
        en la referència &#34;ref&#34;.
        Paràmetres:
            ref: referència afí. Si és None, serà la canònica
            prime: nombre de primes que s&#39;escriuran a les incògnites
        &#34;&#34;&#34;
        if ref is None:
            v = Vector(self.u.components)
            q = Punt(self.p.components)
        else:
            v = self.u.components_en_base(ref.base)
            q = self.p.coordenades_en_referencia(ref)
        v.simplificar()
        q = self.punt_de_coordenades_enteres(q,v)
        x, y, z = symbols(&#39;x y z&#39;)
        incg = [x,y,z]
        eq = []
        p = &#34;&#34;
        if prime &gt; 0:
            p = prime * &#34;&#39;&#34;
        for i in range(v.dimensio):
            if v[i] == 1:
                eq.append(latex(incg[i] - q[i]))
            else:
                eq.append(f&#34;\\frac{{{latex(incg[i] - q[i])}}}{{{v[i]}}}&#34;)
        eq = &#34; = &#34;.join(eq)
        for i in incg:
            eq = eq.replace(latex(i),latex(i) + p)
        return eq
    #
    #
    #
    def equacions_implicites(self,ref=None,prime=0,aleatori=True):
        &#34;&#34;&#34;
        Retorna l&#39;equació implícita (dimensió 2) o el sistema d&#39;equacions implícites
        (dimensió 3) de la recta afí en la referència &#34;ref&#34;.
        Paràmetres:
           ref: referència en la que calculem les equacions implícites
           prime: nombre de primes que s&#39;escriran a les incògnites
           aleatori: només s&#39;aplica a dimensió 3 i genera unes equacions implícites
           amb tots els coeficients de les incògnites no nuls
        &#34;&#34;&#34;
        if ref is None:
            v = Vector(self.u.components)
            a = Matriu.matriu_fila(self.u)
            q = Punt(self.p.components)
        else:
            v = self.u.components_en_base(ref.base)
            a = Matriu.matriu_fila(v)
            q = self.p.coordenades_en_referencia(ref)
        l = a.nucli()
        if len(l) == 1:
            return EquacioLineal.coeficients(l[0],l[0].dot(q),False,prime)
        a = Matriu.from_vectors_fila(l)
        b = a * q
        if aleatori:
            trobat = False
            while not trobat:
                m = Matriu.amb_rang(f=2,c=2,r=2,maxim=3,mzeros=0)
                aux = m * a
                trobat = aux.nzeros() == 0
            a = m * a
            b = m * b
        return SistemaEquacions(a,b,prime=prime)
    #
    #
    #
    def distancia(self,other):
        &#34;&#34;&#34;
        Retorna la distància entre la recta actual i un punt, una recta o un pla
        Paràmetres:
            other: un punt (classe Punt), una recta (classe RectaAfi) o un plan
            (class PlaAfi)
        &#34;&#34;&#34;
        if isinstance(other,Punt):
            v = self.p - other
            w = self.u.cross(v)
            return w.length()/self.u.length()
        if isinstance(other,RectaAfi):
            w = self.u.cross(other.u,simplificar=True)
            if w.length() &gt; 0:
                u = self.p - other.p
                return abs(u.dot(w) / w.length())
            return self.distancia(other.p)
        if isinstance(other,PlaAfi):
            w = other.associat()
            if w.dot(self.u) == 0:
                return other.distancia(self.p)
            return 0
        return None
    #
    #
    #
    def punt(self,t):
        &#34;&#34;&#34;
        Retorna el punt de la recta amb paràmetre t
        Paràmetres:
            t: escalar
        &#34;&#34;&#34;
        q = self.p + t * self.u
        return Punt(q.components)
    #
    #
    #
    def projeccio_ortogonal(self,punt):
        &#34;&#34;&#34;
        Retorna la projecció ortogonal del punt &#34;punt&#34; sobre la recta
        Paràmetres:
          punt: Punt
        &#34;&#34;&#34;
        P = RectaVectorial(self.u)
        if not isinstance(punt,Punt):
            return None
        if punt.dimensio != self.u.dimensio:
            return None
        return (self.p + P.projeccio_ortogonal(punt - self.p)).punt()
    #
    #
    #
    def interseccio(self,other):
        &#34;&#34;&#34;
        Retorna la intersecció de la recta amb una altra recta o un pla.
        El resultat pot ser None, un punt o una recta.
        Paràmetes:
          other. PlaAfi o RectaAfi
        &#34;&#34;&#34;
        if isinstance(other,RectaAfi):
            if self.u.dimensio != other.u.dimensio:
                return None
            m = Matriu.from_vectors_columna([self.u,other.u])
            if m.rang() == 1:
                if self.conte(other.p):
                    return self
                return None
            if self.u.dimensio == 3:
                m = Matriu.from_vectors_columna([self.u,other.u,self.p - other.p])
                if m.det() != 0:
                    return None
            m = Matriu.from_vectors_columna([self.u,- other.u])
            b = other.p - self.p
            s = SistemaEquacions(m,b)
            s.resol()
            return (self.p + s.solucio[0] * self.u).punt()
        if isinstance(other,PlaAfi):
            m = Matriu.from_vectors_columna([other.u1,other.u2,-self.u])
            if m.det() != 0:
                b = self.p - other.p
                s = SistemaEquacions(m,b)
                s.resol()
                return (self.p + s.solucio[2] * self.u).punt()
            if other.conte(self.p):
                return self
        return None
    #
    #
    #
    def simetric(self,punt):
        &#34;&#34;&#34;
        Retorna el simètric del punt &#34;punt&#34; respecte a la recta
        Paràmetres:
          punt: Punt
        &#34;&#34;&#34;
        return 2*self.projeccio_ortogonal(punt) - punt
    #
    #
    #
    def conte(self,punt):
        &#34;&#34;&#34;
        Retorna si el punt &#34;punt&#34; pertany a la recta
        Paràmetres:
          punt: Punt
        &#34;&#34;&#34;
        if not isinstance(punt,Punt):
            return None
        if punt.dimensio != self.u.dimensio:
            return None
        m = Matriu.from_vectors_columna([self.u,punt - self.p])
        return m.rang() == 1


class SubespaiVectorial(object):
    &#34;&#34;&#34;
    Classe per treballar amb subespais vectorials
    Atributs:
       generadors: generadors del subespai
       base: base del subespai
       dimensio: dimensio del subespai
       espai: n si és un suespai de R^n
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,vecs,basern=None):
        &#34;&#34;&#34;
        Constructor.
        Retorna el subespai vectorial generat per una llista de vectors
        Paràmetres:
           vecs: llista de vectors
           basern: base en la que estan expressats els vectors
        &#34;&#34;&#34;
        a = Matriu.from_vectors_columna(vecs)
        if a is None:
            return None
        if basern is not None:
            if not isinstance(basern,Base):
                return None
            if basern.dimensio != a.files:
                return None
        return super(SubespaiVectorial,cls).__new__(cls)
    #
    #
    #
    def __init__(self,vecs,basern=None):
        if basern is None:
            for k in vecs:
                k.simplificar()
            self.generadors = [k for k in vecs]
        else:
            v = [basern.vector_de_components(k) for k in vecs]
            for k in v:
                k.simplificar()
            self.generadors = [k for k in v]
        a = Matriu.from_vectors_columna(self.generadors)
        L, U, _ = a.matriu.LUdecomposition()
        files = Matriu(U).vectors_fila()
        self.base = []
        for f in files:
            k = primer_no_nul(f.components)
            if k is not None:
                self.base.append(self.generadors[k])
        self.dimensio = len(self.base)
        self.espai = self.generadors[0].dimensio
    #
    #
    #
    @classmethod
    def from_equacions_implicites(cls,eqs,basern=None):
        &#34;&#34;&#34;
        Retorna el subespai vectorial que té equacions implícites &#34;eqs&#34;
        Paràmetres:
            eqs: equacions implícites (classe SistemaEquacions)
            basern: Base de R^n
        &#34;&#34;&#34;
        if basern is None:
            return cls(eqs.A.nucli())
        c = [basern.vector_de_components(u) for u in eqs.A.nucli()]
        return cls(c)
    #
    #
    #
    @classmethod
    def from_equacio_implicita(cls,eq,basern=None):
        &#34;&#34;&#34;
        Retorna el subespai vectorial que té equació implícita &#34;eq&#34;
        Paràmetres:
            eqs: equació implícita (classe EquacioLineal)
            basern: Base de R^n
        &#34;&#34;&#34;
        if not isinstance(eq,EquacioLineal):
            return None
        s = eq.to_sistema_equacions()
        return cls.from_equacions_implicites(s,basern)
    #
    #
    #
    def es_zero(self):
        &#34;&#34;&#34;
        Retorna True si és el subespai {0}
        &#34;&#34;&#34;
        return len(self.base) == 0
    #
    #
    #
    def es_total(self):
        &#34;&#34;&#34;
        Retorna True si és el subespai R^n
        &#34;&#34;&#34;
        return len(self.base) == self.espai
    #
    #
    #
    def equacions_implicites(self,basern=None,prime=0):
        &#34;&#34;&#34;
        Retorna unes equacions implícites del subespai
        Paràmetres:
            basern: base en la que s&#39;escriuran les equacions implícites
            prime: nombre de primes a les incògnites
        &#34;&#34;&#34;
        if self.es_total():
            return None
        b = Vector.nul(self.espai)
        if basern is None:
            a = Matriu.from_vectors_columna(self.base)
        else:
            c = [v.components_en_base(basern) for v in self.base]
            a = Matriu.from_vectors_columna(c)
        p = EquacionsParametriques(a,b)
        return (p.eliminar_parametres(prime))
    #
    #
    #
    def suplementari_ortogonal(self):
        &#34;&#34;&#34;
        Retorna el suplementari ortogonal
        &#34;&#34;&#34;
        a = Matriu.from_vectors_fila(self.base)
        return SubespaiVectorial(a.nucli())
    #
    #
    #
    def base_ortogonal(self):
        &#34;&#34;&#34;
        Retorna una base ortogonal del subespai
        &#34;&#34;&#34;
        if self.dimensio == 0:
            return None
        if len(self.base) == 1:
            return self.base
        L = []
        for b in self.base:
            a = Matriu.from_vectors_columna([b])
            L.append(a.matriu)
        Q = GramSchmidt(L)
        base = []
        for m in Q:
            m = Matriu(m)
            v = m.vectors_columna()[0]
            v.simplificar()
            base.append(v)
        return base
    #
    #
    #
    def amplia_base(self,unitaria=False):
        &#34;&#34;&#34;
        Retorna una base ortogonal amb orientació positiva de R^n
        que comença amb una base del subespai
        Paràmetres:
            unitaria: si és True, retorna una base ortonormal
        &#34;&#34;&#34;
        if self.es_total():
            b = Base(self.base_ortogonal(),unitaria)
        else:
            h = self.suplementari_ortogonal()
            b = Base(self.base_ortogonal() + h.base_ortogonal(),unitaria)
        b.orientacio_positiva()
        return b
    #
    #
    #
    def amplia_base_suplementari(self,unitaria=False):
        &#34;&#34;&#34;
        Retorna una base ortogonal amb orientació positiva de R^n
        que comença amb una base del suplementari ortogonal del subespai
        Paràmetres:
            unitaria: si és True, retorna una base ortonormal
        &#34;&#34;&#34;
        h = self.suplementari_ortogonal()
        b = Base(h.base_ortogonal() + self.base_ortogonal(),unitaria)
        b.orientacio_positiva()
        return b
    #
    #
    #
    def projeccio_ortogonal(self,u):
        &#34;&#34;&#34;
        Retorna la projeccio ortogonal del vector u sobre el subespai
        Parametres:
          u: Vector
        &#34;&#34;&#34;
        if not isinstance(u,Vector):
            return None
        if u.dimensio != self.espai:
            return None
        base = self.base_ortogonal()
        ts = [Rational(u.dot(v),v.dot(v)) for v in base]
        p = Vector.nul(self.espai)
        for i in range(len(base)):
            p += ts[i]*base[i]
        return p
    #
    #
    #
    def simetric(self,u):
        &#34;&#34;&#34;
        Retorna el simètric del vector u sobre respecte al subespai
        Parametres:
          u: Vector
        &#34;&#34;&#34;
        if not isinstance(u,Vector):
            return None
        if u.dimensio != self.espai:
            return None
        return 2*self.projeccio_ortogonal(u) - u
    #
    #
    #
    def __repr__(self):
        &#34;&#34;&#34;
        Retorna l&#39;expressió en latex del subespai
        &#34;&#34;&#34;
        base = &#34;,&#34;.join([v.latex(False) for v in self.base])
        return f&#34;&lt;{base}&gt;&#34;


class VarietatAfi(object):
    &#34;&#34;&#34;
    Classe per treballar amb varietats lineal
    Atributs:
       punt: punt de pas
       subespai: SubespaiVectorial
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,p,s,ref=None):
        &#34;&#34;&#34;
        Constructor.
        Retorna la varietat lineal que passa per p i té subespai director s
        Paràmetres:
           p: punt de pas
           s: subespai director
           ref: referència afí en la que estan expressats el punt p
        &#34;&#34;&#34;
        if not isinstance(p,Punt):
            return None
        if not isinstance(s,SubespaiVectorial):
            return None
        if p.dimensio != s.espai:
            return None
        if ref is not None:
            if not isinstance(ref,ReferenciaAfi):
                return None
            if ref.dimensio != p.dimensio:
                return None
        return super(VarietatAfi,cls).__new__(cls)
    #
    #
    #
    def __init__(self,p,s,ref=None):
        self.subespai = s
        if ref is None:
            self.punt = p
        else:
            self.punt = ref.punt_de_coordenades(p)
    #
    #
    #
    def es_un_punt(self):
        &#34;&#34;&#34;
        Retorna True si la varietat lineal és un punt
        &#34;&#34;&#34;
        return self.subespai.es_zero()
    #
    #
    #
    def es_total(self):
        &#34;&#34;&#34;
        Retorna True si la varietat lineal és P_n
        &#34;&#34;&#34;
        return self.subespai.es_total()
    #
    #
    #
    def equacions_implicites(self,ref=None,prime=0):
        &#34;&#34;&#34;
        Retorna unes equacions implícites de la varietat lineal
        Paràmetres:
            ref: referència en la que s&#39;escriuran les equacions implícites
            prime: nombre de primes de les incògnites
        &#34;&#34;&#34;
        if self.es_total():
            return None
        if ref is None:
            q = self.punt
            base = self.subespai.base
        else:
            q = self.punt.coordenades_en_referencia(ref)
            base = [v.components_en_base(ref.base) for v in self.subespai.base]
        a = Matriu.from_vectors_columna(base)
        p = EquacionsParametriques(a,q)
        return (p.eliminar_parametres(prime))
    #
    #
    #
    @classmethod
    def from_equacions_implicites(cls,eqs,ref=None):
        &#34;&#34;&#34;
        Retorna la varietat afí que té equacions implícites &#34;eqs&#34;
        en la referència afí &#34;ref&#34;
        Paràmetres:
            eqs: equacions implícites (classe SistemaEquacions)
            ref: Referència de P^n
        &#34;&#34;&#34;
        s = SubespaiVectorial(eqs.A.nucli())
        eqs.resol()
        sol = list(eqs.parametrica)
        for p in eqs.parametres:
            sol = [k.subs(p,0) for k in sol]
        p = Punt(sol)
        return cls(p,s,ref)
    #
    #
    #
    @classmethod
    def from_equacio_implicita(cls,eq,ref=None):
        &#34;&#34;&#34;
        Retorna la varietat afí que té equació implícita &#34;eq&#34;
        en la referència afí &#34;ref&#34;
        Paràmetres:
            eq: equació implícita (classe EquacioLineal)
            ref: Referència de P^n
        &#34;&#34;&#34;
        if not isinstance(eq,EquacioLineal):
            return None
        s = eq.to_sistema_equacions()
        return cls.from_equacions_implicites(s,ref)
    #
    #
    #
    def base_ortogonal(self):
        &#34;&#34;&#34;
        Retorna una base ortogonal del subespai director de la varietat lineal
        &#34;&#34;&#34;
        return self.subespai.base_ortogonal()
    #
    #
    #
    def varietat_ortogonal(self,p):
        &#34;&#34;&#34;
        Retorna la varietat ortogonal a l&#39;actual que passa pel punt p
        &#34;&#34;&#34;
        if not isinstance(p,Punt):
            return None
        if p.dimensio != self.subespai.espai:
            return None
        s = self.subespai.suplementari_ortogonal()
        return VarietatAfi(p,s)
    #
    #
    #
    def projeccio_ortogonal(self,punt):
        &#34;&#34;&#34;
        Retorna la projecció ortogonal del punt &#34;punt&#34; sobre la
        varietat afi
        Paràmetres:
          punt: Punt
        &#34;&#34;&#34;
        if not isinstance(punt,Punt):
            return None
        if punt.dimensio != self.subespai.espai:
            return None
        return (self.punt + self.subespai.projeccio_ortogonal(punt - self.punt)).punt()
    #
    #
    #
    def simetric(self,punt):
        &#34;&#34;&#34;
        Retorna el simètric del punt &#34;punt&#34; respecte a la varietat afí
        Paràmetres:
          punt: Punt
        &#34;&#34;&#34;
        return 2*self.projeccio_ortogonal(punt) - punt
    #
    #
    #
    def __repr__(self):
        &#34;&#34;&#34;
        Retorna l&#39;expressió en latex de la varietat afi
        &#34;&#34;&#34;
        return f&#34;{self.punt}+{self.subespai}&#34;


class TransformacioLineal(object):
    &#34;&#34;&#34;
    Classe per treballar amb transformacions lineals T:R^n ----&gt; R^n
    Atributs:
       dimensio: n
       canonica: matriu de la transformació en la base canònica
       format: format LaTeX per a la matriu
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,matriu,base=None):
        &#34;&#34;&#34;
        Constructor.
        Retorna una nova transformació lineal
        Paràmetres:
            matriu: matriu de la transformació lineal en la base &#34;base&#34;
            base: base de R^n. Si és None serà la canònica
        &#34;&#34;&#34;
        if not isinstance(matriu,Matriu):
            return None
        if matriu.files != matriu.columnes:
            return None
        if base is not None:
            if not isinstance(base,Base):
                return None
            if base.dimensio != matriu.files:
                return None
        return super(TransformacioLineal,cls).__new__(cls)
    #
    #
    #
    def __init__(self,matriu,base=None):
        self.dimensio = matriu.files
        if base is None:
            self.canonica = Matriu(matriu.matriu)
        else:
            c = base.matriu()
            m = c.matriu * matriu.matriu * c.matriu**(-1)
            self.canonica = Matriu(m)
        self.format = None
    #
    #
    #
    def set_format(self,format):
        &#34;&#34;&#34;
        Estableix el format LaTeX per a la matriu
        &#34;&#34;&#34;
        self.format = format
    #
    #
    #
    def determinant(self):
        &#34;&#34;&#34;
        Retorna el deterinant de la transformació lineal
        &#34;&#34;&#34;
        return self.canonica.determinant()
    #
    #
    #
    @classmethod
    def aleatoria(cls,ordre=3,maxim=4):
        &#34;&#34;&#34;
        Retorna una transformació lineal aleatòria
        Paràmetres:
            ordre: ordre de la matriu corresponent
            maxim: Nombre màqxim que apareix a la matriu en la base
                   canònica de la transformació
        &#34;&#34;&#34;
        A = Matriu.aleatoria(f=ordre,c=ordre,maxim=maxim,nuls=False)
        return cls(A)
    #
    #
    #
    def es_rotacio(self):
        &#34;&#34;&#34;
        Ens diu si és una rotació tridimensional o no
        &#34;&#34;&#34;
        if self.dimensio != 3:
            return False
        d = self.determinant()
        if abs(N(d) - 1.0) &gt; 10**(-8):
            return False
        m = self.canonica
        u = Matriu()
        k = m.transposada() * m
        for i in range(k.files):
            for j in range(k.columnes):
                p = N(k[i,j])
                if abs(p - u[i,j]) &gt; 10**(-8):
                    return False
        return True
    #
    #
    #
    def eix_angle_rotacio(self,radiants=False):
        &#34;&#34;&#34;
        Retorna l&#39;eix i l&#39;angle de rotació
        Paràmetres:
            radiants: si és True retorna l&#39;angle en radiants, en cas contrari,
            ho fa en graus
        &#34;&#34;&#34;
        if not self.es_rotacio():
            return None
        m = self.canonica - Matriu()
        e = m.nucli()[0]
        e = Vector([radsimp(k.expand()) for k in e.components])
        e.simplificar(positiu=True)
        t = radsimp(self.canonica.matriu.trace().expand())
        t = (t - 1)/2
        alpha = acos(t)
        u = e.perpendicular()[0]
        v = self.transforma(u)
        A = Matriu.from_vectors_columna([e,u,v])
        if A.det() &lt;= 0:
            alpha = 2*pi - alpha
        if not radiants:
            alpha = alpha * 180/pi
        return (e,alpha)
    #
    #
    #
    def quaternio(self):
        &#34;&#34;&#34;
        Retorna un dels quaternions que definieix una rotació. Recordem
        que l&#39;altre és l&#39;oposat
        &#34;&#34;&#34;
        if not self.es_rotacio():
            return None
        w, angle = self.eix_angle_rotacio(radiants=True)
        w.simplificar(positiu=True)
        w.normalitzar()
        w *= sin(angle/2)
        w = Vector([radsimp(x.expand()) for x in w.components])
        return Vector(radsimp(radsimp(cos(angle/2).expand())),w[0],w[1],w[2])
    #
    #
    #
    def angles_euler(self,radiants=False):
        &#34;&#34;&#34;
        Retorna els angles d&#39;Euler de la rotació corresponents a l&#39;ordre &#39;ZXZ&#39;
        Paràmetres:
            radiants: si és True retorna els angles en radiants, en cas contrari,
            ho fa en graus
        &#34;&#34;&#34;
        if not self.es_rotacio():
            return None
        m = self.canonica
        if abs(m[2,2]) != 1:
            theta = acos(m[2,2])
            psi = atan2(m[2,0],m[2,1])
            phi = atan2(m[0,2],-m[1,2])
        else:
            phi = 0
            theta = acos(m[2,2])
            psi = atan2(m[2,2] * m[1,0],m[0,0])
        if psi &lt; 0:
            psi += 2*pi
        if theta &lt; 0:
            theta += 2*pi
        if phi &lt; 0:
            phi += 2*pi
        if not radiants:
            theta *= 180 / pi
            psi *= 180 / pi
            phi *= 180 / pi
        return (psi,theta,phi)
    #
    #
    #
    @classmethod
    def gir(cls,angle,radiants=False):
        &#34;&#34;&#34;
        Retorna el gir d&#39;angle &#34;angle&#34; en dimensió 2
        Paràmetres:
            angle: angle de rotació
            radiants: si l&#39;angle està en radiants, ha de ser True
        &#34;&#34;&#34;
        if not radiants:
            angle *= pi / 180
        m = Matriu.from_vectors_columna([Vector(cos(angle),sin(angle)),Vector(-sin(angle),cos(angle))])
        return cls(m)
    #
    #
    #
    @classmethod
    def rotacio(cls,eix,angle,radiants=False):
        &#34;&#34;&#34;
        Retorna la rotació d&#39;angle &#34;angle&#34; al voltant del vector &#34;eix&#34;
        Paràmetres:
            eix: vector al voltant del qual fem la rotació
            angle: angle de rotació
            radiants: si l&#39;angle està en radiants, ha de ser True
        &#34;&#34;&#34;
        if not radiants:
            angle *= pi / 180
        v = Vector(eix.components)
        v.normalitzar()
        q = Quaternion.from_axis_angle(v.components,angle)
        m = Matriu(q.to_rotation_matrix())
        for i in range(m.files):
            for j in range(m.columnes):
                m[(i,j)] = radsimp(m[(i,j)].expand())
        return cls(m)
    #
    #
    #
    @classmethod
    def rotacio_amb_angles_euler(cls,psi,theta,phi,ordre=&#39;ZXZ&#39;,radiants=False):
        &#34;&#34;&#34;
        Retorna la rotació amb angles d&#39;Euler psi, theta i phi al voltant dels
        dels eixos determinats pel paràmetre ordre
        Paràmetres:
            psi, theta i phi: angles d&#39;Euler
            ordre: eixos al voltant dels que fem les rotacions
            radiants: si l&#39;angle està en radiants, ha de ser True
        &#34;&#34;&#34;
        ordres = [&#39;XYZ&#39;,&#39;XZY&#39;,&#39;YXZ&#39;,&#39;YZX&#39;,&#39;ZXY&#39;,&#39;ZYX&#39;,
                  &#39;XZX&#39;,&#39;XYX&#39;,&#39;YXY&#39;,&#39;YZY&#39;,&#39;ZXZ&#39;,&#39;ZYZ&#39;]
        vectors = {&#39;X&#39; : Vector(1,0,0),
                   &#39;Y&#39; : Vector(0,1,0),
                   &#39;Z&#39; : Vector(0,0,1)}
        ordre = ordre.upper()
        angles = [psi,theta,phi]
        if ordre not in ordres:
            return None
        m = []
        for i, s in enumerate(ordre):
            r = cls.rotacio(vectors[s],angles[i],radiants)
            m.append(r)
        A = m[2].canonica * m[1].canonica * m[0].canonica
        return cls(A)
    #
    #
    #
    @classmethod
    def rotacio_amb_quaternio(cls,q):
        &#34;&#34;&#34;
        Retorna la rotació definida pel quaternio &#34;q&#34;
        Paràmetres:
             q: element de la classe Quaternio
        &#34;&#34;&#34;
        if not isinstance(q,Quaternion):
            return None
        n = (q.norm()**2).expand()
        if n != 1 and abs(N(sqrt(n)) - 1.0) &gt; 10**(-12):
            return None
        m = Matriu(q.to_rotation_matrix())
        for i in range(m.files):
            for j in range(m.columnes):
                m[(i,j)] = radsimp(m[(i,j)].expand())
        return cls(m)
    #
    #
    #
    @classmethod
    def escalat(cls,factors,base=None):
        &#34;&#34;&#34;
        Retorna la transformació lineal que consisteix en escalats de factors
        &#34;factor&#34; en les direccions de la base &#34;base&#34;
        Paràmetres:
            factors: llista de nombres
            base: element de la classe Base
        &#34;&#34;&#34;
        if base is None:
            base = Base.canonica(dimensio=len(factors))
        if len(factors) != base.dimensio:
            return None
        A = Matriu.diagonal(factors)
        return cls(A,base)
    #
    #
    #
    @classmethod
    def projeccio_ortogonal(cls,s):
        &#34;&#34;&#34;
        Retorna la projecció ortogonal sobre el subespai &#34;s&#34;
        Paràmetres:
            s: subespai vectorial (classe SubespaiVectorial)
        &#34;&#34;&#34;
        if not isinstance(s,SubespaiVectorial):
            return None
        n = s.espai
        m = s.dimensio
        uns = [1 for k in range(m)]
        zeros = [0 for k in range(n-m)]
        d = uns + zeros
        b = Base(s.base + s.suplementari_ortogonal().base)
        m = Matriu.diagonal(d)
        return cls(m,b)
    #
    #
    #
    @classmethod
    def simetria(cls,s):
        &#34;&#34;&#34;
        Retorna la simetria respecte al subespai &#34;s&#34;
        Paràmetres:
            s: subespai vectorial (classe SubespaiVectorial)
        &#34;&#34;&#34;
        if not isinstance(s,SubespaiVectorial):
            return None
        n = s.espai
        m = s.dimensio
        uns = [1 for k in range(m)]
        menys = [-1 for k in range(n-m)]
        d = uns + menys
        b = Base(s.base + s.suplementari_ortogonal().base)
        m = Matriu.diagonal(d)
        return cls(m,b)
    #
    #
    #
    def matriu_en_base(self,base):
        &#34;&#34;&#34;
        Retorna la matriu de la transformacio lineal en la base &#34;base&#34;
        Paràmetres:
            base: base de R^n (classe Base)
        &#34;&#34;&#34;
        if base is None:
            return self.canonica
        c = base.matriu()
        m = c.matriu**(-1) * self.canonica.matriu * c.matriu
        return Matriu(m)
    #
    #
    #
    def antiimatges(self,v):
        &#34;&#34;&#34;
        Retorna les antiimages del vector v
        Paràmetres:
            v: element de la classe Vector
        &#34;&#34;&#34;
        if self.dimensio != v.dimensio:
            return None
        s = SistemaEquacions(self.canonica,v)
        s.resol()
        return Vector(s.solucio), s.secundaries
    #
    #
    #
    def latex(self,base=None,prime=0):
        &#34;&#34;&#34;
        Retorna l&#39;expressió en latex de la transformació lineal en la base &#34;base&#34;
        Si base és None, serà en la base canònica
        Paràmetres:
            base: base de R^n
            prime: nombre de primes que s&#39;han d&#39;escriure
        &#34;&#34;&#34;
        if self.dimensio &lt;= 4:
            x, y, z, t = symbols(&#39;x y z t&#39;)
            u, v, w, r = symbols(&#39;u v w r&#39;)
            o = [x,y,z,t]
            d = [u,v,w,r]
        else:
            x1, x2, x3, x4, x5, x6, x7, x8 = symbols(&#39;x1 x2 x3 x4 x5 x6 x7 x8&#39;)
            u1, u2, u3, u4, u5, u6, u7, u8 = symbols(&#39;u1 u2 u3 u4 u5 u6 u7 u8&#39;)
            o = [x1, x2, x3, x4, x5, x6, x7, x8]
            d = [u1, u2, u3, u4, u5, u6, u7, u8]
        o = o[0:self.dimensio]
        d = d[0:self.dimensio]
        p = prime * &#34;&#39;&#34;
        o = &#34; \\\\ &#34;.join([latex(x)+p for x in o])
        d = &#34; \\\\ &#34;.join([latex(x)+p for x in d])
        if base is None:
             m = self.canonica
             m.set_format(self.format)
        else:
            if not isinstance(base,Base):
                return None
            c = base.matriu()
            m = c.matriu**(-1) * self.canonica.matriu * c.matriu
            m = Matriu(m)
            m.set_format(self.format)
        s = &#34;\\begin{pmatrix}{c} &#34; + d + &#34;\\end{pmatrix} = \n&#34;
        s += f&#34;{m}\n&#34;
        s += &#34;\\begin{pmatrix}{c} &#34; + o + &#34;\\end{pmatrix}&#34;
        return s
    #
    #
    #
    def __repr__(self):
        &#34;&#34;&#34;
        Retorna el latex de l&#39;expressió en la base canònica de la transformació lineal
        &#34;&#34;&#34;
        return self.latex()
    #
    #
    #
    def imatges_una_base(self,base):
        &#34;&#34;&#34;
        Retorna l&#39;expressió en LaTeX de les imatges dels vectors de la base &#34;base&#34;
        Paràmetres:
            base: element de la classe Base
        &#34;&#34;&#34;
        if not isinstance(base,Base):
            return None
        if self.dimensio != base.dimensio:
            return None
        ts = []
        for x in base.vecs:
            y = self.transforma(x)
            ts.append(f&#34;T{x} &amp;= {y}&#34;)
        ts = &#34; \\\\ \n&#34;.join(ts)
        str = &#34;\\left.\\begin{aligned}\nIMATGES\n\\end{aligned}\\,\\right\\}&#34;
        return str.replace(&#39;IMATGES&#39;,ts)
    #
    #
    #
    def rang(self):
        &#34;&#34;&#34;
        Retorna el rang de la transfoprmació afí
        &#34;&#34;&#34;
        return self.canonica.rang()
    #
    #
    #
    def rank(self):
        &#34;&#34;&#34;
        Retorna el rang de la transfoprmació afí
        &#34;&#34;&#34;
        return self.canonica.rang()
    #
    #
    #
    def __eq__(self,other):
        &#34;&#34;&#34;
        Permet comparar transfonacions lineals amb ==
        Paràmetres:
            other: una altra transformació lineal
        &#34;&#34;&#34;
        return self.canonica == other.canonica
    #
    #
    #
    def __add__(self,other):
        &#34;&#34;&#34;
        Suma de transformacions lineals
        Paràmetres:
            other: una altra transformació lineal
        &#34;&#34;&#34;
        if other.dimensio != self.dimensio:
            return None
        m = self.canonica + other.canonica
        return TransformacioLineal(m)
    #
    #
    #
    def __mul__(self,other):
        &#34;&#34;&#34;
        Composició de transformacions lineal o càlcul de imatges
        Paràmetres:
            other: transformació lineal o vector
        &#34;&#34;&#34;
        if isinstance(other,TransformacioLineal):
            if other.dimensio != self.dimensio:
                return None
            m = self.canonica * other.canonica
            return TransformacioLineal(m)
        if isinstance(other,Vector):
            if other.dimensio != self.dimensio:
                return None
            return self.canonica * other
        return None
    #
    #
    #
    def es_simetrica(self):
        &#34;&#34;&#34;
        Retorna si la transformació lineal és simètrica
        &#34;&#34;&#34;
        return self.canonica == self.canonica.transposada()
    #
    #
    #
    def transforma(self,vec,base=None):
        &#34;&#34;&#34;
        Calcula el transformat (imatge) del vector &#34;vec&#34;.
        Paràmetres:
            vec: vector
            base: si no és None, vec seran les compoents del vectors en aquesta
            base. El transformat o imatge també estarà expressat en aquesta base
        &#34;&#34;&#34;
        if not isinstance(vec,Vector):
            return None
        if vec.dimensio != self.dimensio:
            return None
        if base is None:
            t = self.canonica * vec
        else:
            if not isinstance(base,Base):
                return None
            c = base.matriu()
            m = c.matriu**(-1) * self.canonica.matriu * c.matriu
            m = Matriu(m)
            t = m * vec
        for k in range(t.dimensio):
            t[k] = simplify(t[k].expand())
        return t
    #
    #
    #
    def polinomi_caracteristic(self):
        &#34;&#34;&#34;
        Retorna el polinomi característic de la transformació lineal
        &#34;&#34;&#34;
        return self.canonica.polinomi_caracteristic()
    #
    #
    #
    def es_vector_propi(self,u):
        &#34;&#34;&#34;
        Retorna si el vector &#34;u&#34; és o no un vector propi
        Paràmetres:
            u: element de la class Vector
        &#34;&#34;&#34;
        if not isinstance(u,Vector):
            return None
        if self.dimensio != u.dimensio:
            return None
        v = self.transforma(u)
        return v.es_proporcional(u)
    #
    #
    #
    def diagonalitza(self,ortogonals=False):
        &#34;&#34;&#34;
            Diagonalitza la matriu de la transformació lineal en la base canònica
        &#34;&#34;&#34;
        self.canonica.diagonalitza(ortogonals)


class TransformacioAfi:
    &#34;&#34;&#34;
    Classe per treballar amb transformacions afins T:P^n ----&gt; P^n, on
    T(p) = T + A(p)
    Atributs:
        transformacio: Transformació lineal donada per la matriu A
        translacio: translació de la transformació afí en la referència canònica
        dimensio: n
        formats: formats LaTeX en que s&#39;escriuen les matrius de la transfornació
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,p,t):
        &#34;&#34;&#34;
        Contructor:
        Retorna una transformació afí
        Paràmetres:
           p: Punt que representa la translació en la referencia canònica,
              és a dir, el transformat del punt zero
           t: Transformació lineal
        &#34;&#34;&#34;
        if not isinstance(p,Vector):
            return None
        if not isinstance(t,TransformacioLineal):
            return None
        if p.dimensio != t.dimensio:
            return None
        return super(TransformacioAfi,cls).__new__(cls)
    #
    #
    #
    def __init__(self,p,t):
        self.translacio = p
        self.transformacio = t
        self.dimensio = self.transformacio.dimensio
        self.formats = None
    #
    #
    #
    @classmethod
    def aleatoria(cls,ordre=3,maxim=4):
        &#34;&#34;&#34;
        Retorna una transformació afí aleatòria
        Paràmetres:
            ordre: ordre de la matriu corresponent
            maxim: Nombre màqxim que apareix a la matriu en la base
                   canònica de la transformació i en la translació
        &#34;&#34;&#34;
        T = TransformacioLineal.aleatoria(ordre=ordre,maxim=maxim)
        t = Vector.aleatori(l=ordre,maxim=maxim,nuls=False)
        return cls(t,T)
    #
    #
    #
    @classmethod
    def gir(cls,angle,origen,radiants=False):
        &#34;&#34;&#34;
        Retorna el gir d&#39;angle &#34;angle&#34; al voltant del punt &#34;origen&#34;
        Paràmetres:
            origen: centre del gir (classe Punt)
            angle: angle de rotació
            radiants: si és True, l&#39;angle ha d&#39;estar expressat en radiants
        &#34;&#34;&#34;
        if not isinstance(origen,Punt):
            return None
        if origen.dimensio != 2:
            return None
        t = TransformacioLineal.gir(angle,radiants)
        p = - t.transforma(origen) + origen
        return cls(p,t)
    #
    #
    #
    @classmethod
    def simetria(cls,v):
        &#34;&#34;&#34;
        Retorna la simetria respecte a la variatat lineal &#34;v&#34;
        Paràmetres:
            v: varietat lineal (classe VarietatLineal)
        &#34;&#34;&#34;
        if not isinstance(v,VarietatLineal):
            return None
        t = TransformacioLineal.simetria(v.subespai)
        p = - t.transforma(v.punt) + v.punt
        return cls(p,t)
    #
    #
    #
    @classmethod
    def projeccio_ortogonal(cls,v):
        &#34;&#34;&#34;
        Retorna la projecció ortogonal sobre la variatat lineal &#34;v&#34;
        Paràmetres:
            v: varietat lineal (classe VarietatLineal)
        &#34;&#34;&#34;
        if not isinstance(v,VarietatLineal):
            return None
        t = TransformacioLineal.projeccio_ortogonal(v.subespai)
        p = - t.transforma(v.punt) + v.punt
        return cls(p,t)
    #
    #
    #
    @classmethod
    def moviment_helicoidal(cls,recta,angle,radiants=False,alpha=0):
        &#34;&#34;&#34;
        Retorna el moviment helicoidal de P_3 que consisteix en la rotació
        d&#39;angle &#34;angle&#34; al voltant de la recta &#34;recta&#34; seguit d&#39;una translació
        de vector alpha * vector director de la recta.
        Paràmetres:
            recta: eix de rotació
            angle: angle de rotació
            radiants: si és True, l&#39;angle ha d&#39;estar expressat en radiants
            alpha: factor de la translació
        &#34;&#34;&#34;
        if not isinstance(recta,RectaAfi):
            return None
        if not recta.u.dimensio == 3:
            return None
        rotacio = TransformacioLineal.rotacio(recta.u,angle,radiants)
        p = - rotacio.transforma(recta.p) + recta.p + alpha * recta.u
        return cls(p,rotacio)
    #
    #
    #
    @classmethod
    def rotacio(cls,recta,angle,radiants=False):
        &#34;&#34;&#34;
        Retorna la rotació d&#39;angle &#34;angle&#34; al voltant de la recta &#34;recta&#34;
        Paràmetres:
            recta: eix de rotació
            angle: angle de rotació
            radiants: si és True, l&#39;angle ha d&#39;estar expressat en radiants
        &#34;&#34;&#34;
        return cls.moviment_helicoidal(recta,angle,radiants)
    #
    #
    #
    def set_formats(self,f1,f2):
        self.formats = [f1,f2]
    #
    #
    #
    def rang(self):
        &#34;&#34;&#34;
        Retorna el rang de la transfoprmació afí
        &#34;&#34;&#34;
        return self.transformacio.rang()
    #
    #
    #
    def rank(self):
        &#34;&#34;&#34;
        Retorna el rang de la transfoprmació afí
        &#34;&#34;&#34;
        return self.transformacio.rang()
    #
    #
    #
    def __repr__(self):
        &#34;&#34;&#34;
        Restorna en format latex l&#39;expressió de la transformació afí en la
        referència canònica
        &#34;&#34;&#34;
        return self.latex()
    #
    #
    #
    def latex(self,ref=None,prime=0):
        &#34;&#34;&#34;
        Retorna l&#39;expressió en latex de la transformació afí en la referència
        &#34;ref&#34;. Si ref és None, serà en la referència canònica
        Paràmetres:
            base: referència de P^n
            prime: nombre de primes que s&#39;escriuran
        &#34;&#34;&#34;
        if self.dimensio &lt;= 4:
            x, y, z, t = symbols(&#39;x y z t&#39;)
            u, v, w, r = symbols(&#39;u v w r&#39;)
            o = [x,y,z,t]
            d = [u,v,w,r]
        else:
            x1, x2, x3, x4, x5, x6, x7, x8 = symbols(&#39;x1 x2 x3 x4 x5 x6 x7 x8&#39;)
            u1, u2, u3, u4, u5, u6, u7, u8 = symbols(&#39;u1 u2 u3 u4 u5 u6 u7 u8&#39;)
            o = [x1, x2, x3, x4, x5, x6, x7, x8]
            d = [u1, u2, u3, u4, u5, u6, u7, u8]
        o = o[0:self.dimensio]
        d = d[0:self.dimensio]
        p = prime * &#34;&#39;&#34;
        o = &#34; \\\\ &#34;.join([latex(x)+p for x in o])
        d = &#34; \\\\ &#34;.join([latex(x)+p for x in d])
        z = Punt.nul(self.dimensio)
        tz = self.transforma(z,ref)
        if ref is None:
            m = self.transformacio.canonica
        else:
            m = self.transformacio.matriu_en_base(ref.base)
        s = &#34;\\begin{pmatrix}{c} &#34; + d + &#34;\\end{pmatrix} = \n&#34;
        if tz.length() &gt; 0:
            tz = Matriu.matriu_columna(tz)
            if self.formats is not None:
                tz.set_format(self.formats[0])
            s += f&#34;{tz} + \n&#34;
        if self.formats is not None:
            m.set_format(self.formats[1])
        s += f&#34;{m}\n&#34;
        s += &#34;\\begin{pmatrix}{c} &#34; + o + &#34;\\end{pmatrix}&#34;
        return s
    #
    #
    #
    def __eq__(self,other):
        &#34;&#34;&#34;
        Permet comparar transfonacions afins amb ==
        Paràmetres:
            other: una altra transformació afí
        &#34;&#34;&#34;
        return self.canonica == other.canonica and self.translacio == other.translacio
    #
    #
    #
    def __add__(self,other):
        &#34;&#34;&#34;
        Suma de transformacions afins
        Paràmetres:
            other: una altra transformació afi
        &#34;&#34;&#34;
        if other.dimensio != self.dimensio:
            return None
        m = self.canonica + other.canonica
        t = TansformacioLineal(m)
        tr = self.translacio + other.translacio
        return TransformacioAfi(tr,t)
    #
    #
    #
    def __mul__(self,other):
        &#34;&#34;&#34;
        Composició de transformacions afins o càlcul de imatges de punts
        Paràmetres:
            other: transformació afi o punt
        &#34;&#34;&#34;
        if isinstance(other,TransformacioAfi):
            if other.dimensio != self.dimensio:
                return None
            t = self.translacio + self.transformacio * other.translacio
            t = Punt(list(map(simplify,t.components)))
            tr = self.transformacio * other.transformacio
            return TransformacioAfi(t,tr)
        if isinstance(other,Punt):
            if other.dimensio != self.dimensio:
                return None
            t = self.translacio + self.transformacio * other
            return Punt(list(map(simplify,t.components)))
        return None
    #
    #
    #
    def transforma(self,p,ref=None):
        &#34;&#34;&#34;
        Calcula el transformat o imatge del punt &#34;p&#34;. p seran les coordenades
        d&#39;aquest punt en la referència &#34;ref&#34; i el transformat també estarà expressat
        en aquesta referència
        Paràmetres:
            punt: punt (classe Punt)
            ref: referència afí. Si és None, serà la referència canònica
        &#34;&#34;&#34;
        if not isinstance(p,Vector):
            return None
        if self.dimensio != p.dimensio:
            return None
        if ref is None:
            return self.translacio + self.transformacio.transforma(p)
        q = ref.punt_de_coordenades(p)
        p = Punt(self.transforma(q).components)
        return p.coordenades_en_referencia(ref)


class FormaQuadratica(object):
    &#34;&#34;&#34;
    Classe per treballar amb formes quadràtiques
    Atributs:
        matriu: matriu de la forma quadrètica en la base canònica
        dimensio: n
        vaps: valors propis
        base: base oronormal en la que diagonalitza
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,matriu,base=None):
        &#34;&#34;&#34;
        Contructor:
        Retorna una forma quadràtica
        Paràmetres:
           matriu: matriu simètrica de la forma quadratica en la base &#34;base&#34;
           base: base ortonormal de R^n. Si és None, serà la canònica
        &#34;&#34;&#34;
        if not isinstance(matriu,Matriu):
            return None
        if matriu.files != matriu.columnes:
            return None
        if matriu != matriu.transposada():
            return None
        if base is not None:
            if not isinstance(base,Base):
                return None
            if not base.es_ortogonal():
                return None
            if not base.es_unitaria():
                return None
        return super(FormaQuadratica,cls).__new__(cls)
    #
    #
    #
    def __init__(self,matriu,base=None):
        self.dimensio = matriu.columnes
        if base is None:
            self.matriu = matriu
        else:
            c = base.matriu()
            self.matriu = c * matriu * c.transposada()
        e = self.matriu.matriu.eigenvects()
        vaps = []
        veps = []
        va, ve = vaps_veps_amb_signe(e,signe=1)
        vaps += va
        veps += ve
        va, ve = vaps_veps_amb_signe(e,signe=-1)
        vaps += va
        veps += ve
        s = SubespaiVectorial(veps)
        self.base = s.amplia_base(unitaria=True)
        self.vaps = Vector(vaps + (self.dimensio - len(vaps)) * [0])
    #
    #
    #
    def __repr__(self):
        &#34;&#34;&#34;
        Retorna l&#39;expressió en latex de la forma quadràtica com a polinomi
        de segon grau en la base canònica
        &#34;&#34;&#34;
        return self.latex()
    #
    #
    #
    def latex(self,base=None,prime=0):
        &#34;&#34;&#34;
        Retorna l&#39;expressió en latex de la forma quadràtica com a polinomi
        de segon grau en la base &#34;base&#34;
        Paràmetres:
            base: base de R^n. No cal que sigui ortormal. Si és None, serà la
            base canònica
            prime: nombre de primes que s&#39;escriuran a les variables del polinomi
            segon grau
        &#34;&#34;&#34;
        if self.dimensio &lt;= 4:
            x, y, z, t = symbols(&#39;x y z t&#39;)
            s = [x,y,z,t]
        else:
            x1, x2, x3, x4, x5, x6, x7, x8 = symbols(&#39;x1 x2 x3 x4 x5 x6 x7 x8&#39;)
            s = [x1, x2, x3, x4, x5, x6, x7, x8]
        s = Vector(s[0:self.dimensio])
        m = Matriu.matriu_columna(s)
        if base is None:
            q = self.matriu
        else:
            c = base.matriu()
            q = c.transposada() * self.matriu * c
        r = m.transposada() * q * m
        if self.dimensio &lt;= 4:
            expr = mylatex(r[0,0].expand())
        else:
            expr = latex(r[0,0].expand())
        if prime == 0:
            return expr
        p = prime * &#34;&#39;&#34;
        for k in s.components:
            expr = expr.replace(latex(k),latex(k)+p)
        return expr
    #
    #
    #
    @classmethod
    def aleatoria(cls,ordre=3,maxim=20,vapsnonuls=2):
        &#34;&#34;&#34;
        Retorna una forma quadràtica aleatòria
        Paràmetres:
            ordre: ordre de la matriu simètrica de la forma quadràtica
            maxim: nombre màxim dels coeficients de la matriu
            vapsnonuls: nombre mínim de valrs propis no nuls
        &#34;&#34;&#34;
        trobat = False
        while not trobat:
            vaps = Vector.aleatori(l=ordre,maxim=3)
            if len(set(vaps.components)) == 1:
                continue
            nonuls = [x for x in vaps.components if x != 0]
            if len(nonuls) &lt; vapsnonuls:
                continue
            d = Matriu.diagonal(vaps)
            b = Base.ortogonal(ordre=ordre,maxim=5)
            c = b.matriu()
            m = c * d * c.transposada()
            if m.norma_maxim() &gt; maxim:
                continue
            trobat = not m.es_diagonal()
        return cls(m)
    #
    #
    #
    def signatura(self):
        &#34;&#34;&#34;
        Retorna la signatura o índexs d&#39;inèrcia de la forma quadràtica
        &#34;&#34;&#34;
        r = 0
        s = 0
        for k in self.vaps.components:
            if k &gt; 0:
                r += 1
            elif k &lt; 0:
                s += 1
        return (r,s)
    #
    #
    #
    def classificacio(self):
        &#34;&#34;&#34;
        Retorna la classificació de la forma quadràtica
        &#34;&#34;&#34;
        r, s = self.signatura()
        if r == self.dimensio:
            return &#34;definida positiva&#34;
        if s == self.dimensio:
            return &#34;definida negativa&#34;
        if s == 0:
            return &#34;semidefinida positiva&#34;
        if r == 0:
            return &#34;semidefinida negativa&#34;
        return &#34;indefinida&#34;
    #
    #
    #
    def rank(self):
        &#34;&#34;&#34;
        Retorna el rang de la forma quadràtica
        &#34;&#34;&#34;
        r, s = self.signatura()
        return r + s
    #
    #
    #
    def polinomi_caracteristic(self):
        &#34;&#34;&#34;
        Retorna el polinomi característic de la forma quadràtica
        &#34;&#34;&#34;
        return self.matriu.polinomi_caracteristic()
    #
    #
    #
    def expressio_euclidiana(self,prime=1):
        &#34;&#34;&#34;
        Retorna l&#39;expressió euclidiana reduïda de la forma de polinomi
        expressat en LaTeX
        Paràmetres:
            prime: nombre de primes que s&#39;escriuran a les variables
        &#34;&#34;&#34;
        return self.latex(self.base,prime=prime)


class Conica(object):
    &#34;&#34;&#34;
    Classe per treballar amb còniques. L&#39;objectiu no és classificar còniques,
    sinó generar coniques a partir dels elements característics o de manera
    aleatòria.
    Atributs:
        ref: referència euclidiana
        matriu: matriu projectiva de la cònica en la referència &#34;ref&#34;
        canonica: matriu projectiva de la cònica en la referència canònica
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,matriu,ref=None):
        &#34;&#34;&#34;
        Retorna una nova cònica
        Paràmetres:
            matriu: matriu projectiva de la cònica en la referència &#34;ref&#34;
            Ha de ser 3x3
            ref: referència afí. Si és None, serà la referència canònica
        &#34;&#34;&#34;
        if not isinstance(matriu,Matriu):
            return None
        if matriu.files != matriu.columnes:
            return None
        if matriu.files != 3:
            return None
        if not matriu.es_simetrica():
            return None
        if ref is not None:
            if ref.dimensio != 2:
                return None
            if not ref.base.es_unitaria():
                return None
            if not ref.base.es_ortogonal():
                return None
        return super(Conica,cls).__new__(cls)
    #
    #
    #
    def __init__(self,matriu,ref=None):
        self.ref = ref
        self.matriu = matriu
        if ref is None:
            self.canonica = matriu
        else:
            a = ref.base.matriu()
            a = a.inserta_columna(2,ref.origen)
            a = a.inserta_fila(2,Vector([0,0,1]))
            b = a.inversa()
            self.canonica = b.transposada() * matriu * b
            self.canonica.simplificar()
    #
    #
    #
    @classmethod
    def from_equacio(cls,eq):
        &#34;&#34;&#34;
        Retorna i classifica la cònica a partir de la seva equació.
        Només per a el·lipses, hipèrboles i paràboles
        &#34;&#34;&#34;
        x, y = symbols(&#39;x y&#39;)
        unknowns = [x,y]
        a = diff(eq,x,2) / 2
        b = diff(eq,x,y) / 2
        c = diff(eq,y,2) / 2
        d = (diff(eq,x).subs({x:1,y:0}) - 2 * a) / 2
        e = (diff(eq,y).subs({x:0,y:1}) - 2 * c) / 2
        f = eq.subs({x:0,y:0})
        Q = Matrix([[a,b],[b,c]])
        L = Matrix(2,1,[d,e])
        l = Vector(d,e)
        vs = Q.eigenvects()
        (t1,t2), veps = vaps_veps(vs)
        s = list(linsolve((Q,-L),*unknowns))
        if t1 * t2 &lt; 0:
            #
            # Hipèrbola
            #
            s = Punt(list(s[0]))
            fp = eq.subs({x:s[0],y:s[1]})
            a2 = -fp/t1
            b2 = -fp/t2
            if a2 &gt; 0:
                u = veps[0]
            else:
                a2, b2 = b2, a2
                u = veps[1]
            return Hiperbola(a2,-b2,s,u)
        if t1 * t2 &gt; 0:
            #
            # El·lipse
            #
            s = Punt(list(s[0]))
            fp = eq.subs({x:s[0],y:s[1]})
            if fp == 0:
                return None
            a2 = -fp/t1
            b2 = -fp/t2
            if a2 &lt; 0:
                return None
            if a2 &gt;= b2:
                u = veps[0]
            else:
                a2, b2 = b2, a2
                u = veps[1]
            return Ellipse(a2,b2,s,u)
        if len(s) &gt; 0:
            return None
        if t1 == 0 and t2 == 0:
            return None
        #
        # Paràbola
        #
        if t1 == 0:
            t1, t2 = t2, t1
            veps.reverse()
        veps[0].simplificar()
        veps[1].simplificar()
        b = Base(veps,unitaria=True)
        b.orientacio_positiva()
        es = t1 * veps[0].dot(Vector(x,y)) + veps[0].dot(l)
        vertex = Punt(solve([es,eq],x,y)[0])
        ref = ReferenciaAfi(vertex,b)
        ep = veps[1].dot(l)/veps[1].length()
        p = - ep/t1
        focus = ref.punt_de_coordenades(Punt(0,p/2))
        return Parabola(vertex,focus)
    #
    #
    #
    def __repr__(self):
        &#34;&#34;&#34;
        Retorna l&#39;equació en latex de l&#39;equació de la cònica en la referència
        canònica
        &#34;&#34;&#34;
        x, y = symbols(&#39;x y&#39;)
        m = Matriu.matriu_columna(Vector([x,y,1]))
        r = m.transposada() * self.canonica * m
        r.simplificar()
        return mylatex(r[0,0].expand()) + &#34; = 0&#34;
        #
        #
        #
    def equacio(self):
        &#34;&#34;&#34;
        Retorna l&#39;equació en latex de l&#39;equació de la quàdrica
        &#34;&#34;&#34;
        x, y = symbols(&#39;x y&#39;)
        m = Matriu.matriu_columna(Vector([x,y,1]))
        r = m.transposada() * self.canonica * m
        r.simplificar()
        return r[0,0].expand()
    #
    #
    #
    @classmethod
    def ellipse(cls,maxim=30,canonica=False):
        &#34;&#34;&#34;
        Retorna una el·lipse aleatòria
        Paràmetres:
            maxim: nombre màxim de la matriu projectiva de la cònica
        &#34;&#34;&#34;
        trobat = False
        while not trobat:
            e = Ellipse.aleatoria(canonica=canonica)
            trobat = canonica or e.canonica.norma_maxim() &lt;= maxim
        return e
    #
    #
    #
    @classmethod
    def hiperbola(cls,maxim=30,canonica=False,focus=False):
        &#34;&#34;&#34;
        Retorna una hipèrbola aleatòria
        Paràmetres:
            maxim: nombre màxim de la matriu projectiva de la cònica
        &#34;&#34;&#34;
        trobat = False
        while not trobat:
            h = Hiperbola.aleatoria(canonica=canonica,focus=focus)
            trobat = canonica or h.canonica.norma_maxim() &lt;= maxim
        return h
    #
    #
    #
    @classmethod
    def parabola(cls,maxim=30,canonica=False):
        &#34;&#34;&#34;
        Retorna una paràbola aleatòria
        Paràmetres:
            maxim: nombre màxim de la matriu projectiva de la cònica
        &#34;&#34;&#34;
        trobat = False
        while not trobat:
            p = Parabola.aleatoria(canonica=canonica)
            trobat = canonica or p.canonica.norma_maxim() &lt;= maxim
        return p
    #
    #
    #
    @classmethod
    def aleatoria(cls,maxim=40,canonica=False):
        &#34;&#34;&#34;
        Retorna una el·lipse, hipèrbola o paràbola aleatòries
        Paràmetres:
            maxim: nombre màxim de la matriu projectiva de la cònica
        &#34;&#34;&#34;
        r = random.randint(0,2)
        if r == 0:
            return Conica.ellipse(maxim,canonica=canonica)
        if r == 1:
            return Conica.hiperbola(maxim,canonica=canonica)
        return Conica.parabola(maxim,canonica=canonica)
    #
    #
    #
    def tipus(self):
        &#34;&#34;&#34;
        Retorna el tipus de cònica
        &#34;&#34;&#34;
        if isinstance(self,Ellipse):
            return &#34;El·lipse&#34;
        if isinstance(self,Hiperbola):
            return &#34;Hipèrbola&#34;
        if isinstance(self,Parabola):
            return &#34;Paràbola&#34;
        return &#34;&#34;
    #
    #
    #
    def referencia_principal(self):
        &#34;&#34;&#34;
        Retorna la referencia principal
        &#34;&#34;&#34;
        return self.ref
    #
    #
    #
    def vectors(self,unitaris=False):
        &#34;&#34;&#34;
        Retorna els vectors de la base de la referència principal
        Paràmetres:
            unitaris: si és True, els retorna unitaris
        &#34;&#34;&#34;
        return self.ref.vectors(unitaris)
    #
    #
    #
    def eix_principal(self):
        &#34;&#34;&#34;
        Retorna l&#39;eix principal com a recta afí
        &#34;&#34;&#34;
        return RectaAfi(self.ref.origen,self.ref.base.vecs[0])
    #
    #
    #
    def eix_secundari(self):
        &#34;&#34;&#34;
        Retorna l&#39;eix secundari com a recta afí
        &#34;&#34;&#34;
        return RectaAfi(self.ref.origen,self.ref.base.vecs[1])

class Ellipse(Conica):
    &#34;&#34;&#34;
    Classe per treballar amb el·lipses
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,a2,b2,centre,eix):
        &#34;&#34;&#34;
        Constructor.
        Retorna una el·lipse
        Paràmetres:
            a2: semieix major al quadrat
            b2: semieix menor al quadrat
            centre: centre de l&#39;el·lipse
            eix: direcció de l&#39;eix principal (de les x&#39;)
        &#34;&#34;&#34;
        if not isinstance(centre,Punt):
            return None
        if not isinstance(eix,Vector):
            return None
        if centre.dimensio != 2:
            return None
        if eix.dimensio != 2:
            return None
        if eix.length() == 0:
            return None
        if a2 &lt;= 0:
            return None
        if b2 &lt;= 0:
            return None
        if a2 &lt; b2:
            return None
        return super(Conica,cls).__new__(cls)
    #
    #
    #
    def __init__(self,a2,b2,centre,eix):
        if eix[0] &lt; 0:
            eix = -eix
        s = SubespaiVectorial([eix])
        base = s.amplia_base(unitaria=True)
        r = ReferenciaAfi(centre,base)
        g = gcd(a2,b2)
        t = a2 * b2 // g
        a2 = a2 // g
        b2 = b2 // g
        m = Matriu.diagonal(Vector([b2,a2,-t]))
        Conica.__init__(self,m,r)
    #
    #
    #
    @classmethod
    def aleatoria(cls,canonica=False,):
        &#34;&#34;&#34;
        Retorna una el·lipse aleatòria
        &#34;&#34;&#34;
        if canonica:
            base = [Vector(1,0),Vector(0,1)]
            random.shuffle(base)
            eix = base[0]
        else:
            eix = Vector.aleatori(l=2,maxim=5,nuls=False)
        centre = Punt.aleatori(l=2,maxim=3,nuls=False)
        c = [1,2,3,4,5,6,7,8,9,10]
        trobat = False
        while not trobat:
            a = random.randint(0,len(c) - 1)
            a2 = c[a]
            a = random.randint(0,len(c) - 1)
            b2 = c[a]
            trobat = a2 != b2
        if b2 &gt; a2:
            a2, b2 = b2, a2
        l = eix.length()
        a2 = (a2*l)**2
        b2 = (b2*l)**2
        return cls(a2,b2,centre,eix)
    #
    #
    #
    def centre(self):
        &#34;&#34;&#34;
        Retorna el centre de la el·lipse
        &#34;&#34;&#34;
        return (self.ref.origen)
    #
    #
    #
    def maxim_origen(self):
        &#34;&#34;&#34;
        Retorna el màxim dels valors absoluts de les coordenades del centre
        &#34;&#34;&#34;
        return self.ref.origen.maxim()
    #
    #
    #
    def semieix_major(self):
        &#34;&#34;&#34;
        Retorna el semieix major
        &#34;&#34;&#34;
        l1 = self.matriu[0,0]
        f = - self.matriu[2,2]
        return sqrt(Rational(f,l1))
    #
    #
    #
    def semieix_menor(self):
        &#34;&#34;&#34;
        Retorna el semieix menor
        &#34;&#34;&#34;
        l2 = self.matriu[1,1]
        f = - self.matriu[2,2]
        return sqrt(Rational(f,l2))
    #
    #
    #
    def semidistancia_focal(self):
        &#34;&#34;&#34;
        Retorna la simidistància focal
        &#34;&#34;&#34;
        a2 = self.semieix_major()**2
        b2 = self.semieix_menor()**2
        return sqrt(a2 - b2)
    #
    #
    #
    def focus(self):
        &#34;&#34;&#34;
        Retorna els focus de l&#39;el·lipse
        &#34;&#34;&#34;
        c = self.semidistancia_focal()
        f = [Punt(c,0),Punt(-c,0)]
        return list(map(self.ref.punt_de_coordenades,f))
    #
    #
    #
    def vertexs(self):
        &#34;&#34;&#34;
        Retorna els vèrtex de l&#39;el·lipse
        &#34;&#34;&#34;
        a = self.semieix_major()
        b = self.semieix_menor()
        v = [Punt(a,0),Punt(-a,0),Punt(0,b),Punt(0,-b)]
        return list(map(self.ref.punt_de_coordenades,v))
    #
    #
    #
    def equacio_reduida(self):
        &#34;&#34;&#34;
        Retorna l&#39;equacio reduïda de l&#39;el·lipse en format LaTeX
        &#34;&#34;&#34;
        a2 = self.semieix_major()**2
        b2 = self.semieix_menor()**2
        if a2 == 1:
            return f&#34;x&#39;^2 + \\frac{{y&#39;^2}}{{{b2}}} = 1&#34;
        if b2 == 1:
            return f&#34;\\frac{{x&#39;^2}}{{{a2}}} + y&#39;^2 = 1&#34;
        return f&#34;\\frac{{x&#39;^2}}{{{a2}}} + \\frac{{y&#39;^2}}{{{b2}}} = 1&#34;
    #
    #
    #
    def to_asy(self,scaled=1.0,canonica=10,x=9,y=9):
        &#34;&#34;&#34;
        Retorna una expressió per fer servir amb el programa Asymtote
        Paràmetres:
            scaled: factor d&#39;escalat
            canonica = valors de partida dels eixos de la referència canònica
        &#34;&#34;&#34;
        a2 = self.semieix_major()**2
        b2 = self.semieix_menor()**2
        centre = self.centre()
        vector = self.vectors()[0]
        if vector[0] &lt; 0:
            vector = -vector
        mx, Mx  = -canonica + centre[0],canonica + centre[0]
        my, My  = -canonica + centre[1],canonica + centre[1]
        x = int(self.semieix_major()+3)
        if x &lt; 8:
            x = 8
        y = int(self.semieix_menor()+3)
        if y &lt; 8:
            y = 8
        str = f&#34;Canonica({mx},{Mx},{my},{My},scaled={scaled});&#34;
        clip = f&#34;path cl = ({mx},{my})--({Mx},{my})--({Mx},{My})--({mx},{My})--cycle;\n&#34;
        clip += f&#34;cl = scale({scaled}) * cl;\nclip(cl);&#34;
        return f&#34;{str}\nElipse({centre},{vector},{a2},{b2},x={x},y={y},scaled={scaled},x={x},y={y});\n{clip}&#34;


class Hiperbola(Conica):
    &#34;&#34;&#34;
    Classe per treballar amb hipèrboles
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,a2,b2,centre,eix):
        &#34;&#34;&#34;
        Constructor.
        Retorna una hipèrbola
        Paràmetres:
            a2: semieix real al quadrat
            b2: semieix imaginari al quadrat
            centre: centre de la hipèrbola
            eix: direcció de l&#39;eix principal (de les x&#39;)
        &#34;&#34;&#34;
        if not isinstance(centre,Punt):
            return None
        if not isinstance(eix,Vector):
            return None
        if centre.dimensio != 2:
            return None
        if eix.dimensio != 2:
            return None
        if eix.length() == 0:
            return None
        if a2 &lt;= 0:
            return None
        if b2 &lt;= 0:
            return None
        return super(Conica,cls).__new__(cls)
    #
    #
    #
    def __init__(self,a2,b2,centre,eix):
        if eix[0] &lt; 0:
            eix = -eix
        s = SubespaiVectorial([eix])
        base = s.amplia_base(unitaria=True)
        r = ReferenciaAfi(centre,base)
        g = gcd(a2,b2)
        t = a2 * b2 // g
        a2 = a2 // g
        b2 = b2 // g
        m = Matriu.diagonal(Vector([b2,-a2,-t]))
        Conica.__init__(self,m,r)
    #
    #
    #
    @classmethod
    def aleatoria(cls,canonica=False,focus=False):
        &#34;&#34;&#34;
        Retorna una hipèrbola aleatòria
        Paràmetres:
          canonica: si els eixos principals són paral·lels als de la
             referència canònica
          focus: si els focus han de tenir coordenades enteres
        &#34;&#34;&#34;
        if canonica:
            base = [Vector(1,0),Vector(0,1)]
            random.shuffle(base)
            eix = base[0]
        else:
            eix = Vector.aleatori(l=2,maxim=3,nuls=False)
        centre = Punt.aleatori(l=2,maxim=3,nuls=False)
        values = [1,2,3,4,5,5,7,8,9,10]
        trobat = False
        while not trobat:
            a = random.randint(0,len(values) - 1)
            a2 = values[a]
            if focus:
                c2 = a2 + random.randint(1,3)
                b2 = sqrt(c2 - a2)
            else:
                a = random.randint(0,len(values) - 1)
                b2 = values[a]
            trobat = a2 != b2
        l = eix.length()
        a2 = (a2*l)**2
        if focus:
            c2 = (c2*l)**2
            b2 = c2 - a2
        else:
            b2 = (b2*l)**2
        return cls(a2,b2,centre,eix)
    #
    #
    #
    def centre(self):
        &#34;&#34;&#34;
        Retorna el centre de la el·lipse
        &#34;&#34;&#34;
        return (self.ref.origen)
    #
    #
    #
    def maxim_origen(self):
        &#34;&#34;&#34;
        Retorna el màxim dels valors absoluts de les coordenades del centre
        &#34;&#34;&#34;
        return self.ref.origen.maxim()
    #
    #
    #
    def semieix_real(self):
        &#34;&#34;&#34;
        Retorna el semieix real
        &#34;&#34;&#34;
        l1 = self.matriu[0,0]
        f = - self.matriu[2,2]
        return sqrt(Rational(f,l1))
    #
    #
    #
    def semieix_imaginari(self):
        &#34;&#34;&#34;
        Retorna el semieix imaginari
        &#34;&#34;&#34;
        l2 = - self.matriu[1,1]
        f = - self.matriu[2,2]
        return sqrt(Rational(f,l2))
    #
    #
    #
    def semidistancia_focal(self):
        &#34;&#34;&#34;
        Retorna la simidistància focal
        &#34;&#34;&#34;
        a2 = self.semieix_real()**2
        b2 = self.semieix_imaginari()**2
        return sqrt(a2 + b2)
    #
    #
    #
    def equacio_reduida(self):
        &#34;&#34;&#34;
        Retorna l&#39;equacio reduïda de la hipèrbola en format LaTeX
        &#34;&#34;&#34;
        a2 = self.semieix_real()**2
        b2 = self.semieix_imaginari()**2
        if a2 == 1:
            return f&#34;x&#39;^2 - \\frac{{y&#39;^2}}{{{b2}}} = 1&#34;
        if b2 == 1:
            return f&#34;\\frac{{x&#39;^2}}{{{a2}}} - y&#39;^2 = 1&#34;
        return f&#34;\\frac{{x&#39;^2}}{{{a2}}} - \\frac{{y&#39;^2}}{{{b2}}} = 1&#34;
    #
    #
    #
    def focus(self):
        &#34;&#34;&#34;
        Retorna els focus de la hipèrbola
        &#34;&#34;&#34;
        c = self.semidistancia_focal()
        f = [Punt(c,0),Punt(-c,0)]
        return list(map(self.ref.punt_de_coordenades,f))
    #
    #
    #
    def vertexs(self):
        &#34;&#34;&#34;
        Retorna els vèrtexs de la hipèrbola
        &#34;&#34;&#34;
        a = self.semieix_real()
        v = [Punt(a,0),Punt(-a,0)]
        return list(map(self.ref.punt_de_coordenades,v))
    #
    #
    #
    def vectors_directors_asimptotes(self):
        &#34;&#34;&#34;
        Retorna els vectors directors de les asímptotes expressats en la
        base canònica
        &#34;&#34;&#34;
        l = self.ref.base.vecs[0].length()
        a = l * self.semieix_real()
        b = l * self.semieix_imaginari()
        v1 = self.ref.base.vector_de_components(Vector([a,b]))
        v2 = self.ref.base.vector_de_components(Vector([a,-b]))
        v1.radsimplificar()
        v2.radsimplificar()
        return (v1,v2)
    #
    #
    #
    def equacio_continua_asimptota(self,v):
        &#34;&#34;&#34;
        Retorna l&#39;equació contínua de l&#39;asímptota amb direccio v en format LaTeX
        Paràmetres:
            v: vector director de l&#39;asímptota
        &#34;&#34;&#34;
        x, y = symbols(&#39;x y&#39;)
        centre = self.centre()
        if v[0] == 1:
            str = latex(x - centre[0])
        else:
            str = f&#34;\\frac{{ {latex(x - centre[0])} }}{{ {v[0]} }}&#34;
        str += &#34; = &#34;
        if v[1] == 1:
            str += latex(y - centre[1])
        else:
            str += f&#34;\\frac{{ {latex(y - centre[1])} }}{{ {v[1]} }}&#34;
        return str
    #
    #
    #
    def to_asy(self,scaled=1.0,canonica=10,x=8,y=8):
        &#34;&#34;&#34;
        Retorna una expressió per fer servir amb el programa Asymtote
        Paràmetres:
            scaled: factor d&#39;escalat
            canonica = valors de partida dels eixos de la referència canònica
            x, y: nombres enters. El gràfic es representarà en una quadricula
            de límits (-x,x) i (-y,y)
        &#34;&#34;&#34;
        a2 = self.semieix_real()**2
        b2 = self.semieix_imaginari()**2
        centre = self.centre()
        vector = self.vectors()[0]
        if vector[0] &lt; 0:
            vector = -vector
        mx, Mx  = -canonica + centre[0],canonica + centre[0]
        my, My  = -canonica + centre[1],canonica + centre[1]
        str = f&#34;Canonica({mx},{Mx},{my},{My},scaled={scaled});&#34;
        clip = f&#34;path cl = ({mx},{my})--({Mx},{my})--({Mx},{My})--({mx},{My})--cycle;\n&#34;
        clip += f&#34;cl = scale({scaled}) * cl;\nclip(cl);&#34;
        return f&#34;{str}\nHiperbola({centre},{vector},{a2},{b2},x={x},y={y},scaled={scaled});\n{clip}&#34;


class Parabola(Conica):
    &#34;&#34;&#34;
    Classe per treballar amb paràboles
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,vertex,focus):
        &#34;&#34;&#34;
        Constructor.
        Retorna una paràbola
        Paràmetres:
            vertex: vèrtex
            focus: focus de la paràbola
        &#34;&#34;&#34;
        if not isinstance(vertex,Punt):
            return None
        if not isinstance(focus,Punt):
            return None
        if vertex.dimensio != 2:
            return None
        if focus.dimensio != 2:
            return None
        if vertex == focus:
            return None
        return super(Conica,cls).__new__(cls)
    #
    #
    #
    def __init__(self,vertex,focus):
        eix = focus - vertex
        p = 2 * eix.length()
        s = SubespaiVectorial([eix])
        base = s.amplia_base_suplementari(unitaria=True)
        v1, v2 = base.vecs
        if v1[0] &lt; 0:
            v1 = -v1
        if v2[1] &lt; 0:
            v2 = -v2
        if eix * v2 &lt; 0:
            p = -p
        base.vecs = [v1,v2]
        m = Matriu(Matrix(3,3,[1,0,0,0,0,-p,0,-p,0]))
        r = ReferenciaAfi(vertex,base)
        Conica.__init__(self,m,r)
    #
    #
    #
    @classmethod
    def aleatoria(cls,canonica=False):
        &#34;&#34;&#34;
        Retorna una paràbola aleatòria
        &#34;&#34;&#34;
        trobat = False
        while not trobat:
            if canonica:
                base = [Vector(1,0),Vector(0,1)]
                random.shuffle(base)
                eix = base[0]
                vertex = Punt.aleatori(l=2,maxim=4,nuls=False)
                p = random.randint(-3,3)
                if p == 0:
                    p = 2
                focus = (vertex + p * eix).punt()
                trobat = True
            else:
                vertex = Punt.aleatori(l=2,maxim=5,nuls=False)
                focus = Punt.aleatori(l=2,maxim=5)
                trobat = vertex[0] != focus[0] and vertex[1] != focus[1]
        return cls(vertex,focus)
    #
    #
    #
    def parametre(self):
        &#34;&#34;&#34;
        Retorna el paràmetre de la paràbola
        &#34;&#34;&#34;
        return abs(self.matriu[2,1])
    #
    #
    #
    def vertex(self):
        &#34;&#34;&#34;
        Retorna el vèrtex de la paràbola
        &#34;&#34;&#34;
        return (self.ref.origen)
    #
    #
    #
    def maxim_origen(self):
        &#34;&#34;&#34;
        Retorna el màxim dels valors absoluts de les coordenades del vèrtex
        &#34;&#34;&#34;
        return self.ref.origen.maxim()
    #
    #
    #
    def equacio_reduida(self):
        &#34;&#34;&#34;
        Retorna l&#39;equacio reduïda de la paràbola en format LaTeX
        &#34;&#34;&#34;
        minus = &#34;&#34;
        p = self.parametre()
        eix = self.focus() - self.vertex()
        v2 = self.ref.base.vecs[1]
        if eix * v2 &lt; 0:
            minus = &#34;-&#34;
        if 2 * p == 1:
            return f&#34;y&#39; = {minus}x&#39;^2&#34;
        return f&#34;y&#39; = {minus}\\frac{{x&#39;^2}}{{{ latex(2 * p) }}}&#34;
    #
    #
    #
    def focus(self):
        &#34;&#34;&#34;
        Retorna el focus de la paràbola
        &#34;&#34;&#34;
        p2 = self.parametre() / 2
        if self.matriu[2,1] &gt; 0:
            p2 *= -1
        return self.ref.punt_de_coordenades(Punt([0,p2]))
    #
    #
    #
    def recta_directriu(self):
        &#34;&#34;&#34;
        Retorna la recta directriu com a recta afí
        &#34;&#34;&#34;
        p2 = self.parametre() / 2
        if self.matriu[2,1] &gt; 0:
            p2 *= -1
        p = self.ref.punt_de_coordenades(Punt([0,-p2]))
        return RectaAfi(p,self.ref.base.vecs[0])
    #
    #
    #
    def to_asy(self,scaled=1.0,canonica=10,x=8,y=8):
        &#34;&#34;&#34;
        Retorna una expressió per fer servir amb el programa Asymtote
        Paràmetres:
            scaled: factor d&#39;escalat
            canonica = valors de partida dels eixos de la referència canònica
            x, y: nombres enters. El gràfic es representarà en una quadricula
            de límits (-x,x) i (-y,y)
        &#34;&#34;&#34;
        mx, Mx  = -canonica + self.vertex()[0],canonica + self.vertex()[0]
        my, My  = -canonica + self.vertex()[1],canonica + self.vertex()[1]
        d = 1
        if self.matriu[2,1] &gt; 0:
            d = -1
        str = f&#34;Canonica({mx},{Mx},{my},{My},scaled={scaled});&#34;
        clip = f&#34;path cl = ({mx},{my})--({Mx},{my})--({Mx},{My})--({mx},{My})--cycle;\n&#34;
        clip += f&#34;cl = scale({scaled}) * cl;\nclip(cl);&#34;
        return f&#34;{str}\nParabola({self.vertex()},{self.focus()},d={d},x={x},y={y},scaled={scaled});\n{clip}&#34;


class Quadrica(object):
    &#34;&#34;&#34;
    Classe per treballar amb quàdriques. L&#39;objectiu no és classificar quàdriques,
    sinó generar-les a partir dels elements característics o de manera
    aleatòria.
    Atributs:
        ref: Referència afí
        matriu: matriu projectiva de la quàdrica en la referència &#34;ref&#34;
        canonica: matriu projectiva de la quàdrica en la referència canònica
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,matriu,ref=None):
        &#34;&#34;&#34;
        Retorna una nova quàdrica
        Paràmetres:
            matriu: matriu projectiva de la quàdrica en la referència &#34;ref&#34;
            Ha de ser 4x4
            ref: referència afí. Si és None, serà la referència canònica
        &#34;&#34;&#34;
        if not isinstance(matriu,Matriu):
            return None
        if matriu.files != matriu.columnes:
            return None
        if matriu.files != 4:
            return None
        if not matriu.es_simetrica():
            return None
        if ref is not None:
            if ref.dimensio != 3:
                return None
            if not ref.base.es_unitaria():
                return None
            if not ref.base.es_ortogonal():
                return None
        return super(Quadrica,cls).__new__(cls)
    #
    #
    #
    def __init__(self,matriu,ref=None):
        self.ref = ref
        self.matriu = matriu
        if ref is None:
            self.canonica = matriu
        else:
            a = ref.base.matriu()
            a = a.inserta_columna(3,ref.origen)
            a = a.inserta_fila(3,Vector([0,0,0,1]))
            b = a.inversa()
            self.canonica = b.transposada() * self.matriu * b
        self.canonica.simplificar()
    #
    #
    #
    def __repr__(self):
        &#34;&#34;&#34;
        Retorna l&#39;equació en latex de l&#39;equació de la quàdrica en la referència
        canònica en LaTeX
        &#34;&#34;&#34;
        x, y, z = symbols(&#39;x y z&#39;)
        m = Matriu.matriu_columna(Vector([x,y,z,1]))
        r = m.transposada() * self.canonica * m
        r.simplificar()
        return mylatex(r[0,0].expand()) + &#34; = 0&#34;
    #
    #
    #
    def equacio(self):
        &#34;&#34;&#34;
        Retorna l&#39;equació en latex de l&#39;equació de la quàdrica
        &#34;&#34;&#34;
        x, y, z = symbols(&#39;x y z&#39;)
        m = Matriu.matriu_columna(Vector([x,y,z,1]))
        r = m.transposada() * self.canonica * m
        r.simplificar()
        return r[0,0].expand()
    #
    #
    #
    @classmethod
    def ellipsoide(cls,maxim=30,diagonal=15,canonica=False):
        &#34;&#34;&#34;
        Retorna un el·lipsoide de manera aleatòria
        Paràmetres:
            maxim: valor màxim de la matriu projectiva de la quàdrica
            diagonal: valor màxim de la diagonal de la matriu projectiva de la quàdrica
            canonica: si és True, els eixos principals seran paral·lels
                      als de la referència canònica
        &#34;&#34;&#34;
        trobat = False
        while not trobat:
            e = Ellipsoide.aleatoria(canonica=canonica)
            if canonica:
                trobat = True
            else:
                trobat = e.canonica.norma_maxim() &lt;= maxim and e.canonica.nzeros() &lt; 3 and e.canonica.max_diagonal() &lt; diagonal
        return e
    #
    #
    #
    @classmethod
    def hiperboloideunafulla(cls,maxim=30,diagonal=15,canonica=False):
        &#34;&#34;&#34;
        Retorna un hiperboloide d&#39;una fulla de manera aleatòria
        Paràmetres:
            maxim: valor màxim de la matriu projectiva de la quàdrica
            diagonal: valor màxim de la diagonal de la matriu projectiva de la quàdrica
            canonica: si és True, els eixos principals seran paral·lels
                      als de la referència canònica
        &#34;&#34;&#34;
        trobat = False
        while not trobat:
            h = HiperboloideUnaFulla.aleatoria(canonica=canonica)
            if canonica:
                trobat = True
            else:
                trobat = h.canonica.norma_maxim() &lt;= maxim and h.canonica.nzeros() &lt; 3 and h.canonica.max_diagonal() &lt; diagonal
        return h
    #
    #
    #
    @classmethod
    def hiperboloideduesfulles(cls,maxim=30,diagonal=15,canonica=False):
        &#34;&#34;&#34;
        Retorna un hiperboloide de dues fulles de manera aleatòria
        Paràmetres:
            maxim: valor màxim de la matriu projectiva de la quàdrica
            diagonal: valor màxim de la diagonal de la matriu projectiva de la quàdrica
            canonica: si és True, els eixos principals seran paral·lels
                      als de la referència canònica
        &#34;&#34;&#34;
        trobat = False
        while not trobat:
            h = HiperboloideDuesFulles.aleatoria(canonica=canonica)
            if canonica:
                trobat = True
            else:
                trobat = h.canonica.norma_maxim() &lt;= maxim and h.canonica.nzeros() &lt; 3 and h.canonica.max_diagonal() &lt; diagonal
        return h
    #
    #
    #
    @classmethod
    def con(cls,maxim=30,diagonal=15,canonica=False):
        &#34;&#34;&#34;
        Retorna un con de manera aleatòria
        Paràmetres:
            maxim: valor màxim de la matriu projectiva de la quàdrica
            diagonal: valor màxim de la diagonal de la matriu projectiva de la quàdrica
            canonica: si és True, els eixos principals seran paral·lels
                      als de la referència canònica
        &#34;&#34;&#34;
        trobat = False
        while not trobat:
            c = Con.aleatoria(canonica=canonica)
            if canonica:
                trobat = True
            else:
                trobat = c.canonica.norma_maxim() &lt;= maxim and c.canonica.nzeros() &lt; 3 and c.canonica.max_diagonal() &lt; diagonal
        return c
    #
    #
    #
    @classmethod
    def cilindreelliptic(cls,maxim=30,diagonal=15,canonica=False):
        &#34;&#34;&#34;
        Retorna un cilindre el·líptic de manera aleatòria
        Paràmetres:
            maxim: valor màxim de la matriu projectiva de la quàdrica
            diagonal: valor màxim de la diagonal de la matriu projectiva de la quàdrica
            canonica: si és True, els eixos principals seran paral·lels
                      als de la referència canònica
          &#34;&#34;&#34;
        trobat = False
        while not trobat:
            c = CilindreElliptic.aleatoria(canonica=canonica)
            if canonica:
                trobat = True
            else:
                trobat = c.canonica.norma_maxim() &lt;= maxim and c.canonica.nzeros() &lt; 3 and c.canonica.max_diagonal() &lt; diagonal
        return c
    #
    #
    #
    @classmethod
    def cilindrehiperbolic(cls,maxim=30,diagonal=15,canonica=False):
        &#34;&#34;&#34;
        Retorna un cilindre hiperbòlic de manera aleatòria
        Paràmetres:
            maxim: valor màxim de la matriu projectiva de la quàdrica
            diagonal: valor màxim de la diagonal de la matriu projectiva de la quàdrica
            canonica: si és True, els eixos principals seran paral·lels
                      als de la referència canònica
        &#34;&#34;&#34;
        trobat = False
        while not trobat:
            c = CilindreHiperbolic.aleatoria(canonica=canonica)
            if canonica:
                trobat = True
            else:
                trobat = c.canonica.norma_maxim() &lt;= maxim and c.canonica.nzeros() &lt; 3 and c.canonica.max_diagonal() &lt; diagonal
        return c
    #
    #
    #
    @classmethod
    def paraboloideelliptic(cls,maxim=30,diagonal=15,canonica=False):
        &#34;&#34;&#34;
        Retorna un paraboloide el·líptic de manera aleatòria
        Paràmetres:
            maxim: valor màxim de la matriu projectiva de la quàdrica
            diagonal: valor màxim de la diagonal de la matriu projectiva de la quàdrica
            canonica: si és True, els eixos principals seran paral·lels
                      als de la referència canònica
        &#34;&#34;&#34;
        trobat = False
        while not trobat:
            p = ParaboloideElliptic.aleatoria(canonica=canonica)
            if canonica:
                trobat = True
            else:
                trobat = p.canonica.norma_maxim() &lt;= maxim and p.canonica.nzeros() &lt; 3 and p.canonica.max_diagonal() &lt; diagonal
        return p
    #
    #
    #
    @classmethod
    def paraboloidehiperbolic(cls,maxim=30,diagonal=15,canonica=False):
        &#34;&#34;&#34;
        Retorna un paraboloide hiperbòlic de manera aleatòria
        Paràmetres:
            maxim: valor màxim de la matriu projectiva de la quàdrica
            diagonal: valor màxim de la diagonal de la matriu projectiva de la quàdrica
            canonica: si és True, els eixos principals seran paral·lels
                      als de la referència canònica
        &#34;&#34;&#34;
        trobat = False
        while not trobat:
            p = ParaboloideHiperbolic.aleatoria(canonica=canonica)
            if canonica:
                trobat = True
            else:
                trobat = p.canonica.norma_maxim() &lt;= maxim and p.canonica.nzeros() &lt; 3 and p.canonica.max_diagonal() &lt; diagonal
        return p
    #
    #
    #
    @classmethod
    def cilindreparabolic(cls,maxim=30,diagonal=15,canonica=False):
        &#34;&#34;&#34;
        Retorna un cilindre parabòlic de manera aleatòria
        Paràmetres:
            maxim: valor màxim de la matriu projectiva de la quàdrica
            diagonal: valor màxim de la diagonal de la matriu projectiva de la quàdrica
            canonica: si és True, els eixos principals seran paral·lels
                      als de la referència canònica
        &#34;&#34;&#34;
        trobat = False
        while not trobat:
            c = CilindreParabolic.aleatoria(canonica=canonica)
            if canonica:
                trobat = True
            else:
                trobat = c.canonica.norma_maxim() &lt;= maxim and c.canonica.nzeros() &lt; 3 and c.canonica.max_diagonal() &lt; diagonal
        return c
    #
    #
    #
    @classmethod
    def aleatoria(cls,maxim=30,diagonal=15,canonica=False):
        &#34;&#34;&#34;
        Retorna una quàdrica de manera aleatòria
        Paràmetres:
            maxim: valor màxim de la matriu projectiva de la quàdrica
            diagonal: valor màxim de la diagonal de la matriu projectiva de la quàdrica
        &#34;&#34;&#34;
        r = random.randint(0,9)
        if r == 0:
            return Quadrica.ellipsoide(maxim,diagonal,canonica)
        if r == 1:
            return Quadrica.hiperboloideunafulla(maxim,diagonal,canonica)
        if r == 2:
            return Quadrica.hiperboloideduesfulles(maxim,diagonal,canonica)
        if r == 3:
            return Quadrica.con(maxim,diagonal,canonica)
        if r == 4:
            return Quadrica.cilindreelliptic(maxim,diagonal,canonica)
        if r == 5:
            return Quadrica.cilindrehiperbolic(maxim,diagonal,canonica)
        if r == 6:
            return Quadrica.paraboloideelliptic(maxim,diagonal,canonica)
        if r == 7:
            return Quadrica.paraboloidehiperbolic(maxim,diagonal,canonica)
        return Quadrica.cilindreparabolic(maxim,diagonal,canonica)
    #
    #
    #
    def tipus(self):
        &#34;&#34;&#34;
        Retorna el tipus de quàdrica
        &#34;&#34;&#34;
        if isinstance(self,Ellipsoide):
            return &#34;El·lipsoide&#34;
        if isinstance(self,HiperboloideUnaFulla):
            return &#34;Hiperboloide d&#39;una fulla&#34;
        if isinstance(self,HiperboloideDuesFulles):
            return &#34;Hiperboloide de dues fulles&#34;
        if isinstance(self,Con):
            return &#34;Con real&#34;
        if isinstance(self,CilindreElliptic):
            return &#34;Cilindre el·líptic&#34;
        if isinstance(self,CilindreHiperbolic):
            return &#34;Cilindre hiperbòlic&#34;
        if isinstance(self,ParaboloideElliptic):
            return &#34;Paraboloide el·líptic&#34;
        if isinstance(self,ParaboloideHiperbolic):
            return &#34;Paraboloide hiperbòlic&#34;
        if isinstance(self,CilindreParabolic):
            return &#34;Cilindre parabòlic&#34;
        return &#34;&#34;
    #
    #
    #
    def referencia_principal(self):
        &#34;&#34;&#34;
        Retorna la referencia principal
        &#34;&#34;&#34;
        return self.ref
    #
    #
    #
    def vectors(self,unitaris=False):
        &#34;&#34;&#34;
        Retorna els vectors de la base de la referència principal
        Paràmetres:
            unitaris: si és True, els retorna unitaris
        &#34;&#34;&#34;
        return self.ref.vectors(unitaris)
    #
    #
    #
    @classmethod
    def from_equacio(cls,eq):
        &#34;&#34;&#34;
        Retorna i classifica la quadrica a partir de la seva equació.
        Només per als nou tipus de quàdriques definides en aquesta llibreria
        &#34;&#34;&#34;
        x, y, z = symbols(&#39;x y z&#39;)
        unknowns = [x,y,z]
        #
        # Termes quadràtics
        #
        a = diff(eq,x,2) / 2
        b = diff(eq,x,y) / 2
        d = diff(eq,x,z) / 2
        c = diff(eq,y,2) / 2
        e = diff(eq,y,z) / 2
        f = diff(eq,z,2) / 2
        #
        # Termes lineals
        #
        l1 = (diff(eq,x).subs({x:1,y:0,z:0}) - 2 * a) / 2
        l2 = (diff(eq,y).subs({x:0,y:1,z:0}) - 2 * c) / 2
        l3 = (diff(eq,z).subs({x:0,y:0,z:1}) - 2 * f) / 2
        #
        # Terme independent
        #
        ti = eq.subs({x:0,y:0,z:0})
        #
        # Matrius
        #
        Q = Matrix([[a,b,d],[b,c,e],[d,e,f]])
        L = Matrix(3,1,[l1,l2,l3])
        l = Vector(l1,l2,l3)
        #
        # Preparatius
        #
        vs = Q.eigenvects()
        vaps, veps = vaps_veps_amb_signe(vs,1)
        positius = list(zip(vaps,veps))
        vaps, veps = vaps_veps_amb_signe(vs,-1)
        negatius = list(zip(vaps,veps))
        positius.sort(key=lambda item: abs(item[0]))
        negatius.sort(key=lambda item: abs(item[0]))
        s = list(linsolve((Q,-L),*unknowns))
        #
        # Classificació
        #
        if len(positius) == 3 or len(negatius) == 3:
            #
            # Ellipsoide
            #
            s = Punt(list(s[0]))
            tip = eq.subs({x:s[0],y:s[1],z:s[2]})
            if tip == 0:
                return None
            if len(positius) == 3 and tip &gt; 0:
                return None
            if len(negatius) == 3 and tip &lt; 0:
                return None
            v = positius
            if len(v) == 0:
                v = negatius
            a2 = -tip / v[0][0]
            b2 = -tip / v[1][0]
            c2 = -tip / v[2][0]
            return Ellipsoide(a2,b2,c2,s,v[0][1],v[1][1])
        if len(positius) + len(negatius) == 3:
            #
            # Rang 3
            #
            s = Punt(list(s[0]))
            tip = eq.subs({x:s[0],y:s[1],z:s[2]})
            v1 = positius
            v2 = negatius
            signe = 1
            if len(v2) == 2:
                v1, v2 = v2, v1
                signe = -1
            a2 = signe * v1[0][0]
            b2 = signe * v1[1][0]
            c2 = signe * v2[0][0]
            tip *= signe
            if tip == 0:
                #
                # Con
                #
                if a2.is_integer and b2.is_integer and c2.is_integer:
                    g = mcm_llista([a2,b2,c2])
                else:
                    g = a2 * b2 * c2
                a2 = g / a2
                b2 = g / b2
                c2 = g / c2
                return Con(a2,b2,-c2,s,v1[0][1],v1[1][1])
            elif tip &gt; 0:
                #
                # Hiperboloide de dues fulles
                #
                a2 = tip / a2
                b2 = tip / b2
                c2 = tip / c2
                return HiperboloideDuesFulles(a2,b2,-c2,s,v1[0][1],v1[1][1])
            elif tip &lt; 0:
                #
                # Hiperboloide d&#39;una fulla
                #
                a2 = - tip / a2
                b2 = - tip / b2
                c2 = - tip / c2
                return HiperboloideUnaFulla(a2,b2,-c2,s,v1[0][1],v1[1][1])
        if len(positius) + len(negatius) == 2:
            #
            # Rang 2
            #
            if len(s) &gt; 0:
                s = Punt(list(s[0].subs({x:0,y:0,z:0})))
                tip = eq.subs({x:s[0],y:s[1],z:s[2]})
                if len(positius) == 2 or len(negatius) == 2:
                    #
                    # Clindre e·líptic
                    #
                    if tip == 0:
                        return None
                    if len(positius) == 2 and tip &gt; 0:
                        return None
                    if len(negatius) == 2 and tip &lt; 0:
                        return None
                    v = positius
                    if len(v) == 0:
                        v = negatius
                    a2 = -tip / v[0][0]
                    b2 = -tip / v[1][0]
                    return CilindreElliptic(a2,b2,s,v[0][1],v[1][1])
                if len(positius) == 1:
                    #
                    # Clindre hiperbòlic
                    #
                    if tip == 0:
                        return None
                    v1 = positius
                    v2 = negatius
                    a2 = -tip / positius[0][0]
                    b2 = -tip / negatius[0][0]
                    if a2 &lt; 0:
                        a2, b2 = b2, a2
                        v1, v2 = v2, v1
                    return CilindreHiperbolic(a2,-b2,s,v1[0][1],v2[0][1])
            if len(positius) == 2 or len(negatius) == 2:
                #
                # Paraboloide el·líptic
                #
                v = positius
                if len(v) == 0:
                    v = negatius
                v1, v2 = v[0][1],v[1][1]
                v1.simplificar()
                v2.simplificar()
                v3 = v1.cross(v2,simplificar=True)
                ep = v3.dot(l)/v3.length()
                t1, t2 = v[0][0],v[1][0]
                es1 = t1 * v1.dot(Vector(x,y,z)) + v1.dot(l)
                es2 = t2 * v2.dot(Vector(x,y,z)) + v2.dot(l)
                vertex = Punt(solve([es1,es2,eq],x,y,z)[0])
                a2 =  -2 * ep / t1
                b2 =  -2 * ep / t2
                if a2 &lt; 0:
                    a2, b2 = -a2,-b2
                    v2 = -v2
                a2 /= v3.length()
                b2 /= v3.length()
                return ParaboloideElliptic(a2,b2,vertex,v1,v2)
            if len(positius) == 1:
                #
                # Paraboloide hiperbòlic
                #
                v1 = positius
                v2 = negatius
                vec1, vec2 = v1[0][1],v2[0][1]
                vec1.simplificar()
                vec2.simplificar()
                vec3 = vec1.cross(vec2,simplificar=True)
                ep = vec3.dot(l)/vec3.length()
                t1, t2 = v1[0][0],v2[0][0]
                es1 = t1 * vec1.dot(Vector(x,y,z)) + vec1.dot(l)
                es2 = t2 * vec2.dot(Vector(x,y,z)) + vec2.dot(l)
                vertex = Punt(solve([es1,es2,eq],x,y,z)[0])
                a2 =  -2 * ep / t1
                b2 =  -2 * ep / t2
                if a2 &lt; 0:
                    a2, b2 = b2, a2
                    vec1, vec2 = vec2, vec1
                    vec3 *= -1
                a2 /= vec3.length()
                b2 /= vec3.length()
                return ParaboloideHiperbolic(a2,-b2,vertex,vec1,vec2)
        if len(positius) + len(negatius) == 1:
            #
            # Cilindre parabòlic
            #
            if len(s) &gt; 0:
                return None
            v = positius
            if len(v) == 0:
                v = negatius
            t1 = v[0][0]
            v1 = v[0][1]
            v2 = v1.cross(l,simplificar=True)
            v3 = v1.cross(v2,simplificar=True)
            es = t1 * v1.dot(Vector(x,y,z)) + v1.dot(l)
            vertex = solve([es,eq],x,y,z)[0]
            k = 0
            while True:
                v = Punt([item.subs({x:k,y:k,z:k}) for item in vertex])
                f = v.factor_comu()
                if f[0].q == 1:
                    break
                v = Punt([item.subs({x:-k,y:-k,z:-k}) for item in vertex])
                f = v.factor_comu()
                if f[0].q == 1:
                    break
                k += 1
            ep = v3.dot(l)/v3.length()
            a2 =  -2 * ep / t1
            return CilindreParabolic(a2/2,v,v1,v2)


class Ellipsoide(Quadrica):
    &#34;&#34;&#34;
    Classe per treballar amb el·lipsoides
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,a2,b2,c2,centre,eix1,eix2):
        &#34;&#34;&#34;
        Constructor.
        Paràmetres:
           a2, b2, c2: semieixos al quadrat
           eix1: direcció de l&#39;eix principal (de les x&#39;)
           eix2: en pricipi és la direcció de l&#39;eix de les y&#39;, però si no és
                 perpendicular a eix1, es calcula el perpendicular que està
                 en el mateix pla vectorial que &lt;eix1,eix2&gt; aplicant el
                 mètode de Gram-Schmidt
        &#34;&#34;&#34;
        if not isinstance(centre,Punt):
            return None
        if not isinstance(eix1,Vector):
            return None
        if not isinstance(eix2,Vector):
            return None
        if centre.dimensio != 3:
            return None
        if eix1.dimensio != 3:
            return None
        if eix2.dimensio != 3:
            return None
        if eix1.length() == 0:
            return None
        if eix2.length() == 0:
            return None
        m = Matriu.from_vectors_columna([eix1,eix2])
        if m.rank() != 2:
            return None
        if a2 &lt;= 0:
            return None
        if b2 &lt;= 0:
            return None
        if c2 &lt;= 0:
            return None
        return super(Quadrica,cls).__new__(cls)
    #
    #
    #
    def __init__(self,a2,b2,c2,centre,eix1,eix2):
        s = SubespaiVectorial([eix1,eix2])
        base = s.amplia_base(unitaria=True)
        r = ReferenciaAfi(centre,base)
        g = mcm_llista([a2,b2,c2])
        t = g
        a2 = g // a2
        b2 = g // b2
        c2 = g // c2
        m = Matriu.diagonal(Vector([a2,b2,c2,-g]))
        Quadrica.__init__(self,m,r)
    #
    #
    #
    @classmethod
    def aleatoria(cls,canonica=False):
        &#34;&#34;&#34;
        Retorna un el·lipsoide de manera aleatòria aleatòria
        &#34;&#34;&#34;
        if canonica:
            v = [Vector(1,0,0),Vector(0,1,0),Vector(0,0,1)]
            random.shuffle(v)
            eix1, eix2, _ = v
        else:
            trobat = False
            while not trobat:
                eix1 = Vector.aleatori(l=3,maxim=3)
                eix2 = Vector.aleatori(l=3,maxim=3)
                if eix1.nzeros() &gt; 1 or eix2.nzeros() &gt; 1:
                    continue
                trobat = Matriu.from_vectors_columna([eix1,eix2]).rank() == 2
        trobat = False
        while not trobat:
            centre = Punt.aleatori(l=3,maxim=4,nuls=False)
            trobat = centre.length() &gt; 0
        c = [1,2,3,4,5,8,10,12,16,18,20,25,36]
        trobat = False
        while not trobat:
            a = random.randint(0,len(c) - 1)
            a2 = c[a]
            a = random.randint(0,len(c) - 1)
            b2 = c[a]
            a = random.randint(0,len(c) - 1)
            c2 = c[a]
            trobat = a2 != b2 or a2 != c2
        a2, b2, c2 = sorted([a2,b2,c2])[::-1]
        return cls(a2,b2,c2,centre,eix1,eix2)
    #
    #
    #
    def centre(self):
        &#34;&#34;&#34;
        Retorna el centre de l&#39;el·lipsoide
        &#34;&#34;&#34;
        return (self.ref.origen)
    #
    #
    #
    def semieixos(self):
        &#34;&#34;&#34;
        Retorna els semieixos de l&#39;el·lipsoide
        &#34;&#34;&#34;
        a = self.matriu[0,0]
        b = self.matriu[1,1]
        c = self.matriu[2,2]
        f = - self.matriu[3,3]
        return (sqrt(Rational(f,a)),sqrt(Rational(f,b)),sqrt(Rational(f,c)))
    #
    #
    #
    def semieixos_quadrats(self):
        &#34;&#34;&#34;
        Retorna els semieixos al quadrat de l&#39;el·lipsoide
        &#34;&#34;&#34;
        a = self.matriu[0,0]
        b = self.matriu[1,1]
        c = self.matriu[2,2]
        f = - self.matriu[3,3]
        return (Rational(f,a),Rational(f,b),Rational(f,c))
    #
    #
    #
    def equacio_reduida(self):
        &#34;&#34;&#34;
        Retorna l&#39;equacio reduïda de l&#39;el·lipsoide
        &#34;&#34;&#34;
        a2, b2, c2 = self.semieixos_quadrats()
        if a2 == 1:
            str = &#34;x&#39;^2&#34;
        else:
            str = f&#34;\\frac{{x&#39;^2}}{{ {latex(a2)} }}&#34;
        if b2 == 1:
            str += &#34; + y&#39;^2&#34;
        else:
            str += f&#34; + \\frac{{y&#39;^2}}{{ {latex(b2)} }}&#34;
        if c2 == 1:
            str += &#34; + z&#39;^2 = 1&#34;
        else:
            str += f&#34; + \\frac{{z&#39;^2}}{{ {latex(c2)} }} = 1&#34;
        return str


class HiperboloideUnaFulla(Quadrica):
    &#34;&#34;&#34;
    Classe per treballar amb hiperboloides d&#39;una fulla
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,a2,b2,c2,centre,eix1,eix2):
        &#34;&#34;&#34;
        Constructor.
        Paràmetres:
           a2, b2, c2: semieixos al quadrat
           eix1: direcció de l&#39;eix principal (de les x&#39;)
           eix2: en pricipi és la direcció de l&#39;eix de les y&#39;, però si no és
                 perpendicular a eix1, es calcula el perpendicular que està
                 en el mateix pla vectorial que &lt;eix1,eix2&gt; aplicant el
                 mètode de Gram-Schmidt
        &#34;&#34;&#34;
        if not isinstance(centre,Punt):
            return None
        if not isinstance(eix1,Vector):
            return None
        if not isinstance(eix2,Vector):
            return None
        if centre.dimensio != 3:
            return None
        if eix1.dimensio != 3:
            return None
        if eix2.dimensio != 3:
            return None
        if eix1.length() == 0:
            return None
        if eix2.length() == 0:
            return None
        m = Matriu.from_vectors_columna([eix1,eix2])
        if m.rank() != 2:
            return None
        if a2 &lt;= 0:
            return None
        if b2 &lt;= 0:
            return None
        if c2 &lt;= 0:
            return None
        return super(Quadrica,cls).__new__(cls)
    #
    #
    #
    def __init__(self,a2,b2,c2,centre,eix1,eix2):
        s = SubespaiVectorial([eix1,eix2])
        base = s.amplia_base(unitaria=True)
        r = ReferenciaAfi(centre,base)
        g = mcm_llista([a2,b2,c2])
        t = g
        a2 = g // a2
        b2 = g // b2
        c2 = g // c2
        m = Matriu.diagonal(Vector([a2,b2,-c2,-g]))
        Quadrica.__init__(self,m,r)
    #
    #
    #
    @classmethod
    def aleatoria(cls,canonica=False):
        &#34;&#34;&#34;
        Retorna un hiperboloide d&#39;una fulla de manera aleatòria
        &#34;&#34;&#34;
        if canonica:
            v = [Vector(1,0,0),Vector(0,1,0),Vector(0,0,1)]
            random.shuffle(v)
            eix1, eix2, _ = v
        else:
            trobat = False
            while not trobat:
                eix1 = Vector.aleatori(l=3,maxim=3)
                eix2 = Vector.aleatori(l=3,maxim=3)
                if eix1.nzeros() &gt; 1 or eix2.nzeros() &gt; 1:
                    continue
                trobat = Matriu.from_vectors_columna([eix1,eix2]).rank() == 2
        trobat = False
        while not trobat:
            centre = Punt.aleatori(l=3,maxim=4,nuls=False)
            trobat = centre.length() &gt; 0
        c = [1,2,3,4,5,8,10,12,16,18,20,25,36]
        trobat = False
        while not trobat:
            a = random.randint(0,len(c) - 1)
            a2 = c[a]
            a = random.randint(0,len(c) - 1)
            b2 = c[a]
            a = random.randint(0,len(c) - 1)
            c2 = c[a]
            trobat = a2 != b2 or a2 != c2
        a2, b2 = sorted([a2,b2])[::-1]
        return cls(a2,b2,c2,centre,eix1,eix2)
    #
    #
    #
    def centre(self):
        &#34;&#34;&#34;
        Retorna el centre de l&#39;el·lipsoide
        &#34;&#34;&#34;
        return (self.ref.origen)
    #
    #
    #
    def semieixos(self):
        &#34;&#34;&#34;
        Retorna els semieixos de l&#39;el·lipsoide
        &#34;&#34;&#34;
        a = self.matriu[0,0]
        b = self.matriu[1,1]
        c = - self.matriu[2,2]
        f = - self.matriu[3,3]
        return (sqrt(Rational(f,a)),sqrt(Rational(f,b)),sqrt(Rational(f,c)))
    #
    #
    #
    def semieixos_quadrats(self):
        &#34;&#34;&#34;
        Retorna els semieixos al quadrat de l&#39;el·lipsoide
        &#34;&#34;&#34;
        a = self.matriu[0,0]
        b = self.matriu[1,1]
        c = - self.matriu[2,2]
        f = - self.matriu[3,3]
        return (Rational(f,a),Rational(f,b),Rational(f,c))
    #
    #
    #
    def equacio_reduida(self):
        &#34;&#34;&#34;
        Retorna l&#39;equacio reduïda de l&#39;hiperboloide d&#39;una fulla
        &#34;&#34;&#34;
        a2, b2, c2 = self.semieixos_quadrats()
        if a2 == 1:
            str = &#34;x&#39;^2&#34;
        else:
            str = f&#34;\\frac{{x&#39;^2}}{{ {latex(a2)} }}&#34;
        if b2 == 1:
            str += &#34; + y&#39;^2&#34;
        else:
            str += f&#34; + \\frac{{y&#39;^2}}{{ {latex(b2)} }}&#34;
        if c2 == 1:
            str += &#34; - z&#39;^2 = 1&#34;
        else:
            str += f&#34; - \\frac{{z&#39;^2}}{{ {latex(c2)} }} = 1&#34;
        return str


class HiperboloideDuesFulles(Quadrica):
    &#34;&#34;&#34;
    Classe per treballar amb hiperboloides de dues fulles
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,a2,b2,c2,centre,eix1,eix2):
        &#34;&#34;&#34;
        Constructor.
        Paràmetres:
           a2, b2, c2: semieixos al quadrat
           eix1: direcció de l&#39;eix principal (de les x&#39;)
           eix2: en pricipi és la direcció de l&#39;eix de les y&#39;, però si no és
                 perpendicular a eix1, es calcula el perpendicular que està
                 en el mateix pla vectorial que &lt;eix1,eix2&gt; aplicant el
                 mètode de Gram-Schmidt
        &#34;&#34;&#34;
        if not isinstance(centre,Punt):
            return None
        if not isinstance(eix1,Vector):
            return None
        if not isinstance(eix2,Vector):
            return None
        if centre.dimensio != 3:
            return None
        if eix1.dimensio != 3:
            return None
        if eix2.dimensio != 3:
            return None
        if eix1.length() == 0:
            return None
        if eix2.length() == 0:
            return None
        m = Matriu.from_vectors_columna([eix1,eix2])
        if m.rank() != 2:
            return None
        if a2 &lt;= 0:
            return None
        if b2 &lt;= 0:
            return None
        if c2 &lt;= 0:
            return None
        return super(Quadrica,cls).__new__(cls)
    #
    #
    #
    def __init__(self,a2,b2,c2,centre,eix1,eix2):
        s = SubespaiVectorial([eix1,eix2])
        base = s.amplia_base(unitaria=True)
        r = ReferenciaAfi(centre,base)
        g = mcm_llista([a2,b2,c2])
        t = g
        a2 = g // a2
        b2 = g // b2
        c2 = g // c2
        m = Matriu.diagonal(Vector([a2,b2,-c2,g]))
        Quadrica.__init__(self,m,r)
    #
    #
    #
    @classmethod
    def aleatoria(cls,canonica=False):
        &#34;&#34;&#34;
        Retorna un hiperboloide de dues fulles de manera aleatòria aleatòria
        &#34;&#34;&#34;
        if canonica:
            v = [Vector(1,0,0),Vector(0,1,0),Vector(0,0,1)]
            random.shuffle(v)
            eix1, eix2, _ = v
        else:
            trobat = False
            while not trobat:
                eix1 = Vector.aleatori(l=3,maxim=3)
                eix2 = Vector.aleatori(l=3,maxim=3)
                if eix1.nzeros() &gt; 1 or eix2.nzeros() &gt; 1:
                    continue
                trobat = Matriu.from_vectors_columna([eix1,eix2]).rank() == 2
        trobat = False
        while not trobat:
            centre = Punt.aleatori(l=3,maxim=4,nuls=False)
            trobat = centre.length() &gt; 0
        c = [1,2,3,4,5,8,10,12,16,18,20,25,36]
        trobat = False
        while not trobat:
            a = random.randint(0,len(c) - 1)
            a2 = c[a]
            a = random.randint(0,len(c) - 1)
            b2 = c[a]
            a = random.randint(0,len(c) - 1)
            c2 = c[a]
            trobat = a2 != b2 or a2 != c2
        a2, b2 = sorted([a2,b2])[::-1]
        return cls(a2,b2,c2,centre,eix1,eix2)
    #
    #
    #
    def centre(self):
        &#34;&#34;&#34;
        Retorna el centre de l&#39;hiperboloide de dues fulles
        &#34;&#34;&#34;
        return (self.ref.origen)
    #
    #
    #
    def semieixos(self):
        &#34;&#34;&#34;
        Retorna els semieixos de l&#39;hiperboloide de dues fulles
        &#34;&#34;&#34;
        a = self.matriu[0,0]
        b = self.matriu[1,1]
        c = - self.matriu[2,2]
        f = self.matriu[3,3]
        return (sqrt(Rational(f,a)),sqrt(Rational(f,b)),sqrt(Rational(f,c)))
    #
    #
    #
    def semieixos_quadrats(self):
        &#34;&#34;&#34;
        Retorna els semieixos al quadrat de l&#39;hiperboloide de dues fulles
        &#34;&#34;&#34;
        a = self.matriu[0,0]
        b = self.matriu[1,1]
        c = - self.matriu[2,2]
        f = self.matriu[3,3]
        return (Rational(f,a),Rational(f,b),Rational(f,c))
    #
    #
    #
    def equacio_reduida(self):
        &#34;&#34;&#34;
        Retorna l&#39;equacio reduïda de l&#39;hiperboloide de dues fulles
        &#34;&#34;&#34;

        a2, b2, c2 = self.semieixos_quadrats()
        if a2 == 1:
            str = &#34;x&#39;^2&#34;
        else:
            str = f&#34;\\frac{{x&#39;^2}}{{ {latex(a2)} }}&#34;
        if b2 == 1:
            str += &#34; + y&#39;^2&#34;
        else:
            str += f&#34; + \\frac{{y&#39;^2}}{{ {latex(b2)} }}&#34;
        if c2 == 1:
            str += &#34; - z&#39;^2 = -1&#34;
        else:
            str += f&#34; - \\frac{{z&#39;^2}}{{ {latex(c2)} }} = -1&#34;
        return str


class Con(Quadrica):
    &#34;&#34;&#34;
    Classe per treballar amb cons
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,a2,b2,c2,centre,eix1,eix2):
        &#34;&#34;&#34;
        Constructor.
        Retorna un Con
        Paràmetres:
           a2, b2, c2: semieixos al quadrat
           eix1: direcció de l&#39;eix principal (de les x&#39;)
           eix2: en pricipi és la direcció de l&#39;eix de les y&#39;, però si no és
                 perpendicular a eix1, es calcula el perpendicular que està
                 en el mateix pla vectorial que &lt;eix1,eix2&gt; aplicant el
                 mètode de Gram-Schmidt
        &#34;&#34;&#34;
        if not isinstance(centre,Punt):
            return None
        if not isinstance(eix1,Vector):
            return None
        if not isinstance(eix2,Vector):
            return None
        if centre.dimensio != 3:
            return None
        if eix1.dimensio != 3:
            return None
        if eix2.dimensio != 3:
            return None
        if eix1.length() == 0:
            return None
        if eix2.length() == 0:
            return None
        m = Matriu.from_vectors_columna([eix1,eix2])
        if m.rank() != 2:
            return None
        if a2 &lt;= 0:
            return None
        if b2 &lt;= 0:
            return None
        if c2 &lt;= 0:
            return None
        return super(Quadrica,cls).__new__(cls)
    #
    #
    #
    def __init__(self,a2,b2,c2,centre,eix1,eix2):
        s = SubespaiVectorial([eix1,eix2])
        base = s.amplia_base(unitaria=True)
        r = ReferenciaAfi(centre,base)
        g = mcm_llista([a2,b2,c2])
        a2 = g // a2
        b2 = g // b2
        c2 = g // c2
        m = Matriu.diagonal(Vector([a2,b2,-c2,0]))
        Quadrica.__init__(self,m,r)
    #
    #
    #
    @classmethod
    def aleatoria(cls,canonica=False):
        &#34;&#34;&#34;
        Retorna un hiperboloide de dues fulles de manera aleatòria aleatòria
        &#34;&#34;&#34;
        if canonica:
            v = [Vector(1,0,0),Vector(0,1,0),Vector(0,0,1)]
            random.shuffle(v)
            eix1, eix2, _ = v
        else:
            trobat = False
            while not trobat:
                eix1 = Vector.aleatori(l=3,maxim=3)
                eix2 = Vector.aleatori(l=3,maxim=3)
                if eix1.nzeros() &gt; 1 or eix2.nzeros() &gt; 1:
                    continue
                trobat = Matriu.from_vectors_columna([eix1,eix2]).rank() == 2
        trobat = False
        while not trobat:
            centre = Punt.aleatori(l=3,maxim=4,nuls=False)
            trobat = centre.length() &gt; 0
        c = [1,2,3,4,5,8,10,12,16,18,20,25,36]
        trobat = False
        while not trobat:
            a = random.randint(0,len(c) - 1)
            a2 = c[a]
            a = random.randint(0,len(c) - 1)
            b2 = c[a]
            a = random.randint(0,len(c) - 1)
            c2 = c[a]
            trobat = a2 != b2 or a2 != c2
        a2, b2 = sorted([a2,b2])[::-1]
        return cls(a2,b2,c2,centre,eix1,eix2)
    #
    #
    #
    def centre(self):
        &#34;&#34;&#34;
        Retorna el centre o vèrtex del con
        &#34;&#34;&#34;
        return (self.ref.origen)
    #
    #
    #
    def semieixos(self):
        &#34;&#34;&#34;
        Retorna els semieixos del con
        &#34;&#34;&#34;
        a = self.matriu[0,0]
        b = self.matriu[1,1]
        c = - self.matriu[2,2]
        m = mcm_llista([a,b,c])
        return (sqrt(Rational(m,a)),sqrt(Rational(m,b)),sqrt(Rational(m,c)))
    #
    #
    #
    def semieixos_quadrats(self):
        &#34;&#34;&#34;
        Retorna els semieixos al quadrat del con
        &#34;&#34;&#34;
        a = self.matriu[0,0]
        b = self.matriu[1,1]
        c = - self.matriu[2,2]
        m = mcm_llista([a,b,c])
        return (Rational(m,a),Rational(m,b),Rational(m,c))
    #
    #
    #
    def equacio_reduida(self):
        &#34;&#34;&#34;
        Retorna l&#39;equacio reduïda del con
        &#34;&#34;&#34;
        a2, b2, c2 = self.semieixos_quadrats()
        if a2 == 1:
            str = &#34;x&#39;^2&#34;
        else:
            str = f&#34;\\frac{{x&#39;^2}}{{ {latex(a2)} }}&#34;
        if b2 == 1:
            str += &#34; + y&#39;^2&#34;
        else:
            str += f&#34; + \\frac{{y&#39;^2}}{{ {latex(b2)} }}&#34;
        if c2 == 1:
            str += &#34; - z&#39;^2 = 0&#34;
        else:
            str += f&#34; - \\frac{{z&#39;^2}}{{ {latex(c2)} }} = 0&#34;
        return str


class CilindreElliptic(Quadrica):
    &#34;&#34;&#34;
    Classe per treballar amb cilindres el·líptics
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,a2,b2,centre,eix1,eix2):
        &#34;&#34;&#34;
        Constructor.
        Paràmetres:
           a2, b2: semieixos al quadrat
           eix1: direcció de l&#39;eix principal (de les x&#39;)
           eix2: en pricipi és la direcció de l&#39;eix de les y&#39;, però si no és
                 perpendicular a eix1, es calcula el perpendicular que està
                 en el mateix pla vectorial que &lt;eix1,eix2&gt; aplicant el
                 mètode de Gram-Schmidt
        &#34;&#34;&#34;
        if not isinstance(centre,Punt):
            return None
        if not isinstance(eix1,Vector):
            return None
        if not isinstance(eix2,Vector):
            return None
        if centre.dimensio != 3:
            return None
        if eix1.dimensio != 3:
            return None
        if eix2.dimensio != 3:
            return None
        if eix1.length() == 0:
            return None
        if eix2.length() == 0:
            return None
        m = Matriu.from_vectors_columna([eix1,eix2])
        if m.rank() != 2:
            return None
        if a2 &lt;= 0:
            return None
        if b2 &lt;= 0:
            return None
        return super(Quadrica,cls).__new__(cls)
    #
    #
    #
    def __init__(self,a2,b2,centre,eix1,eix2):
        s = SubespaiVectorial([eix1,eix2])
        base = s.amplia_base(unitaria=True)
        r = ReferenciaAfi(centre,base)
        g = mcd_llista([a2,b2])
        t = a2 * b2 // g
        a2 = a2 // g
        b2 = b2 // g
        m = Matriu.diagonal(Vector([b2,a2,0,-t]))
        Quadrica.__init__(self,m,r)
    #
    #
    #
    @classmethod
    def aleatoria(cls,canonica=False):
        &#34;&#34;&#34;
        Retorna un cilindre el·líptic de manera aleatòria
        &#34;&#34;&#34;
        if canonica:
            v = [Vector(1,0,0),Vector(0,1,0),Vector(0,0,1)]
            random.shuffle(v)
            eix1, eix2, _ = v
        else:
            trobat = False
            while not trobat:
                eix1 = Vector.aleatori(l=3,maxim=3)
                eix2 = Vector.aleatori(l=3,maxim=3)
                if eix1.nzeros() &gt; 1 or eix2.nzeros() &gt; 1:
                    continue
                trobat = Matriu.from_vectors_columna([eix1,eix2]).rank() == 2
        trobat = False
        while not trobat:
            centre = Punt.aleatori(l=3,maxim=4,nuls=False)
            trobat = centre.length() &gt; 0
        c = [1,2,3,4,5,8,10,12,16,18,20,25,36]
        trobat = False
        while not trobat:
            a = random.randint(0,len(c) - 1)
            a2 = c[a]
            a = random.randint(0,len(c) - 1)
            b2 = c[a]
            trobat = a2 != b2
        a2, b2 = sorted([a2,b2])[::-1]
        return cls(a2,b2,centre,eix1,eix2)
    #
    #
    #
    def centre(self):
        &#34;&#34;&#34;
        Retorna un centre del cilindre el·líptic
        &#34;&#34;&#34;
        return (self.ref.origen)
    #
    #
    #
    def centres(self):
        &#34;&#34;&#34;
        Retorna la recta de centres
        &#34;&#34;&#34;
        return RectaAfi(self.ref.origen,self.ref.base[2])
    #
    #
    #
    def semieixos(self):
        &#34;&#34;&#34;
        Retorna els semieixos del cilindre el·líptic
        &#34;&#34;&#34;
        a = self.matriu[0,0]
        b = self.matriu[1,1]
        f = - self.matriu[3,3]
        return (sqrt(Rational(f,a)),sqrt(Rational(f,b)))
    #
    #
    #
    def semieixos_quadrats(self):
        &#34;&#34;&#34;
        Retorna els semieixos al quadrat del cilindre el·líptic
        &#34;&#34;&#34;
        a = self.matriu[0,0]
        b = self.matriu[1,1]
        f = - self.matriu[3,3]
        return (Rational(f,a),Rational(f,b))
    #
    #
    #
    def equacio_reduida(self):
        &#34;&#34;&#34;
        Retorna l&#39;equacio reduïda del cilindre el·líptic
        &#34;&#34;&#34;
        a2, b2 = self.semieixos_quadrats()
        if a2 == 1:
            str = &#34;x&#39;^2&#34;
        else:
            str = f&#34;\\frac{{x&#39;^2}}{{ {latex(a2)} }}&#34;
        if b2 == 1:
            str += &#34; + y&#39;^2 = 1&#34;
        else:
            str += f&#34; + \\frac{{y&#39;^2}}{{ {latex(b2)} }} = 1&#34;
        return str


class CilindreHiperbolic(Quadrica):
    &#34;&#34;&#34;
    Classe per treballar amb cilindres hiperbòlic
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,a2,b2,centre,eix1,eix2):
        &#34;&#34;&#34;
        Constructor.
        Paràmetres:
           a2, b2: semieixos al quadrat
           eix1: direcció de l&#39;eix principal (de les x&#39;)
           eix2: en pricipi és la direcció de l&#39;eix de les y&#39;, però si no és
                 perpendicular a eix1, es calcula el perpendicular que està
                 en el mateix pla vectorial que &lt;eix1,eix2&gt; aplicant el
                 mètode de Gram-Schmidt
        &#34;&#34;&#34;
        if not isinstance(centre,Punt):
            return None
        if not isinstance(eix1,Vector):
            return None
        if not isinstance(eix2,Vector):
            return None
        if centre.dimensio != 3:
            return None
        if eix1.dimensio != 3:
            return None
        if eix2.dimensio != 3:
            return None
        if eix1.length() == 0:
            return None
        if eix2.length() == 0:
            return None
        m = Matriu.from_vectors_columna([eix1,eix2])
        if m.rank() != 2:
            return None
        if a2 &lt;= 0:
            return None
        if b2 &lt;= 0:
            return None
        return super(Quadrica,cls).__new__(cls)
    #
    #
    #
    def __init__(self,a2,b2,centre,eix1,eix2):
        s = SubespaiVectorial([eix1,eix2])
        base = s.amplia_base(unitaria=True)
        r = ReferenciaAfi(centre,base)
        g = mcd_llista([a2,b2])
        t = a2 * b2 // g
        a2 = a2 // g
        b2 = b2 // g
        m = Matriu.diagonal(Vector([b2,-a2,0,-t]))
        Quadrica.__init__(self,m,r)
    #
    #
    #
    @classmethod
    def aleatoria(cls,canonica=False):
        &#34;&#34;&#34;
        Retorna un cilindre hiperbòlic de manera aleatòria
        &#34;&#34;&#34;
        if canonica:
            v = [Vector(1,0,0),Vector(0,1,0),Vector(0,0,1)]
            random.shuffle(v)
            eix1, eix2, _ = v
        else:
            trobat = False
            while not trobat:
                eix1 = Vector.aleatori(l=3,maxim=3)
                eix2 = Vector.aleatori(l=3,maxim=3)
                if eix1.nzeros() &gt; 1 or eix2.nzeros() &gt; 1:
                    continue
                trobat = Matriu.from_vectors_columna([eix1,eix2]).rank() == 2
        trobat = False
        while not trobat:
            centre = Punt.aleatori(l=3,maxim=4,nuls=False)
            trobat = centre.length() &gt; 0
        c = [1,2,3,4,5,8,10,12,16,18,20,25,36,40,45,48,50,60]
        trobat = False
        while not trobat:
            a = random.randint(0,len(c) - 1)
            a2 = c[a]
            a = random.randint(0,len(c) - 1)
            b2 = c[a]
            trobat = a2 != b2
        return cls(a2,b2,centre,eix1,eix2)
    #
    #
    #
    def centre(self):
        &#34;&#34;&#34;
        Retorna un centre del cilindre hiperbòlic
        &#34;&#34;&#34;
        return (self.ref.origen)
    #
    #
    #
    def centres(self):
        &#34;&#34;&#34;
        Retorna la recta de centres
        &#34;&#34;&#34;
        return RectaAfi(self.ref.origen,self.ref.base[2])
    #
    #
    #
    def semieixos(self):
        &#34;&#34;&#34;
        Retorna els semieixos del cilindre hiperbòlic
        &#34;&#34;&#34;
        a = self.matriu[0,0]
        b = - self.matriu[1,1]
        f = - self.matriu[3,3]
        return (sqrt(Rational(f,a)),sqrt(Rational(f,b)))
    #
    #
    #
    def semieixos_quadrats(self):
        &#34;&#34;&#34;
        Retorna els semieixos al quadrat del cilindre hiperbòlic
        &#34;&#34;&#34;
        a = self.matriu[0,0]
        b = - self.matriu[1,1]
        f = - self.matriu[3,3]
        return (Rational(f,a),Rational(f,b))
    #
    #
    #
    def equacio_reduida(self):
        &#34;&#34;&#34;
        Retorna l&#39;equacio reduïda del cilindre hiperbòlic
        &#34;&#34;&#34;
        a2, b2 = self.semieixos_quadrats()
        if a2 == 1:
            str = &#34;x&#39;^2&#34;
        else:
            str = f&#34;\\frac{{x&#39;^2}}{{ {latex(a2)} }}&#34;
        if b2 == 1:
            str += &#34; - y&#39;^2 = 1&#34;
        else:
            str += f&#34; - \\frac{{y&#39;^2}}{{ {latex(b2)} }} = 1&#34;
        return str


class ParaboloideElliptic(Quadrica):
    &#34;&#34;&#34;
    Classe per treballar amb paraboloides el·líptics
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,a2,b2,vertex,eix1,eix2):
        &#34;&#34;&#34;
        Constructor.
        Retorna el paraboloide el·líptic amb vèrtex &#34;vertex&#34; i semieixos l*a2
        i l*b2, on l és la longitud de eix3
        Paràmetres:
           a2, b2: nombres enters positius
           eix1: direcció de l&#39;eix principal (de les x&#39;)
           eix2: en pricipi és la direcció de l&#39;eix de les y&#39;, però si no és
                 perpendicular a eix1, es calcula el perpendicular que està
                 en el mateix pla vectorial que &lt;eix1,eix2&gt; aplicant el
                 mètode de Gram-Schmidt
        &#34;&#34;&#34;
        if not isinstance(vertex,Punt):
            return None
        if not isinstance(eix1,Vector):
            return None
        if not isinstance(eix2,Vector):
            return None
        if vertex.dimensio != 3:
            return None
        if eix1.dimensio != 3:
            return None
        if eix2.dimensio != 3:
            return None
        if eix1.length() == 0:
            return None
        if eix2.length() == 0:
            return None
        m = Matriu.from_vectors_columna([eix1,eix2])
        if m.rank() != 2:
            return None
        if a2 &lt;= 0:
            return None
        if b2 &lt;= 0:
            return None
        a2 = sympify(a2)
        b2 = sympify(b2)
        if not a2.is_integer or not b2.is_integer:
            return None
        return super(Quadrica,cls).__new__(cls)
    #
    #
    #
    def __init__(self,a2,b2,vertex,eix1,eix2):
        s = SubespaiVectorial([eix1,eix2])
        base = s.amplia_base(unitaria=True)
        r = ReferenciaAfi(vertex,base)
        q = base.quadrats_longituds()
        t = a2 * b2
        a2 = t // a2
        b2 = t // b2
        t *= sqrt(q[2])
        m = Matriu(Matrix([[a2,0,0,0],[0,b2,0,0],[0,0,0,-t/2],[0,0,-t/2,0]]))
        Quadrica.__init__(self,m,r)
    #
    #
    #
    @classmethod
    def aleatoria(cls,canonica=False):
        &#34;&#34;&#34;
        Retorna un paraboloide el·líptic de manera aleatòria
        &#34;&#34;&#34;
        if canonica:
            v = [Vector(1,0,0),Vector(0,1,0),Vector(0,0,1)]
            random.shuffle(v)
            eix1, eix2, _ = v
        else:
            trobat = False
            while not trobat:
                eix1 = Vector.aleatori(l=3,maxim=3)
                eix2 = Vector.aleatori(l=3,maxim=3)
                if eix1.nzeros() &gt; 1 or eix2.nzeros() &gt; 1:
                    continue
                trobat = Matriu.from_vectors_columna([eix1,eix2]).rank() == 2
        trobat = False
        while not trobat:
            vertex = Punt.aleatori(l=3,maxim=4,nuls=False)
            trobat = vertex.length() &gt; 0
        c = [1,2,3,4,5,8,10,12,16,18,20,25,36,40,45,48,50,60]
        trobat = False
        while not trobat:
            a = random.randint(0,len(c) - 1)
            a2 = c[a]
            a = random.randint(0,len(c) - 1)
            b2 = c[a]
            trobat = a2 != b2
        a2, b2 = sorted([a2,b2])[::-1]
        return cls(a2,b2,vertex,eix1,eix2)
    #
    #
    #
    def vertex(self):
        &#34;&#34;&#34;
        Retorna el vèrtex del paraboloide el·líptic
        &#34;&#34;&#34;
        return (self.ref.origen)
    #
    #
    #
    def semieixos(self):
        &#34;&#34;&#34;
        Retorna els semieixos del paraboloide el·líptic
        &#34;&#34;&#34;
        a = self.matriu[0,0]
        b = self.matriu[1,1]
        t = - 2 * self.matriu[2,3]
        return (sqrt(t/a),sqrt(t/b))
    #
    #
    #
    def semieixos_quadrats(self):
        &#34;&#34;&#34;
        Retorna els semieixos al quadrat del paraboloide el·líptic
        &#34;&#34;&#34;
        a = self.matriu[0,0]
        b = self.matriu[1,1]
        t = - 2 * self.matriu[2,3]
        return (t/a,t/b)
    #
    #
    #
    def equacio_reduida(self):
        &#34;&#34;&#34;
        Retorna l&#39;equacio reduïda del paraboloide el·líptic
        &#34;&#34;&#34;
        a2, b2 = self.semieixos_quadrats()
        if a2 == 1:
            str = &#34;z&#39; = x&#39;^2&#34;
        else:
            str = f&#34;z&#39; = \\frac{{x&#39;^2}}{{ {latex(a2)} }}&#34;
        if b2 == 1:
            str += &#34; + y&#39;^2&#34;
        else:
            str += f&#34; + \\frac{{y&#39;^2}}{{ {latex(b2)} }}&#34;
        return str


class ParaboloideHiperbolic(Quadrica):
    &#34;&#34;&#34;
    Classe per treballar amb paraboloides hiperbòlics
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,a2,b2,vertex,eix1,eix2):
        &#34;&#34;&#34;
        Constructor.
        Retorna el paraboloide hiperbòlic amb vèrtex &#34;vertex&#34; i semieixos l*a2
        i l*b2, on l és la longitud de eix3
        Paràmetres:
           a2, b2: nombres enters positius
           eix1: direcció de l&#39;eix principal (de les x&#39;)
           eix2: en pricipi és la direcció de l&#39;eix de les y&#39;, però si no és
                 perpendicular a eix1, es calcula el perpendicular que està
                 en el mateix pla vectorial que &lt;eix1,eix2&gt; aplicant el
                 mètode de Gram-Schmidt
        &#34;&#34;&#34;
        if not isinstance(vertex,Punt):
            return None
        if not isinstance(eix1,Vector):
            return None
        if not isinstance(eix2,Vector):
            return None
        if vertex.dimensio != 3:
            return None
        if eix1.dimensio != 3:
            return None
        if eix2.dimensio != 3:
            return None
        if eix1.length() == 0:
            return None
        if eix2.length() == 0:
            return None
        m = Matriu.from_vectors_columna([eix1,eix2])
        if m.rank() != 2:
            return None
        if a2 &lt;= 0:
            return None
        if b2 &lt;= 0:
            return None
        a2 = sympify(a2)
        b2 = sympify(b2)
        if not a2.is_integer or not b2.is_integer:
            return None
        return super(Quadrica,cls).__new__(cls)
    #
    #
    #
    def __init__(self,a2,b2,vertex,eix1,eix2):
        s = SubespaiVectorial([eix1,eix2])
        base = s.amplia_base(unitaria=True)
        r = ReferenciaAfi(vertex,base)
        g = mcd_llista([a2,b2])
        t = a2 * b2 // g
        a2 = a2 // g
        b2 = b2 // g
        q = base.quadrats_longituds()
        if random.randint(0,1):
            t /= sqrt(q[2])
        else:
            t *= sqrt(q[2])
        m = Matriu(Matrix([[b2,0,0,0],[0,-a2,0,0],[0,0,0,-t/2],[0,0,-t/2,0]]))
        Quadrica.__init__(self,m,r)
    #
    #
    #
    @classmethod
    def aleatoria(cls,canonica=False):
        &#34;&#34;&#34;
        Retorna un paraboloide hiperbòlic de manera aleatòria
        &#34;&#34;&#34;
        if canonica:
            v = [Vector(1,0,0),Vector(0,1,0),Vector(0,0,1)]
            random.shuffle(v)
            eix1, eix2, _ = v
        else:
            trobat = False
            while not trobat:
                eix1 = Vector.aleatori(l=3,maxim=3)
                eix2 = Vector.aleatori(l=3,maxim=3)
                if eix1.nzeros() &gt; 1 or eix2.nzeros() &gt; 1:
                    continue
                trobat = Matriu.from_vectors_columna([eix1,eix2]).rank() == 2
        trobat = False
        while not trobat:
            vertex = Punt.aleatori(l=3,maxim=4,nuls=False)
            trobat = vertex.length() &gt; 0
        c = [1,2,3,4,5,8,10,12,16]
        trobat = False
        while not trobat:
            a = random.randint(0,len(c) - 1)
            a2 = c[a]
            a = random.randint(0,len(c) - 1)
            b2 = c[a]
            trobat = a2 != b2
        return cls(a2,b2,vertex,eix1,eix2)
    #
    #
    #
    def vertex(self):
        &#34;&#34;&#34;
        Retorna el vèrtex del paraboloide hiperbòlic
        &#34;&#34;&#34;
        return (self.ref.origen)
    #
    #
    #
    def semieixos(self):
        &#34;&#34;&#34;
        Retorna els semieixos del paraboloide hiperbòlic
        &#34;&#34;&#34;
        a = self.matriu[0,0]
        b = - self.matriu[1,1]
        t = - 2 * self.matriu[2,3]
        return (sqrt(t,a),sqrt(t,b))
    #
    #
    #
    def semieixos_quadrats(self):
        &#34;&#34;&#34;
        Retorna els semieixos al quadrat del paraboloide hiperbòlic
        &#34;&#34;&#34;
        a = self.matriu[0,0]
        b = - self.matriu[1,1]
        t = - 2 * self.matriu[2,3]
        return (t/a,t/b)
    #
    #
    #
    def equacio_reduida(self):
        &#34;&#34;&#34;
        Retorna l&#39;equacio reduïda del paraboloide hiperbòlic
        &#34;&#34;&#34;
        a2, b2 = self.semieixos_quadrats()
        if a2 == 1:
            str = &#34;z&#39; = x&#39;^2&#34;
        else:
            str = f&#34;z&#39; = \\frac{{x&#39;^2}}{{ {latex(a2)} }}&#34;
        if b2 == 1:
            str += &#34; - y&#39;^2&#34;
        else:
            str += f&#34; - \\frac{{y&#39;^2}}{{ {latex(b2)} }}&#34;
        return str


class CilindreParabolic(Quadrica):
    &#34;&#34;&#34;
    Classe per treballar amb cilindres parabòlics
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,p,vertex,eix1,eix2=None):
        &#34;&#34;&#34;
        Constructor.
        Retorna el cilindre parabòlic amb vèrtex &#34;vertex&#34;, eix de les x&#39; amb
        direcció &#34;eix&#34;, eix de les y&#39; amb direcció &#34;eix2&#34; i paràmetre de
        la paràbola &#34;p&#34;
        Paràmetres:
           p: paràmetre de l&#39;equació reduïda z&#39; = \\frac{x&#39;^2}{2 * p}
           vertex: un vèrtex del cilindre parabòlic
           eix1: direcció de l&#39;eix de les x&#39;
           eix2: direcció de l&#39;eix de les y&#39;. Si és None, el tria el programa
        &#34;&#34;&#34;
        if not isinstance(vertex,Punt):
            return None
        if not isinstance(eix1,Vector):
            return None
        if vertex.dimensio != 3:
            return None
        if eix1.dimensio != 3:
            return None
        if eix1.nzeros() &gt;= 2:
            return None
        if p == 0:
            return None
        if eix2 is not None:
            if not isinstance(eix2,Vector):
                return None
            if eix2.dimensio != 3:
                return None
            w = eix1.cross(eix2,simplificar=True)
            if w.length() == 0:
                return None
        return super(Quadrica,cls).__new__(cls)
    #
    #
    #
    def __init__(self,p,vertex,eix1,eix2=None):
        if eix2 is None:
            s = SubespaiVectorial([eix1])
        else:
            s = SubespaiVectorial([eix1,eix2])
        base = s.amplia_base(unitaria=True)
        r = ReferenciaAfi(vertex,base)
        m = Matriu(Matrix([[1,0,0,0],[0,0,0,0],[0,0,0,-p],[0,0,-p,0]]))
        Quadrica.__init__(self,m,r)
    #
    #
    #
    @classmethod
    def aleatoria(cls,canonica=False):
        &#34;&#34;&#34;
        Retorna un cilindre parabòlic de manera aleatòria
        &#34;&#34;&#34;
        vertex = Punt.aleatori(l=3,maxim=4,nuls=False)
        trobat = False
        while not trobat:
            eix = Vector.aleatori(l=3,maxim=3)
            trobat = eix.nzeros() &lt; 2 and eix.length() &lt; 12
        s = SubespaiVectorial([eix])
        base = s.amplia_base(unitaria=True)
        if canonica:
            v = [Vector(1,0,0),Vector(0,1,0),Vector(0,0,1)]
            random.shuffle(v)
            base = Base(v)
        q = base.quadrats_longituds()
        c = [k for k in range(1,3)] + [-k for k in range(1,3)]
        c += [Rational(1,k) for k in range(1,4)] + [-Rational(1,k) for k in range(1,4)]
        a = random.randint(0,len(c) - 1)
        p = 2 * c[a] * sqrt(q[2])
        return cls(p,vertex,eix)
    #
    #
    #
    def parametre(self):
        &#34;&#34;&#34;
        Retorna el paràmetre de la paràbola
        &#34;&#34;&#34;
        return - self.matriu[2,3]
    #
    #
    #
    def vertex(self):
        &#34;&#34;&#34;
            Retorna l&#39;origen de la referència principal
        &#34;&#34;&#34;
        return (self.ref.origen)
    #
    #
    #
    def equacio_reduida(self):
        &#34;&#34;&#34;
        Retorna l&#39;equacio reduïda del cilindre parabòlic
        &#34;&#34;&#34;
        p = self.parametre()
        if 2 * p == 1:
            return f&#34;z&#39; = x&#39;^2&#34;
        if 2 * p == -1:
            return f&#34;z&#39; = - x&#39;^2&#34;
        if p &gt; 0:
            return f&#34;z&#39; = \\frac{{x&#39;^2}}{{ {latex(2 * p)} }}&#34;
        return f&#34;z&#39; = -\\frac{{x&#39;^2}}{{ {latex(-2 * p)} }}&#34;


class RectaRegressio(object):
    &#34;&#34;&#34;
    Classe per treballar amb rectes de regressió
    Atributs:
        punts: llista de punts
        A: matriu dels coeficients de les incògnites
        B: vector de termes independents
        solucio: solució del sistema d&#39;equacions A^tAX = A^tB
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,punts):
        &#34;&#34;&#34;
        Retorna un objecte RectaRegressio definit a partir d&#39;una llista de punts
        Paràmetres:
            punts: llista de punts de dimensió 2
        &#34;&#34;&#34;
        if not isinstance(punts,list) and not isinstance(punts,tuple):
            return None
        if len(punts) &lt;= 2:
            return None
        for k in punts:
            if not isinstance(k,Punt):
                return None
            if k.dimensio != 2:
                return None
        return super(RectaRegressio,cls).__new__(cls)
    #
    #
    #
    def __init__(self,punts):
        self.punts = punts
        a = Vector([k[0] for k in self.punts])
        b = Vector(len(self.punts) * [1])
        A = Matriu.from_vectors_columna([a,b])
        B = Vector([k[1] for k in self.punts])
        s = SistemaEquacions(A.transposada() * A,A.transposada() * B)
        s.resol()
        self.A = A
        self.B = B
        self.solucio = Vector(s.solucio)
    #
    #
    #
    def equacio(self):
        &#34;&#34;&#34;
        Retorna l&#39;equació de la recta de regressió expressada en LaTeX
        &#34;&#34;&#34;
        x = symbols(&#39;x&#39;)
        n = Vector.nul(dim=2)
        if self.solucio == n:
            return &#34;y=0&#34;
        a, b = self.solucio.factor_comu()
        eq = a.p * (b[0]*x + b[1])
        if a.q == 1:
            return f&#34;y = {mylatex(eq)}&#34;
        return f&#34;y = \\frac{{ {mylatex(eq)} }}{{ {a.q} }}&#34;
    #
    #
    #
    def error_quadratic(self):
        &#34;&#34;&#34;
        Retorna d&#39;error quadràtic
        &#34;&#34;&#34;
        e = self.A * self.solucio - self.B
        return e.length()
    #
    #
    #
    @classmethod
    def aleatoria(cls,l=4,max=4):
        &#34;&#34;&#34;
        Retorna un problema aleatori amb l punts
        Paràmetres:
            l: nombre de punts
            max: valor màxim de les ys
        &#34;&#34;&#34;
        if l &gt; 13:
            return None
        p = [-k for k in range(l)] + [k for k in range(l)]
        random.shuffle(p)
        xs = p[0:l]
        xs.sort()
        ys = [random.randint(-max,max) for k in range(l)]
        punts = [Punt(xs[k],ys[k]) for k in range(l)]
        return cls(punts)
    #
    #
    #
    def llista_punts(self):
        &#34;&#34;&#34;
        Retorna la llista de punts en format LaTeX
        &#34;&#34;&#34;
        l = list(map(lambda item: f&#34;${item}$&#34;,self.punts))
        return &#34;, &#34;.join(l[0:-1]) + f&#34; i {l[-1]}&#34;
    #
    #
    #
    def taula_punts(self):
        &#34;&#34;&#34;
        Retorna una taula en format LaTeX dels punts
        &#34;&#34;&#34;
        format = &#34;c|&#34; + len(self.punts) * &#34;r&#34;
        xs = &#34; &amp; &#34;.join([f&#34;${p[0]}$&#34; for p in self.punts])
        ys = &#34; &amp; &#34;.join([f&#34;${p[1]}$&#34; for p in self.punts])
        return f&#34;\\begin{{tabular}}{{{format}}} {xs} \\\\ \\hline {ys} \\end{{tabular}}&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="Algebra.matriu_latex"><code class="name flex">
<span>def <span class="ident">matriu_latex</span></span>(<span>m, format=None, ampliada=False, tipus='p')</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna l'expressió en latex d'una matriu del tipus Matrix del sympy</p>
<h2 id="parametres">Parametres</h2>
<p>format:
format de les columnes de la matriu. Per defecte "r"
ampliada: si es vol separar amb una línia vertical l'última
columna de la matriu</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def matriu_latex(m,format=None,ampliada=False,tipus=&#34;p&#34;):
    &#34;&#34;&#34;
    Retorna l&#39;expressió en latex d&#39;una matriu del tipus Matrix del sympy
    Parametres:
        format:   format de les columnes de la matriu. Per defecte &#34;r&#34;
        ampliada: si es vol separar amb una línia vertical l&#39;última
                  columna de la matriu
    &#34;&#34;&#34;
    f, c = m.shape
    vert = &#34;&#34;
    if ampliada:
        cols = c - 1
        vert = &#34;|r&#34;
    else:
        cols = c
    if format is None:
        text = &#34;\\begin{TIPUSmatrix}{*{%d}r%s} LINES\\end{TIPUSmatrix}&#34; % (cols,vert)
    else:
        text = &#34;\\begin{TIPUSmatrix}{%s} LINES\\end{TIPUSmatrix}&#34; % format
    text = text.replace(&#39;TIPUS&#39;,tipus)
    lines = []
    for i in range(f):
        line = []
        for j in range(c):
            line.append(latex(m[i,j]))
        lines.append(&#34; &amp; &#34;.join(map(str,line)))
    return (text.replace(&#39;LINES&#39;,&#34;\\\\ &#34;.join(lines)))</code></pre>
</details>
</dd>
<dt id="Algebra.matriu_mathematica"><code class="name flex">
<span>def <span class="ident">matriu_mathematica</span></span>(<span>m)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna l'expressió en Mathematica d'una matriu del tipus Matrix del sympy</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def matriu_mathematica(m):
    &#34;&#34;&#34;
    Retorna l&#39;expressió en Mathematica d&#39;una matriu del tipus Matrix del sympy
    &#34;&#34;&#34;
    r = re.compile(r&#39;sqrt\((\d+)\)&#39;)
    f, c = m.shape
    lines = []
    slines = &#34;{LINES}&#34;
    for i in range(f):
        line = []
        sline = &#34;{LINE}&#34;
        for j in range(c):
            line.append(m[i,j])
        sline = sline.replace(&#39;LINE&#39;,&#34;,&#34;.join(map(str,line)))
        sline = r.sub(r&#39;Sqrt[\g&lt;1&gt;]&#39;,sline)
        lines.append(sline)
    return (slines.replace(&#39;LINES&#39;,&#34;,&#34;.join(lines)))</code></pre>
</details>
</dd>
<dt id="Algebra.mcd_llista"><code class="name flex">
<span>def <span class="ident">mcd_llista</span></span>(<span>list)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el màxim comú divisor d'una llista d'enters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mcd_llista(list):
    &#34;&#34;&#34;
    Retorna el màxim comú divisor d&#39;una llista d&#39;enters
    &#34;&#34;&#34;
    return reduce(gcd, list)</code></pre>
</details>
</dd>
<dt id="Algebra.mcm_llista"><code class="name flex">
<span>def <span class="ident">mcm_llista</span></span>(<span>list)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el mínim comú múltiple d'una llista d'enters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mcm_llista(list):
    &#34;&#34;&#34;
    Retorna el mínim comú múltiple d&#39;una llista d&#39;enters
    &#34;&#34;&#34;
    if len(list) == 0:
        return 1
    mcm = list[0]
    for i in list[1:]:
        mcm = mcm * i // gcd(mcm, i)
    return mcm</code></pre>
</details>
</dd>
<dt id="Algebra.mti"><code class="name flex">
<span>def <span class="ident">mti</span></span>(<span>i, j)</span>
</code></dt>
<dd>
<div class="desc"><p>Funció auxiliar per crear una matriu triangular superior i uns
o menys uns a la diagonal
Retorna zero si el coeficients està per sota de la diagonal principal</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mti(i,j):
    &#34;&#34;&#34;
    Funció auxiliar per crear una matriu triangular superior i uns
    o menys uns a la diagonal
    Retorna zero si el coeficients està per sota de la diagonal principal
    &#34;&#34;&#34;
    values = (-1,1)
    if i &gt; j:
        return 0
    elif i == j:
        return values[random.randint(0,1)]
    else:
        return random.randint(-1,2)</code></pre>
</details>
</dd>
<dt id="Algebra.mts"><code class="name flex">
<span>def <span class="ident">mts</span></span>(<span>i, j, values)</span>
</code></dt>
<dd>
<div class="desc"><p>Funció auxiliar per crear una matriu triangular inferior i uns
o menys uns a la diagonal
Retorna zero si el coeficients està per sobre de la diagonal principal</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mts(i,j,values):
    &#34;&#34;&#34;
    Funció auxiliar per crear una matriu triangular inferior i uns
    o menys uns a la diagonal
    Retorna zero si el coeficients està per sobre de la diagonal principal
    &#34;&#34;&#34;
    if i &lt; j:
        return 0
    elif i == j:
        return  values[i]
    else:
        return random.randint(-2,1)</code></pre>
</details>
</dd>
<dt id="Algebra.mylatex"><code class="name flex">
<span>def <span class="ident">mylatex</span></span>(<span>e)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mylatex(e):
    p, q, r, s = symbols(&#39;p q u v&#39;)
    e = str(e)
    e = e.replace(&#39;x&#39;,&#39;p&#39;)
    e = e.replace(&#39;y&#39;,&#39;q&#39;)
    e = e.replace(&#39;z&#39;,&#39;u&#39;)
    e = e.replace(&#39;t&#39;,&#39;v&#39;)
    e = sympify(e)
    if not isinstance(e,Add):
        e = latex(e)
    else:
        e = Impresora().doprint(e)
    e = e.replace(&#39;p&#39;,&#39;x&#39;)
    e = e.replace(&#39;q&#39;,&#39;y&#39;)
    e = e.replace(&#39;u&#39;,&#39;z&#39;)
    e = e.replace(&#39;v&#39;,&#39;t&#39;)
    return e</code></pre>
</details>
</dd>
<dt id="Algebra.nnegatius"><code class="name flex">
<span>def <span class="ident">nnegatius</span></span>(<span>m)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el nombre d'elements negatius d'una matriu del tipus Matrix del sympy</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nnegatius(m):
    &#34;&#34;&#34;
    Retorna el nombre d&#39;elements negatius d&#39;una matriu del tipus Matrix del sympy
    &#34;&#34;&#34;
    f, c = m.shape
    z = 0
    for i in range(f):
        for j in range(c):
            if m[i,j] &lt; 0:
                z += 1
    return z</code></pre>
</details>
</dd>
<dt id="Algebra.norma_maxim"><code class="name flex">
<span>def <span class="ident">norma_maxim</span></span>(<span>m)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el màxim en valor absolut d'entre els coeficients d'una matriu
del tipus Matrix del sympy</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def norma_maxim(m):
    &#34;&#34;&#34;
    Retorna el màxim en valor absolut d&#39;entre els coeficients d&#39;una matriu
    del tipus Matrix del sympy
    &#34;&#34;&#34;
    f, c = m.shape
    n = 0
    for i in range(f):
        for j in range(c):
            if abs(m[i,j]) &gt; n:
                n = abs(m[i,j])
    return n</code></pre>
</details>
</dd>
<dt id="Algebra.nzeros"><code class="name flex">
<span>def <span class="ident">nzeros</span></span>(<span>m)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el nombre de zeros d'una matriu del tipus Matrix del sympy</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nzeros(m):
    &#34;&#34;&#34;
    Retorna el nombre de zeros d&#39;una matriu del tipus Matrix del sympy
    &#34;&#34;&#34;
    f, c = m.shape
    z = 0
    for i in range(f):
        for j in range(c):
            if m[i,j] == 0:
                z += 1
    return z</code></pre>
</details>
</dd>
<dt id="Algebra.primer_no_nul"><code class="name flex">
<span>def <span class="ident">primer_no_nul</span></span>(<span>list)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna l'índex del primer coeficient no nul d'una llista</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def primer_no_nul(list):
    &#34;&#34;&#34;
    Retorna l&#39;índex del primer coeficient no nul d&#39;una llista
    &#34;&#34;&#34;
    if list is None or len(list) == 0:
        return None
    for i in range(len(list)):
        if list[i] != 0:
            return i
    return None</code></pre>
</details>
</dd>
<dt id="Algebra.vaps_veps"><code class="name flex">
<span>def <span class="ident">vaps_veps</span></span>(<span>result, ortogonals=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la llista valors propis i els seus vectors propis.</p>
<h2 id="parametres">Paràmetres</h2>
<p>result: resultat de la funció eigenvects() del sympy</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vaps_veps(result,ortogonals=False):
    &#34;&#34;&#34;
    Retorna la llista valors propis i els seus vectors propis.
    Paràmetres:
        result: resultat de la funció eigenvects() del sympy
    &#34;&#34;&#34;
    vaps = []
    veps = []
    for l, m, us in result:
        if ortogonals and m &gt; 1:
            vs = [Matriu(us[k]).vectors_columna()[0] for k in range(m)]
            b = SubespaiVectorial(vs).base_ortogonal()
            veps.extend(b)
            vaps.extend(m*[l])
        else:
            for k in range(m):
                vaps.append(l)
                n1 = Matriu(us[k])
                vep = n1.vectors_columna()[0]
                vep.simplificar()
                veps.append(vep)
    return (vaps,veps)</code></pre>
</details>
</dd>
<dt id="Algebra.vaps_veps_amb_signe"><code class="name flex">
<span>def <span class="ident">vaps_veps_amb_signe</span></span>(<span>result, signe=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Donada una matriu A del sympy, result ha de ser el resultat de la funció
r = A.eigenvects(). Aleshores aquesta funció retorna la llista valors propis
positius (signe &gt; 0) o negatius (signe &lt; 0) i els seus vectors propis.</p>
<h2 id="parametres">Paràmetres</h2>
<p>result: resultat de la funció eigenvects() del sympy
signe: positiu o negatiu, en funció de quins valors i vectors propis es volen</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vaps_veps_amb_signe(result,signe=1):
    &#34;&#34;&#34;
    Donada una matriu A del sympy, result ha de ser el resultat de la funció
    r = A.eigenvects(). Aleshores aquesta funció retorna la llista valors propis
    positius (signe &gt; 0) o negatius (signe &lt; 0) i els seus vectors propis.
    Paràmetres:
        result: resultat de la funció eigenvects() del sympy
        signe: positiu o negatiu, en funció de quins valors i vectors propis es volen
    &#34;&#34;&#34;
    vaps = []
    veps = []
    for l, m, us in result:
        if l * signe &lt;= 0:
            continue
        for k in range(m):
            vaps.append(l)
            n1 = Matriu(us[k])
            vep = n1.vectors_columna()[0]
            vep.simplificar()
            veps.append(vep)
    return (vaps,veps)</code></pre>
</details>
</dd>
<dt id="Algebra.vectors_latex"><code class="name flex">
<span>def <span class="ident">vectors_latex</span></span>(<span>l, sep=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la llista de vectors l escrita en latex</p>
<h2 id="parametres">Paràmetres</h2>
<p>l: llista de vectors o punts
sep: Si és False, retorna (1,2,3),(3,5,2),(1,-2,3)
Si és True, retorna $(1,2,3)$, $(3,5,2)$ i $(1,-2,3)$</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vectors_latex(l,sep=False):
    &#34;&#34;&#34;
    Retorna la llista de vectors l escrita en latex
    Paràmetres:
        l: llista de vectors o punts
        sep: Si és False, retorna (1,2,3),(3,5,2),(1,-2,3)
             Si és True, retorna $(1,2,3)$, $(3,5,2)$ i $(1,-2,3)$
    &#34;&#34;&#34;
    if not sep:
        return &#34;,&#34;.join([str(k) for k in l])
    if len(l) == 1:
        return f&#34;${l[0]}$&#34;
    f = l[:-1]
    txt = &#34;, &#34;.join([f&#34;${k}$&#34; for k in f])
    txt += f&#34; i ${l[-1]}$&#34;
    return txt</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="Algebra.Base"><code class="flex name class">
<span>class <span class="ident">Base</span></span>
<span>(</span><span>vecs, unitaria=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Classe que ens permetrà representar bases de R^n</p>
<h2 id="atributs">Atributs</h2>
<p>vecs: una llista de n vectors de R^n
dimensio: el valor de n
unitaria: En funcio de si volem imprimir els seus
vectors unitaris o no</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Base(object):
    &#34;&#34;&#34;
    Classe que ens permetrà representar bases de R^n
    Atributs:
        vecs: una llista de n vectors de R^n
        dimensio: el valor de n
        unitaria: En funcio de si volem imprimir els seus
                  vectors unitaris o no
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,vecs,unitaria=False):
        &#34;&#34;&#34;
        Contructor.
        Paràmetres:
           vecs: llista de vectors
           unitaria: True o False.
                     Serveix per si volem imprimir o fer servir els seus
                     vectors com a unitaris
        Exemple:
            base = Base([Vector(1,1),Vector(-1,1)],unitaria=True)
            print(base)
            print(base.vecs)
        &#34;&#34;&#34;
        if len(vecs) == 0:
            return None
        if not isinstance(vecs[0],Vector):
            return None
        d = vecs[0].dimensio
        for v in vecs:
            if not isinstance(v,Vector):
                return None
            if v.dimensio != d:
                return None
        m = Matriu.from_vectors_columna(vecs)
        if m.files != d:
            return None
        if m.rank() != len(vecs):
            return None
        return super(Base,cls).__new__(cls)
    #
    #
    #
    def __init__(self,vecs,unitaria=False):
        self.unitaria = unitaria
        self.vecs = vecs
        self.dimensio = vecs[0].dimensio
    #
    #
    #
    def es_unitaria(self):
        &#34;&#34;&#34;
        Retorna si la base és unitària. Notem que els vectors no es guarden
        com a unitaris.
        &#34;&#34;&#34;
        return self.unitaria
    #
    #
    #
    def es_ortogonal(self):
        &#34;&#34;&#34;
        Retorna si la base és ortogonal
        &#34;&#34;&#34;
        d = len(self.vecs)
        for i in range(d):
            for j in range(i+1,d):
                if self.vecs[i].dot(self.vecs[j]) != 0:
                    return False
        return True
    #
    #
    #
    def set_unitaria(self):
        &#34;&#34;&#34;
        Si la matriu és ortogonal, la passa a unitària
        &#34;&#34;&#34;
        if not self.es_ortogonal():
            return
        self.unitaria = True
    #
    #
    #
    def te_orientacio_positiva(self):
        &#34;&#34;&#34;
        Retorna si té orientació positiva
        &#34;&#34;&#34;
        m = Matriu.from_vectors_columna(self.vecs)
        return m.determinant() &gt; 0
    #
    #
    #
    def orientacio_positiva(self):
        &#34;&#34;&#34;
        Fa que tingui orientació positiva canviant, si cal, de signe l&#39;últim
        vector
        &#34;&#34;&#34;
        if not self.te_orientacio_positiva():
            self.vecs[-1] = - self.vecs[-1]
    #
    #
    #
    def matriu(self):
        &#34;&#34;&#34;
        Retorna la matriu de la classe Matriu que té per columnes
        els vectors de la base
        &#34;&#34;&#34;
        if not self.unitaria:
            return Matriu.from_vectors_columna(self.vecs)
        unitaris = [(1 / v.length()) * v for v in self.vecs]
        return Matriu.from_vectors_columna(unitaris)
    #
    #
    #
    @classmethod
    def from_matriu(cls,m):
        &#34;&#34;&#34;
        Crea una nova base a partir d&#39;una matriu de la classe Matriu
        Si la matriu no és quadrada o no té rang màxim, retorna None
        &#34;&#34;&#34;
        if m.files != m.columnes:
            return None
        if m.rank() != m.columnes:
            return None
        return cls(m.vectors_columna())
    #
    #
    #
    def __repr__(self):
        &#34;&#34;&#34;
        Retorna l&#39;expressió en latex de la base
        &#34;&#34;&#34;
        if not self.unitaria:
            base = &#34;,&#34;.join(map(str,self.vecs))
            return f&#34;\\{{{base}\\}}&#34;
        base = &#34;,&#34;.join([v.latex(True) for v in self.vecs])
        return f&#34;\\left\\{{{base}\\right\\}}&#34;
    #
    #
    #
    def vectors(self,unitaris=False):
        &#34;&#34;&#34;
        Retorna els vectors la base
        Paràmetres:
            unitaris: si és True, els divideix per la seva longitud
        &#34;&#34;&#34;
        if not unitaris:
            return self.vecs
        return [v/v.length() for v in self.vecs]
    #
    #
    #
    def vectors_latex(self):
        &#34;&#34;&#34;
        Retorna l&#39;expressió en latex dels vector de la base, sense les claus
        inicial i final
        &#34;&#34;&#34;
        if not self.unitaria:
            base = &#34;,&#34;.join(map(str,self.vecs))
        else:
            base = &#34;,&#34;.join([v.latex(unitari=True) for v in self.vecs])
        return f&#34;{base}&#34;
    #
    #
    #
    def vector_de_components(self,vec):
        &#34;&#34;&#34;
        Retorna un nou vector expressat en la base canònica del vector
        que en aquesta base té components &#34;vec&#34;
        Paràmetres:
            vec: vector
        &#34;&#34;&#34;
        if not isinstance(vec,Vector):
            return None
        if vec.dimensio != self.dimensio:
            return None
        c = self.matriu()
        return c * vec
    #
    #
    #
    def components_del_vector(self,vec,base=None):
        &#34;&#34;&#34;
        Retorna un nou vector expressat en aquesta base del vector
        que en la base &#34;base&#34; té components &#34;vec&#34;
        Paràmetres:
            vec: components en la base &#34;base&#34;
            base: Base
        &#34;&#34;&#34;
        if not isinstance(vec,Vector):
            return None
        if base is not None:
            if vec.dimensio != base.dimensio:
                return None
            uc = base.vector_de_components(vec)
        else:
            uc = vec
        c = self.matriu()
        return c.inversa() * uc
    #
    #
    #
    def canvi_de_base_a_la_base(self,B,p1=1,p2=0):
        &#34;&#34;&#34;
        Retorna en format latex l&#39;expressió del canvi de base de la base
        actual a la base B
        Paràmetres:
            p1: primes que s&#39;escriuran a les components en la base actual
            p2: primes que s&#39;escriuran a les components en la base B
        &#34;&#34;&#34;
        if not isinstance(B,Base):
            return None
        if self.dimensio != B.dimensio:
            return None
        c = self.matriu()
        d = B.matriu()
        A = d.inversa() * c
        if self.dimensio &lt;= 4:
            x, y, z, t = symbols(&#39;x y z t&#39;)
            components = [x,y,z,t]
        else:
            x1, x2, x3, x4, x5, x6, x7, x8 = symbols(&#39;x1 x2 x3 x4 x5 x6 x7 x8&#39;)
            components = [x1,x2,x3,x4,x5,x6,x7,x8]
        components = components[0:self.dimensio]
        ps1 = &#34;&#34;
        ps2 = &#34;&#34;
        if p1 &gt; 0:
            ps1 = p1 * &#34;&#39;&#34;
        if p2 &gt; 0:
            ps2 = p2 * &#34;&#39;&#34;
        cself = &#34; \\\\ &#34;.join([latex(k) + ps1 for k in components])
        cB = &#34; \\\\ &#34;.join([latex(k) + ps2 for k in components])
        s = &#34;\\begin{pmatrix}{c} &#34; + cB + &#34;\\end{pmatrix} = \n&#34;
        s += f&#34;{A}\n&#34;
        s += &#34;\\begin{pmatrix}{c} &#34; + cself + &#34;\\end{pmatrix}&#34;
        return s
    #
    #
    #
    @classmethod
    def ortogonal(cls,ordre=3,maxim=5,unitaria=False):
        &#34;&#34;&#34;
        Retorna una base ortogonal &#34;aleatòria&#34;
        Paràmetres:
            ordre: dimensió
            maxim: màxim per a les components dels vectors de la base
            unitaria: si és True, la base serà ortonormal
        &#34;&#34;&#34;
        trobat = False
        while not trobat:
            m = Matriu.invertible(ordre=ordre,maxim=4,mzeros=0,unitaria=True)
            L = []
            for v in m.vectors_columna():
                a = Matriu.from_vectors_columna([v])
                L.append(a.matriu)
            Q = GramSchmidt(L)
            base = []
            for m in Q:
                m = Matriu(m)
                v = m.vectors_columna()[0]
                v.simplificar()
                base.append(v)
            m = 0
            for v in base:
                a = v.maxim()
                if a &gt; m:
                    m = a
            trobat = m &lt;= maxim
        return cls(base,unitaria)
    #
    #
    #
    @classmethod
    def aleatoria(cls,dimensio=3,maxim=5,unitaria=False,mzeros=-1):
        &#34;&#34;&#34;
        Retorna una base aleàtoria
        Paràmetres:
           dimensio: Dimensió de l&#39;espai corresponent
           maxim: Nombre màxim de les components dels seus vectors
           unitaria: Si el determinant ha de ser 1 o -1
           mzeros: Nombre màxim de zeros entre les components dels seus vectors
        &#34;&#34;&#34;
        C = Matriu.invertible(ordre=dimensio,unitaria=unitaria,maxim=maxim,mzeros=mzeros)
        return cls(C.vectors_columna())
    #
    #
    #
    @classmethod
    def canonica(cls,dimensio=3):
        &#34;&#34;&#34;
        Retorna la base canònica
        Paràmetres:
           dimensio: Dimensió de l&#39;espai corresponent
        &#34;&#34;&#34;
        C = Matriu(eye(dimensio))
        return cls(C.vectors_columna())
    #
    #
    #
    def quadrats_longituds(self):
        &#34;&#34;&#34;
        Retorna els quadrats de les longituds dels vectors de la base sense tenir
        en compte si la base és unitària
        &#34;&#34;&#34;
        return [v.length()**2 for v in self.vecs]</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="Algebra.Base.aleatoria"><code class="name flex">
<span>def <span class="ident">aleatoria</span></span>(<span>dimensio=3, maxim=5, unitaria=False, mzeros=-1)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna una base aleàtoria</p>
<h2 id="parametres">Paràmetres</h2>
<p>dimensio: Dimensió de l'espai corresponent
maxim: Nombre màxim de les components dels seus vectors
unitaria: Si el determinant ha de ser 1 o -1
mzeros: Nombre màxim de zeros entre les components dels seus vectors</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def aleatoria(cls,dimensio=3,maxim=5,unitaria=False,mzeros=-1):
    &#34;&#34;&#34;
    Retorna una base aleàtoria
    Paràmetres:
       dimensio: Dimensió de l&#39;espai corresponent
       maxim: Nombre màxim de les components dels seus vectors
       unitaria: Si el determinant ha de ser 1 o -1
       mzeros: Nombre màxim de zeros entre les components dels seus vectors
    &#34;&#34;&#34;
    C = Matriu.invertible(ordre=dimensio,unitaria=unitaria,maxim=maxim,mzeros=mzeros)
    return cls(C.vectors_columna())</code></pre>
</details>
</dd>
<dt id="Algebra.Base.canonica"><code class="name flex">
<span>def <span class="ident">canonica</span></span>(<span>dimensio=3)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la base canònica</p>
<h2 id="parametres">Paràmetres</h2>
<p>dimensio: Dimensió de l'espai corresponent</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def canonica(cls,dimensio=3):
    &#34;&#34;&#34;
    Retorna la base canònica
    Paràmetres:
       dimensio: Dimensió de l&#39;espai corresponent
    &#34;&#34;&#34;
    C = Matriu(eye(dimensio))
    return cls(C.vectors_columna())</code></pre>
</details>
</dd>
<dt id="Algebra.Base.from_matriu"><code class="name flex">
<span>def <span class="ident">from_matriu</span></span>(<span>m)</span>
</code></dt>
<dd>
<div class="desc"><p>Crea una nova base a partir d'una matriu de la classe Matriu
Si la matriu no és quadrada o no té rang màxim, retorna None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_matriu(cls,m):
    &#34;&#34;&#34;
    Crea una nova base a partir d&#39;una matriu de la classe Matriu
    Si la matriu no és quadrada o no té rang màxim, retorna None
    &#34;&#34;&#34;
    if m.files != m.columnes:
        return None
    if m.rank() != m.columnes:
        return None
    return cls(m.vectors_columna())</code></pre>
</details>
</dd>
<dt id="Algebra.Base.ortogonal"><code class="name flex">
<span>def <span class="ident">ortogonal</span></span>(<span>ordre=3, maxim=5, unitaria=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna una base ortogonal "aleatòria"</p>
<h2 id="parametres">Paràmetres</h2>
<p>ordre: dimensió
maxim: màxim per a les components dels vectors de la base
unitaria: si és True, la base serà ortonormal</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def ortogonal(cls,ordre=3,maxim=5,unitaria=False):
    &#34;&#34;&#34;
    Retorna una base ortogonal &#34;aleatòria&#34;
    Paràmetres:
        ordre: dimensió
        maxim: màxim per a les components dels vectors de la base
        unitaria: si és True, la base serà ortonormal
    &#34;&#34;&#34;
    trobat = False
    while not trobat:
        m = Matriu.invertible(ordre=ordre,maxim=4,mzeros=0,unitaria=True)
        L = []
        for v in m.vectors_columna():
            a = Matriu.from_vectors_columna([v])
            L.append(a.matriu)
        Q = GramSchmidt(L)
        base = []
        for m in Q:
            m = Matriu(m)
            v = m.vectors_columna()[0]
            v.simplificar()
            base.append(v)
        m = 0
        for v in base:
            a = v.maxim()
            if a &gt; m:
                m = a
        trobat = m &lt;= maxim
    return cls(base,unitaria)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Algebra.Base.canvi_de_base_a_la_base"><code class="name flex">
<span>def <span class="ident">canvi_de_base_a_la_base</span></span>(<span>self, B, p1=1, p2=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna en format latex l'expressió del canvi de base de la base
actual a la base B</p>
<h2 id="parametres">Paràmetres</h2>
<p>p1: primes que s'escriuran a les components en la base actual
p2: primes que s'escriuran a les components en la base B</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def canvi_de_base_a_la_base(self,B,p1=1,p2=0):
    &#34;&#34;&#34;
    Retorna en format latex l&#39;expressió del canvi de base de la base
    actual a la base B
    Paràmetres:
        p1: primes que s&#39;escriuran a les components en la base actual
        p2: primes que s&#39;escriuran a les components en la base B
    &#34;&#34;&#34;
    if not isinstance(B,Base):
        return None
    if self.dimensio != B.dimensio:
        return None
    c = self.matriu()
    d = B.matriu()
    A = d.inversa() * c
    if self.dimensio &lt;= 4:
        x, y, z, t = symbols(&#39;x y z t&#39;)
        components = [x,y,z,t]
    else:
        x1, x2, x3, x4, x5, x6, x7, x8 = symbols(&#39;x1 x2 x3 x4 x5 x6 x7 x8&#39;)
        components = [x1,x2,x3,x4,x5,x6,x7,x8]
    components = components[0:self.dimensio]
    ps1 = &#34;&#34;
    ps2 = &#34;&#34;
    if p1 &gt; 0:
        ps1 = p1 * &#34;&#39;&#34;
    if p2 &gt; 0:
        ps2 = p2 * &#34;&#39;&#34;
    cself = &#34; \\\\ &#34;.join([latex(k) + ps1 for k in components])
    cB = &#34; \\\\ &#34;.join([latex(k) + ps2 for k in components])
    s = &#34;\\begin{pmatrix}{c} &#34; + cB + &#34;\\end{pmatrix} = \n&#34;
    s += f&#34;{A}\n&#34;
    s += &#34;\\begin{pmatrix}{c} &#34; + cself + &#34;\\end{pmatrix}&#34;
    return s</code></pre>
</details>
</dd>
<dt id="Algebra.Base.components_del_vector"><code class="name flex">
<span>def <span class="ident">components_del_vector</span></span>(<span>self, vec, base=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna un nou vector expressat en aquesta base del vector
que en la base "base" té components "vec"</p>
<h2 id="parametres">Paràmetres</h2>
<p>vec: components en la base "base"
base: Base</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def components_del_vector(self,vec,base=None):
    &#34;&#34;&#34;
    Retorna un nou vector expressat en aquesta base del vector
    que en la base &#34;base&#34; té components &#34;vec&#34;
    Paràmetres:
        vec: components en la base &#34;base&#34;
        base: Base
    &#34;&#34;&#34;
    if not isinstance(vec,Vector):
        return None
    if base is not None:
        if vec.dimensio != base.dimensio:
            return None
        uc = base.vector_de_components(vec)
    else:
        uc = vec
    c = self.matriu()
    return c.inversa() * uc</code></pre>
</details>
</dd>
<dt id="Algebra.Base.es_ortogonal"><code class="name flex">
<span>def <span class="ident">es_ortogonal</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna si la base és ortogonal</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def es_ortogonal(self):
    &#34;&#34;&#34;
    Retorna si la base és ortogonal
    &#34;&#34;&#34;
    d = len(self.vecs)
    for i in range(d):
        for j in range(i+1,d):
            if self.vecs[i].dot(self.vecs[j]) != 0:
                return False
    return True</code></pre>
</details>
</dd>
<dt id="Algebra.Base.es_unitaria"><code class="name flex">
<span>def <span class="ident">es_unitaria</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna si la base és unitària. Notem que els vectors no es guarden
com a unitaris.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def es_unitaria(self):
    &#34;&#34;&#34;
    Retorna si la base és unitària. Notem que els vectors no es guarden
    com a unitaris.
    &#34;&#34;&#34;
    return self.unitaria</code></pre>
</details>
</dd>
<dt id="Algebra.Base.matriu"><code class="name flex">
<span>def <span class="ident">matriu</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la matriu de la classe Matriu que té per columnes
els vectors de la base</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def matriu(self):
    &#34;&#34;&#34;
    Retorna la matriu de la classe Matriu que té per columnes
    els vectors de la base
    &#34;&#34;&#34;
    if not self.unitaria:
        return Matriu.from_vectors_columna(self.vecs)
    unitaris = [(1 / v.length()) * v for v in self.vecs]
    return Matriu.from_vectors_columna(unitaris)</code></pre>
</details>
</dd>
<dt id="Algebra.Base.orientacio_positiva"><code class="name flex">
<span>def <span class="ident">orientacio_positiva</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Fa que tingui orientació positiva canviant, si cal, de signe l'últim
vector</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def orientacio_positiva(self):
    &#34;&#34;&#34;
    Fa que tingui orientació positiva canviant, si cal, de signe l&#39;últim
    vector
    &#34;&#34;&#34;
    if not self.te_orientacio_positiva():
        self.vecs[-1] = - self.vecs[-1]</code></pre>
</details>
</dd>
<dt id="Algebra.Base.quadrats_longituds"><code class="name flex">
<span>def <span class="ident">quadrats_longituds</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna els quadrats de les longituds dels vectors de la base sense tenir
en compte si la base és unitària</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def quadrats_longituds(self):
    &#34;&#34;&#34;
    Retorna els quadrats de les longituds dels vectors de la base sense tenir
    en compte si la base és unitària
    &#34;&#34;&#34;
    return [v.length()**2 for v in self.vecs]</code></pre>
</details>
</dd>
<dt id="Algebra.Base.set_unitaria"><code class="name flex">
<span>def <span class="ident">set_unitaria</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Si la matriu és ortogonal, la passa a unitària</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_unitaria(self):
    &#34;&#34;&#34;
    Si la matriu és ortogonal, la passa a unitària
    &#34;&#34;&#34;
    if not self.es_ortogonal():
        return
    self.unitaria = True</code></pre>
</details>
</dd>
<dt id="Algebra.Base.te_orientacio_positiva"><code class="name flex">
<span>def <span class="ident">te_orientacio_positiva</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna si té orientació positiva</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def te_orientacio_positiva(self):
    &#34;&#34;&#34;
    Retorna si té orientació positiva
    &#34;&#34;&#34;
    m = Matriu.from_vectors_columna(self.vecs)
    return m.determinant() &gt; 0</code></pre>
</details>
</dd>
<dt id="Algebra.Base.vector_de_components"><code class="name flex">
<span>def <span class="ident">vector_de_components</span></span>(<span>self, vec)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna un nou vector expressat en la base canònica del vector
que en aquesta base té components "vec"</p>
<h2 id="parametres">Paràmetres</h2>
<p>vec: vector</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vector_de_components(self,vec):
    &#34;&#34;&#34;
    Retorna un nou vector expressat en la base canònica del vector
    que en aquesta base té components &#34;vec&#34;
    Paràmetres:
        vec: vector
    &#34;&#34;&#34;
    if not isinstance(vec,Vector):
        return None
    if vec.dimensio != self.dimensio:
        return None
    c = self.matriu()
    return c * vec</code></pre>
</details>
</dd>
<dt id="Algebra.Base.vectors"><code class="name flex">
<span>def <span class="ident">vectors</span></span>(<span>self, unitaris=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna els vectors la base</p>
<h2 id="parametres">Paràmetres</h2>
<p>unitaris: si és True, els divideix per la seva longitud</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vectors(self,unitaris=False):
    &#34;&#34;&#34;
    Retorna els vectors la base
    Paràmetres:
        unitaris: si és True, els divideix per la seva longitud
    &#34;&#34;&#34;
    if not unitaris:
        return self.vecs
    return [v/v.length() for v in self.vecs]</code></pre>
</details>
</dd>
<dt id="Algebra.Base.vectors_latex"><code class="name flex">
<span>def <span class="ident">vectors_latex</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna l'expressió en latex dels vector de la base, sense les claus
inicial i final</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vectors_latex(self):
    &#34;&#34;&#34;
    Retorna l&#39;expressió en latex dels vector de la base, sense les claus
    inicial i final
    &#34;&#34;&#34;
    if not self.unitaria:
        base = &#34;,&#34;.join(map(str,self.vecs))
    else:
        base = &#34;,&#34;.join([v.latex(unitari=True) for v in self.vecs])
    return f&#34;{base}&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Algebra.CilindreElliptic"><code class="flex name class">
<span>class <span class="ident">CilindreElliptic</span></span>
<span>(</span><span>a2, b2, centre, eix1, eix2)</span>
</code></dt>
<dd>
<div class="desc"><p>Classe per treballar amb cilindres el·líptics</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CilindreElliptic(Quadrica):
    &#34;&#34;&#34;
    Classe per treballar amb cilindres el·líptics
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,a2,b2,centre,eix1,eix2):
        &#34;&#34;&#34;
        Constructor.
        Paràmetres:
           a2, b2: semieixos al quadrat
           eix1: direcció de l&#39;eix principal (de les x&#39;)
           eix2: en pricipi és la direcció de l&#39;eix de les y&#39;, però si no és
                 perpendicular a eix1, es calcula el perpendicular que està
                 en el mateix pla vectorial que &lt;eix1,eix2&gt; aplicant el
                 mètode de Gram-Schmidt
        &#34;&#34;&#34;
        if not isinstance(centre,Punt):
            return None
        if not isinstance(eix1,Vector):
            return None
        if not isinstance(eix2,Vector):
            return None
        if centre.dimensio != 3:
            return None
        if eix1.dimensio != 3:
            return None
        if eix2.dimensio != 3:
            return None
        if eix1.length() == 0:
            return None
        if eix2.length() == 0:
            return None
        m = Matriu.from_vectors_columna([eix1,eix2])
        if m.rank() != 2:
            return None
        if a2 &lt;= 0:
            return None
        if b2 &lt;= 0:
            return None
        return super(Quadrica,cls).__new__(cls)
    #
    #
    #
    def __init__(self,a2,b2,centre,eix1,eix2):
        s = SubespaiVectorial([eix1,eix2])
        base = s.amplia_base(unitaria=True)
        r = ReferenciaAfi(centre,base)
        g = mcd_llista([a2,b2])
        t = a2 * b2 // g
        a2 = a2 // g
        b2 = b2 // g
        m = Matriu.diagonal(Vector([b2,a2,0,-t]))
        Quadrica.__init__(self,m,r)
    #
    #
    #
    @classmethod
    def aleatoria(cls,canonica=False):
        &#34;&#34;&#34;
        Retorna un cilindre el·líptic de manera aleatòria
        &#34;&#34;&#34;
        if canonica:
            v = [Vector(1,0,0),Vector(0,1,0),Vector(0,0,1)]
            random.shuffle(v)
            eix1, eix2, _ = v
        else:
            trobat = False
            while not trobat:
                eix1 = Vector.aleatori(l=3,maxim=3)
                eix2 = Vector.aleatori(l=3,maxim=3)
                if eix1.nzeros() &gt; 1 or eix2.nzeros() &gt; 1:
                    continue
                trobat = Matriu.from_vectors_columna([eix1,eix2]).rank() == 2
        trobat = False
        while not trobat:
            centre = Punt.aleatori(l=3,maxim=4,nuls=False)
            trobat = centre.length() &gt; 0
        c = [1,2,3,4,5,8,10,12,16,18,20,25,36]
        trobat = False
        while not trobat:
            a = random.randint(0,len(c) - 1)
            a2 = c[a]
            a = random.randint(0,len(c) - 1)
            b2 = c[a]
            trobat = a2 != b2
        a2, b2 = sorted([a2,b2])[::-1]
        return cls(a2,b2,centre,eix1,eix2)
    #
    #
    #
    def centre(self):
        &#34;&#34;&#34;
        Retorna un centre del cilindre el·líptic
        &#34;&#34;&#34;
        return (self.ref.origen)
    #
    #
    #
    def centres(self):
        &#34;&#34;&#34;
        Retorna la recta de centres
        &#34;&#34;&#34;
        return RectaAfi(self.ref.origen,self.ref.base[2])
    #
    #
    #
    def semieixos(self):
        &#34;&#34;&#34;
        Retorna els semieixos del cilindre el·líptic
        &#34;&#34;&#34;
        a = self.matriu[0,0]
        b = self.matriu[1,1]
        f = - self.matriu[3,3]
        return (sqrt(Rational(f,a)),sqrt(Rational(f,b)))
    #
    #
    #
    def semieixos_quadrats(self):
        &#34;&#34;&#34;
        Retorna els semieixos al quadrat del cilindre el·líptic
        &#34;&#34;&#34;
        a = self.matriu[0,0]
        b = self.matriu[1,1]
        f = - self.matriu[3,3]
        return (Rational(f,a),Rational(f,b))
    #
    #
    #
    def equacio_reduida(self):
        &#34;&#34;&#34;
        Retorna l&#39;equacio reduïda del cilindre el·líptic
        &#34;&#34;&#34;
        a2, b2 = self.semieixos_quadrats()
        if a2 == 1:
            str = &#34;x&#39;^2&#34;
        else:
            str = f&#34;\\frac{{x&#39;^2}}{{ {latex(a2)} }}&#34;
        if b2 == 1:
            str += &#34; + y&#39;^2 = 1&#34;
        else:
            str += f&#34; + \\frac{{y&#39;^2}}{{ {latex(b2)} }} = 1&#34;
        return str</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Algebra.Quadrica" href="#Algebra.Quadrica">Quadrica</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="Algebra.CilindreElliptic.aleatoria"><code class="name flex">
<span>def <span class="ident">aleatoria</span></span>(<span>canonica=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna un cilindre el·líptic de manera aleatòria</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def aleatoria(cls,canonica=False):
    &#34;&#34;&#34;
    Retorna un cilindre el·líptic de manera aleatòria
    &#34;&#34;&#34;
    if canonica:
        v = [Vector(1,0,0),Vector(0,1,0),Vector(0,0,1)]
        random.shuffle(v)
        eix1, eix2, _ = v
    else:
        trobat = False
        while not trobat:
            eix1 = Vector.aleatori(l=3,maxim=3)
            eix2 = Vector.aleatori(l=3,maxim=3)
            if eix1.nzeros() &gt; 1 or eix2.nzeros() &gt; 1:
                continue
            trobat = Matriu.from_vectors_columna([eix1,eix2]).rank() == 2
    trobat = False
    while not trobat:
        centre = Punt.aleatori(l=3,maxim=4,nuls=False)
        trobat = centre.length() &gt; 0
    c = [1,2,3,4,5,8,10,12,16,18,20,25,36]
    trobat = False
    while not trobat:
        a = random.randint(0,len(c) - 1)
        a2 = c[a]
        a = random.randint(0,len(c) - 1)
        b2 = c[a]
        trobat = a2 != b2
    a2, b2 = sorted([a2,b2])[::-1]
    return cls(a2,b2,centre,eix1,eix2)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Algebra.CilindreElliptic.centre"><code class="name flex">
<span>def <span class="ident">centre</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna un centre del cilindre el·líptic</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def centre(self):
    &#34;&#34;&#34;
    Retorna un centre del cilindre el·líptic
    &#34;&#34;&#34;
    return (self.ref.origen)</code></pre>
</details>
</dd>
<dt id="Algebra.CilindreElliptic.centres"><code class="name flex">
<span>def <span class="ident">centres</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la recta de centres</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def centres(self):
    &#34;&#34;&#34;
    Retorna la recta de centres
    &#34;&#34;&#34;
    return RectaAfi(self.ref.origen,self.ref.base[2])</code></pre>
</details>
</dd>
<dt id="Algebra.CilindreElliptic.equacio_reduida"><code class="name flex">
<span>def <span class="ident">equacio_reduida</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna l'equacio reduïda del cilindre el·líptic</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def equacio_reduida(self):
    &#34;&#34;&#34;
    Retorna l&#39;equacio reduïda del cilindre el·líptic
    &#34;&#34;&#34;
    a2, b2 = self.semieixos_quadrats()
    if a2 == 1:
        str = &#34;x&#39;^2&#34;
    else:
        str = f&#34;\\frac{{x&#39;^2}}{{ {latex(a2)} }}&#34;
    if b2 == 1:
        str += &#34; + y&#39;^2 = 1&#34;
    else:
        str += f&#34; + \\frac{{y&#39;^2}}{{ {latex(b2)} }} = 1&#34;
    return str</code></pre>
</details>
</dd>
<dt id="Algebra.CilindreElliptic.semieixos"><code class="name flex">
<span>def <span class="ident">semieixos</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna els semieixos del cilindre el·líptic</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def semieixos(self):
    &#34;&#34;&#34;
    Retorna els semieixos del cilindre el·líptic
    &#34;&#34;&#34;
    a = self.matriu[0,0]
    b = self.matriu[1,1]
    f = - self.matriu[3,3]
    return (sqrt(Rational(f,a)),sqrt(Rational(f,b)))</code></pre>
</details>
</dd>
<dt id="Algebra.CilindreElliptic.semieixos_quadrats"><code class="name flex">
<span>def <span class="ident">semieixos_quadrats</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna els semieixos al quadrat del cilindre el·líptic</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def semieixos_quadrats(self):
    &#34;&#34;&#34;
    Retorna els semieixos al quadrat del cilindre el·líptic
    &#34;&#34;&#34;
    a = self.matriu[0,0]
    b = self.matriu[1,1]
    f = - self.matriu[3,3]
    return (Rational(f,a),Rational(f,b))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Algebra.Quadrica" href="#Algebra.Quadrica">Quadrica</a></b></code>:
<ul class="hlist">
<li><code><a title="Algebra.Quadrica.cilindreelliptic" href="#Algebra.Quadrica.cilindreelliptic">cilindreelliptic</a></code></li>
<li><code><a title="Algebra.Quadrica.cilindrehiperbolic" href="#Algebra.Quadrica.cilindrehiperbolic">cilindrehiperbolic</a></code></li>
<li><code><a title="Algebra.Quadrica.cilindreparabolic" href="#Algebra.Quadrica.cilindreparabolic">cilindreparabolic</a></code></li>
<li><code><a title="Algebra.Quadrica.con" href="#Algebra.Quadrica.con">con</a></code></li>
<li><code><a title="Algebra.Quadrica.ellipsoide" href="#Algebra.Quadrica.ellipsoide">ellipsoide</a></code></li>
<li><code><a title="Algebra.Quadrica.equacio" href="#Algebra.Quadrica.equacio">equacio</a></code></li>
<li><code><a title="Algebra.Quadrica.from_equacio" href="#Algebra.Quadrica.from_equacio">from_equacio</a></code></li>
<li><code><a title="Algebra.Quadrica.hiperboloideduesfulles" href="#Algebra.Quadrica.hiperboloideduesfulles">hiperboloideduesfulles</a></code></li>
<li><code><a title="Algebra.Quadrica.hiperboloideunafulla" href="#Algebra.Quadrica.hiperboloideunafulla">hiperboloideunafulla</a></code></li>
<li><code><a title="Algebra.Quadrica.paraboloideelliptic" href="#Algebra.Quadrica.paraboloideelliptic">paraboloideelliptic</a></code></li>
<li><code><a title="Algebra.Quadrica.paraboloidehiperbolic" href="#Algebra.Quadrica.paraboloidehiperbolic">paraboloidehiperbolic</a></code></li>
<li><code><a title="Algebra.Quadrica.referencia_principal" href="#Algebra.Quadrica.referencia_principal">referencia_principal</a></code></li>
<li><code><a title="Algebra.Quadrica.tipus" href="#Algebra.Quadrica.tipus">tipus</a></code></li>
<li><code><a title="Algebra.Quadrica.vectors" href="#Algebra.Quadrica.vectors">vectors</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Algebra.CilindreHiperbolic"><code class="flex name class">
<span>class <span class="ident">CilindreHiperbolic</span></span>
<span>(</span><span>a2, b2, centre, eix1, eix2)</span>
</code></dt>
<dd>
<div class="desc"><p>Classe per treballar amb cilindres hiperbòlic</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CilindreHiperbolic(Quadrica):
    &#34;&#34;&#34;
    Classe per treballar amb cilindres hiperbòlic
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,a2,b2,centre,eix1,eix2):
        &#34;&#34;&#34;
        Constructor.
        Paràmetres:
           a2, b2: semieixos al quadrat
           eix1: direcció de l&#39;eix principal (de les x&#39;)
           eix2: en pricipi és la direcció de l&#39;eix de les y&#39;, però si no és
                 perpendicular a eix1, es calcula el perpendicular que està
                 en el mateix pla vectorial que &lt;eix1,eix2&gt; aplicant el
                 mètode de Gram-Schmidt
        &#34;&#34;&#34;
        if not isinstance(centre,Punt):
            return None
        if not isinstance(eix1,Vector):
            return None
        if not isinstance(eix2,Vector):
            return None
        if centre.dimensio != 3:
            return None
        if eix1.dimensio != 3:
            return None
        if eix2.dimensio != 3:
            return None
        if eix1.length() == 0:
            return None
        if eix2.length() == 0:
            return None
        m = Matriu.from_vectors_columna([eix1,eix2])
        if m.rank() != 2:
            return None
        if a2 &lt;= 0:
            return None
        if b2 &lt;= 0:
            return None
        return super(Quadrica,cls).__new__(cls)
    #
    #
    #
    def __init__(self,a2,b2,centre,eix1,eix2):
        s = SubespaiVectorial([eix1,eix2])
        base = s.amplia_base(unitaria=True)
        r = ReferenciaAfi(centre,base)
        g = mcd_llista([a2,b2])
        t = a2 * b2 // g
        a2 = a2 // g
        b2 = b2 // g
        m = Matriu.diagonal(Vector([b2,-a2,0,-t]))
        Quadrica.__init__(self,m,r)
    #
    #
    #
    @classmethod
    def aleatoria(cls,canonica=False):
        &#34;&#34;&#34;
        Retorna un cilindre hiperbòlic de manera aleatòria
        &#34;&#34;&#34;
        if canonica:
            v = [Vector(1,0,0),Vector(0,1,0),Vector(0,0,1)]
            random.shuffle(v)
            eix1, eix2, _ = v
        else:
            trobat = False
            while not trobat:
                eix1 = Vector.aleatori(l=3,maxim=3)
                eix2 = Vector.aleatori(l=3,maxim=3)
                if eix1.nzeros() &gt; 1 or eix2.nzeros() &gt; 1:
                    continue
                trobat = Matriu.from_vectors_columna([eix1,eix2]).rank() == 2
        trobat = False
        while not trobat:
            centre = Punt.aleatori(l=3,maxim=4,nuls=False)
            trobat = centre.length() &gt; 0
        c = [1,2,3,4,5,8,10,12,16,18,20,25,36,40,45,48,50,60]
        trobat = False
        while not trobat:
            a = random.randint(0,len(c) - 1)
            a2 = c[a]
            a = random.randint(0,len(c) - 1)
            b2 = c[a]
            trobat = a2 != b2
        return cls(a2,b2,centre,eix1,eix2)
    #
    #
    #
    def centre(self):
        &#34;&#34;&#34;
        Retorna un centre del cilindre hiperbòlic
        &#34;&#34;&#34;
        return (self.ref.origen)
    #
    #
    #
    def centres(self):
        &#34;&#34;&#34;
        Retorna la recta de centres
        &#34;&#34;&#34;
        return RectaAfi(self.ref.origen,self.ref.base[2])
    #
    #
    #
    def semieixos(self):
        &#34;&#34;&#34;
        Retorna els semieixos del cilindre hiperbòlic
        &#34;&#34;&#34;
        a = self.matriu[0,0]
        b = - self.matriu[1,1]
        f = - self.matriu[3,3]
        return (sqrt(Rational(f,a)),sqrt(Rational(f,b)))
    #
    #
    #
    def semieixos_quadrats(self):
        &#34;&#34;&#34;
        Retorna els semieixos al quadrat del cilindre hiperbòlic
        &#34;&#34;&#34;
        a = self.matriu[0,0]
        b = - self.matriu[1,1]
        f = - self.matriu[3,3]
        return (Rational(f,a),Rational(f,b))
    #
    #
    #
    def equacio_reduida(self):
        &#34;&#34;&#34;
        Retorna l&#39;equacio reduïda del cilindre hiperbòlic
        &#34;&#34;&#34;
        a2, b2 = self.semieixos_quadrats()
        if a2 == 1:
            str = &#34;x&#39;^2&#34;
        else:
            str = f&#34;\\frac{{x&#39;^2}}{{ {latex(a2)} }}&#34;
        if b2 == 1:
            str += &#34; - y&#39;^2 = 1&#34;
        else:
            str += f&#34; - \\frac{{y&#39;^2}}{{ {latex(b2)} }} = 1&#34;
        return str</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Algebra.Quadrica" href="#Algebra.Quadrica">Quadrica</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="Algebra.CilindreHiperbolic.aleatoria"><code class="name flex">
<span>def <span class="ident">aleatoria</span></span>(<span>canonica=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna un cilindre hiperbòlic de manera aleatòria</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def aleatoria(cls,canonica=False):
    &#34;&#34;&#34;
    Retorna un cilindre hiperbòlic de manera aleatòria
    &#34;&#34;&#34;
    if canonica:
        v = [Vector(1,0,0),Vector(0,1,0),Vector(0,0,1)]
        random.shuffle(v)
        eix1, eix2, _ = v
    else:
        trobat = False
        while not trobat:
            eix1 = Vector.aleatori(l=3,maxim=3)
            eix2 = Vector.aleatori(l=3,maxim=3)
            if eix1.nzeros() &gt; 1 or eix2.nzeros() &gt; 1:
                continue
            trobat = Matriu.from_vectors_columna([eix1,eix2]).rank() == 2
    trobat = False
    while not trobat:
        centre = Punt.aleatori(l=3,maxim=4,nuls=False)
        trobat = centre.length() &gt; 0
    c = [1,2,3,4,5,8,10,12,16,18,20,25,36,40,45,48,50,60]
    trobat = False
    while not trobat:
        a = random.randint(0,len(c) - 1)
        a2 = c[a]
        a = random.randint(0,len(c) - 1)
        b2 = c[a]
        trobat = a2 != b2
    return cls(a2,b2,centre,eix1,eix2)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Algebra.CilindreHiperbolic.centre"><code class="name flex">
<span>def <span class="ident">centre</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna un centre del cilindre hiperbòlic</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def centre(self):
    &#34;&#34;&#34;
    Retorna un centre del cilindre hiperbòlic
    &#34;&#34;&#34;
    return (self.ref.origen)</code></pre>
</details>
</dd>
<dt id="Algebra.CilindreHiperbolic.centres"><code class="name flex">
<span>def <span class="ident">centres</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la recta de centres</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def centres(self):
    &#34;&#34;&#34;
    Retorna la recta de centres
    &#34;&#34;&#34;
    return RectaAfi(self.ref.origen,self.ref.base[2])</code></pre>
</details>
</dd>
<dt id="Algebra.CilindreHiperbolic.equacio_reduida"><code class="name flex">
<span>def <span class="ident">equacio_reduida</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna l'equacio reduïda del cilindre hiperbòlic</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def equacio_reduida(self):
    &#34;&#34;&#34;
    Retorna l&#39;equacio reduïda del cilindre hiperbòlic
    &#34;&#34;&#34;
    a2, b2 = self.semieixos_quadrats()
    if a2 == 1:
        str = &#34;x&#39;^2&#34;
    else:
        str = f&#34;\\frac{{x&#39;^2}}{{ {latex(a2)} }}&#34;
    if b2 == 1:
        str += &#34; - y&#39;^2 = 1&#34;
    else:
        str += f&#34; - \\frac{{y&#39;^2}}{{ {latex(b2)} }} = 1&#34;
    return str</code></pre>
</details>
</dd>
<dt id="Algebra.CilindreHiperbolic.semieixos"><code class="name flex">
<span>def <span class="ident">semieixos</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna els semieixos del cilindre hiperbòlic</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def semieixos(self):
    &#34;&#34;&#34;
    Retorna els semieixos del cilindre hiperbòlic
    &#34;&#34;&#34;
    a = self.matriu[0,0]
    b = - self.matriu[1,1]
    f = - self.matriu[3,3]
    return (sqrt(Rational(f,a)),sqrt(Rational(f,b)))</code></pre>
</details>
</dd>
<dt id="Algebra.CilindreHiperbolic.semieixos_quadrats"><code class="name flex">
<span>def <span class="ident">semieixos_quadrats</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna els semieixos al quadrat del cilindre hiperbòlic</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def semieixos_quadrats(self):
    &#34;&#34;&#34;
    Retorna els semieixos al quadrat del cilindre hiperbòlic
    &#34;&#34;&#34;
    a = self.matriu[0,0]
    b = - self.matriu[1,1]
    f = - self.matriu[3,3]
    return (Rational(f,a),Rational(f,b))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Algebra.Quadrica" href="#Algebra.Quadrica">Quadrica</a></b></code>:
<ul class="hlist">
<li><code><a title="Algebra.Quadrica.cilindreelliptic" href="#Algebra.Quadrica.cilindreelliptic">cilindreelliptic</a></code></li>
<li><code><a title="Algebra.Quadrica.cilindrehiperbolic" href="#Algebra.Quadrica.cilindrehiperbolic">cilindrehiperbolic</a></code></li>
<li><code><a title="Algebra.Quadrica.cilindreparabolic" href="#Algebra.Quadrica.cilindreparabolic">cilindreparabolic</a></code></li>
<li><code><a title="Algebra.Quadrica.con" href="#Algebra.Quadrica.con">con</a></code></li>
<li><code><a title="Algebra.Quadrica.ellipsoide" href="#Algebra.Quadrica.ellipsoide">ellipsoide</a></code></li>
<li><code><a title="Algebra.Quadrica.equacio" href="#Algebra.Quadrica.equacio">equacio</a></code></li>
<li><code><a title="Algebra.Quadrica.from_equacio" href="#Algebra.Quadrica.from_equacio">from_equacio</a></code></li>
<li><code><a title="Algebra.Quadrica.hiperboloideduesfulles" href="#Algebra.Quadrica.hiperboloideduesfulles">hiperboloideduesfulles</a></code></li>
<li><code><a title="Algebra.Quadrica.hiperboloideunafulla" href="#Algebra.Quadrica.hiperboloideunafulla">hiperboloideunafulla</a></code></li>
<li><code><a title="Algebra.Quadrica.paraboloideelliptic" href="#Algebra.Quadrica.paraboloideelliptic">paraboloideelliptic</a></code></li>
<li><code><a title="Algebra.Quadrica.paraboloidehiperbolic" href="#Algebra.Quadrica.paraboloidehiperbolic">paraboloidehiperbolic</a></code></li>
<li><code><a title="Algebra.Quadrica.referencia_principal" href="#Algebra.Quadrica.referencia_principal">referencia_principal</a></code></li>
<li><code><a title="Algebra.Quadrica.tipus" href="#Algebra.Quadrica.tipus">tipus</a></code></li>
<li><code><a title="Algebra.Quadrica.vectors" href="#Algebra.Quadrica.vectors">vectors</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Algebra.CilindreParabolic"><code class="flex name class">
<span>class <span class="ident">CilindreParabolic</span></span>
<span>(</span><span>p, vertex, eix1, eix2=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Classe per treballar amb cilindres parabòlics</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CilindreParabolic(Quadrica):
    &#34;&#34;&#34;
    Classe per treballar amb cilindres parabòlics
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,p,vertex,eix1,eix2=None):
        &#34;&#34;&#34;
        Constructor.
        Retorna el cilindre parabòlic amb vèrtex &#34;vertex&#34;, eix de les x&#39; amb
        direcció &#34;eix&#34;, eix de les y&#39; amb direcció &#34;eix2&#34; i paràmetre de
        la paràbola &#34;p&#34;
        Paràmetres:
           p: paràmetre de l&#39;equació reduïda z&#39; = \\frac{x&#39;^2}{2 * p}
           vertex: un vèrtex del cilindre parabòlic
           eix1: direcció de l&#39;eix de les x&#39;
           eix2: direcció de l&#39;eix de les y&#39;. Si és None, el tria el programa
        &#34;&#34;&#34;
        if not isinstance(vertex,Punt):
            return None
        if not isinstance(eix1,Vector):
            return None
        if vertex.dimensio != 3:
            return None
        if eix1.dimensio != 3:
            return None
        if eix1.nzeros() &gt;= 2:
            return None
        if p == 0:
            return None
        if eix2 is not None:
            if not isinstance(eix2,Vector):
                return None
            if eix2.dimensio != 3:
                return None
            w = eix1.cross(eix2,simplificar=True)
            if w.length() == 0:
                return None
        return super(Quadrica,cls).__new__(cls)
    #
    #
    #
    def __init__(self,p,vertex,eix1,eix2=None):
        if eix2 is None:
            s = SubespaiVectorial([eix1])
        else:
            s = SubespaiVectorial([eix1,eix2])
        base = s.amplia_base(unitaria=True)
        r = ReferenciaAfi(vertex,base)
        m = Matriu(Matrix([[1,0,0,0],[0,0,0,0],[0,0,0,-p],[0,0,-p,0]]))
        Quadrica.__init__(self,m,r)
    #
    #
    #
    @classmethod
    def aleatoria(cls,canonica=False):
        &#34;&#34;&#34;
        Retorna un cilindre parabòlic de manera aleatòria
        &#34;&#34;&#34;
        vertex = Punt.aleatori(l=3,maxim=4,nuls=False)
        trobat = False
        while not trobat:
            eix = Vector.aleatori(l=3,maxim=3)
            trobat = eix.nzeros() &lt; 2 and eix.length() &lt; 12
        s = SubespaiVectorial([eix])
        base = s.amplia_base(unitaria=True)
        if canonica:
            v = [Vector(1,0,0),Vector(0,1,0),Vector(0,0,1)]
            random.shuffle(v)
            base = Base(v)
        q = base.quadrats_longituds()
        c = [k for k in range(1,3)] + [-k for k in range(1,3)]
        c += [Rational(1,k) for k in range(1,4)] + [-Rational(1,k) for k in range(1,4)]
        a = random.randint(0,len(c) - 1)
        p = 2 * c[a] * sqrt(q[2])
        return cls(p,vertex,eix)
    #
    #
    #
    def parametre(self):
        &#34;&#34;&#34;
        Retorna el paràmetre de la paràbola
        &#34;&#34;&#34;
        return - self.matriu[2,3]
    #
    #
    #
    def vertex(self):
        &#34;&#34;&#34;
            Retorna l&#39;origen de la referència principal
        &#34;&#34;&#34;
        return (self.ref.origen)
    #
    #
    #
    def equacio_reduida(self):
        &#34;&#34;&#34;
        Retorna l&#39;equacio reduïda del cilindre parabòlic
        &#34;&#34;&#34;
        p = self.parametre()
        if 2 * p == 1:
            return f&#34;z&#39; = x&#39;^2&#34;
        if 2 * p == -1:
            return f&#34;z&#39; = - x&#39;^2&#34;
        if p &gt; 0:
            return f&#34;z&#39; = \\frac{{x&#39;^2}}{{ {latex(2 * p)} }}&#34;
        return f&#34;z&#39; = -\\frac{{x&#39;^2}}{{ {latex(-2 * p)} }}&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Algebra.Quadrica" href="#Algebra.Quadrica">Quadrica</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="Algebra.CilindreParabolic.aleatoria"><code class="name flex">
<span>def <span class="ident">aleatoria</span></span>(<span>canonica=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna un cilindre parabòlic de manera aleatòria</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def aleatoria(cls,canonica=False):
    &#34;&#34;&#34;
    Retorna un cilindre parabòlic de manera aleatòria
    &#34;&#34;&#34;
    vertex = Punt.aleatori(l=3,maxim=4,nuls=False)
    trobat = False
    while not trobat:
        eix = Vector.aleatori(l=3,maxim=3)
        trobat = eix.nzeros() &lt; 2 and eix.length() &lt; 12
    s = SubespaiVectorial([eix])
    base = s.amplia_base(unitaria=True)
    if canonica:
        v = [Vector(1,0,0),Vector(0,1,0),Vector(0,0,1)]
        random.shuffle(v)
        base = Base(v)
    q = base.quadrats_longituds()
    c = [k for k in range(1,3)] + [-k for k in range(1,3)]
    c += [Rational(1,k) for k in range(1,4)] + [-Rational(1,k) for k in range(1,4)]
    a = random.randint(0,len(c) - 1)
    p = 2 * c[a] * sqrt(q[2])
    return cls(p,vertex,eix)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Algebra.CilindreParabolic.equacio_reduida"><code class="name flex">
<span>def <span class="ident">equacio_reduida</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna l'equacio reduïda del cilindre parabòlic</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def equacio_reduida(self):
    &#34;&#34;&#34;
    Retorna l&#39;equacio reduïda del cilindre parabòlic
    &#34;&#34;&#34;
    p = self.parametre()
    if 2 * p == 1:
        return f&#34;z&#39; = x&#39;^2&#34;
    if 2 * p == -1:
        return f&#34;z&#39; = - x&#39;^2&#34;
    if p &gt; 0:
        return f&#34;z&#39; = \\frac{{x&#39;^2}}{{ {latex(2 * p)} }}&#34;
    return f&#34;z&#39; = -\\frac{{x&#39;^2}}{{ {latex(-2 * p)} }}&#34;</code></pre>
</details>
</dd>
<dt id="Algebra.CilindreParabolic.parametre"><code class="name flex">
<span>def <span class="ident">parametre</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el paràmetre de la paràbola</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parametre(self):
    &#34;&#34;&#34;
    Retorna el paràmetre de la paràbola
    &#34;&#34;&#34;
    return - self.matriu[2,3]</code></pre>
</details>
</dd>
<dt id="Algebra.CilindreParabolic.vertex"><code class="name flex">
<span>def <span class="ident">vertex</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna l'origen de la referència principal</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertex(self):
    &#34;&#34;&#34;
        Retorna l&#39;origen de la referència principal
    &#34;&#34;&#34;
    return (self.ref.origen)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Algebra.Quadrica" href="#Algebra.Quadrica">Quadrica</a></b></code>:
<ul class="hlist">
<li><code><a title="Algebra.Quadrica.cilindreelliptic" href="#Algebra.Quadrica.cilindreelliptic">cilindreelliptic</a></code></li>
<li><code><a title="Algebra.Quadrica.cilindrehiperbolic" href="#Algebra.Quadrica.cilindrehiperbolic">cilindrehiperbolic</a></code></li>
<li><code><a title="Algebra.Quadrica.cilindreparabolic" href="#Algebra.Quadrica.cilindreparabolic">cilindreparabolic</a></code></li>
<li><code><a title="Algebra.Quadrica.con" href="#Algebra.Quadrica.con">con</a></code></li>
<li><code><a title="Algebra.Quadrica.ellipsoide" href="#Algebra.Quadrica.ellipsoide">ellipsoide</a></code></li>
<li><code><a title="Algebra.Quadrica.equacio" href="#Algebra.Quadrica.equacio">equacio</a></code></li>
<li><code><a title="Algebra.Quadrica.from_equacio" href="#Algebra.Quadrica.from_equacio">from_equacio</a></code></li>
<li><code><a title="Algebra.Quadrica.hiperboloideduesfulles" href="#Algebra.Quadrica.hiperboloideduesfulles">hiperboloideduesfulles</a></code></li>
<li><code><a title="Algebra.Quadrica.hiperboloideunafulla" href="#Algebra.Quadrica.hiperboloideunafulla">hiperboloideunafulla</a></code></li>
<li><code><a title="Algebra.Quadrica.paraboloideelliptic" href="#Algebra.Quadrica.paraboloideelliptic">paraboloideelliptic</a></code></li>
<li><code><a title="Algebra.Quadrica.paraboloidehiperbolic" href="#Algebra.Quadrica.paraboloidehiperbolic">paraboloidehiperbolic</a></code></li>
<li><code><a title="Algebra.Quadrica.referencia_principal" href="#Algebra.Quadrica.referencia_principal">referencia_principal</a></code></li>
<li><code><a title="Algebra.Quadrica.tipus" href="#Algebra.Quadrica.tipus">tipus</a></code></li>
<li><code><a title="Algebra.Quadrica.vectors" href="#Algebra.Quadrica.vectors">vectors</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Algebra.Con"><code class="flex name class">
<span>class <span class="ident">Con</span></span>
<span>(</span><span>a2, b2, c2, centre, eix1, eix2)</span>
</code></dt>
<dd>
<div class="desc"><p>Classe per treballar amb cons</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Con(Quadrica):
    &#34;&#34;&#34;
    Classe per treballar amb cons
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,a2,b2,c2,centre,eix1,eix2):
        &#34;&#34;&#34;
        Constructor.
        Retorna un Con
        Paràmetres:
           a2, b2, c2: semieixos al quadrat
           eix1: direcció de l&#39;eix principal (de les x&#39;)
           eix2: en pricipi és la direcció de l&#39;eix de les y&#39;, però si no és
                 perpendicular a eix1, es calcula el perpendicular que està
                 en el mateix pla vectorial que &lt;eix1,eix2&gt; aplicant el
                 mètode de Gram-Schmidt
        &#34;&#34;&#34;
        if not isinstance(centre,Punt):
            return None
        if not isinstance(eix1,Vector):
            return None
        if not isinstance(eix2,Vector):
            return None
        if centre.dimensio != 3:
            return None
        if eix1.dimensio != 3:
            return None
        if eix2.dimensio != 3:
            return None
        if eix1.length() == 0:
            return None
        if eix2.length() == 0:
            return None
        m = Matriu.from_vectors_columna([eix1,eix2])
        if m.rank() != 2:
            return None
        if a2 &lt;= 0:
            return None
        if b2 &lt;= 0:
            return None
        if c2 &lt;= 0:
            return None
        return super(Quadrica,cls).__new__(cls)
    #
    #
    #
    def __init__(self,a2,b2,c2,centre,eix1,eix2):
        s = SubespaiVectorial([eix1,eix2])
        base = s.amplia_base(unitaria=True)
        r = ReferenciaAfi(centre,base)
        g = mcm_llista([a2,b2,c2])
        a2 = g // a2
        b2 = g // b2
        c2 = g // c2
        m = Matriu.diagonal(Vector([a2,b2,-c2,0]))
        Quadrica.__init__(self,m,r)
    #
    #
    #
    @classmethod
    def aleatoria(cls,canonica=False):
        &#34;&#34;&#34;
        Retorna un hiperboloide de dues fulles de manera aleatòria aleatòria
        &#34;&#34;&#34;
        if canonica:
            v = [Vector(1,0,0),Vector(0,1,0),Vector(0,0,1)]
            random.shuffle(v)
            eix1, eix2, _ = v
        else:
            trobat = False
            while not trobat:
                eix1 = Vector.aleatori(l=3,maxim=3)
                eix2 = Vector.aleatori(l=3,maxim=3)
                if eix1.nzeros() &gt; 1 or eix2.nzeros() &gt; 1:
                    continue
                trobat = Matriu.from_vectors_columna([eix1,eix2]).rank() == 2
        trobat = False
        while not trobat:
            centre = Punt.aleatori(l=3,maxim=4,nuls=False)
            trobat = centre.length() &gt; 0
        c = [1,2,3,4,5,8,10,12,16,18,20,25,36]
        trobat = False
        while not trobat:
            a = random.randint(0,len(c) - 1)
            a2 = c[a]
            a = random.randint(0,len(c) - 1)
            b2 = c[a]
            a = random.randint(0,len(c) - 1)
            c2 = c[a]
            trobat = a2 != b2 or a2 != c2
        a2, b2 = sorted([a2,b2])[::-1]
        return cls(a2,b2,c2,centre,eix1,eix2)
    #
    #
    #
    def centre(self):
        &#34;&#34;&#34;
        Retorna el centre o vèrtex del con
        &#34;&#34;&#34;
        return (self.ref.origen)
    #
    #
    #
    def semieixos(self):
        &#34;&#34;&#34;
        Retorna els semieixos del con
        &#34;&#34;&#34;
        a = self.matriu[0,0]
        b = self.matriu[1,1]
        c = - self.matriu[2,2]
        m = mcm_llista([a,b,c])
        return (sqrt(Rational(m,a)),sqrt(Rational(m,b)),sqrt(Rational(m,c)))
    #
    #
    #
    def semieixos_quadrats(self):
        &#34;&#34;&#34;
        Retorna els semieixos al quadrat del con
        &#34;&#34;&#34;
        a = self.matriu[0,0]
        b = self.matriu[1,1]
        c = - self.matriu[2,2]
        m = mcm_llista([a,b,c])
        return (Rational(m,a),Rational(m,b),Rational(m,c))
    #
    #
    #
    def equacio_reduida(self):
        &#34;&#34;&#34;
        Retorna l&#39;equacio reduïda del con
        &#34;&#34;&#34;
        a2, b2, c2 = self.semieixos_quadrats()
        if a2 == 1:
            str = &#34;x&#39;^2&#34;
        else:
            str = f&#34;\\frac{{x&#39;^2}}{{ {latex(a2)} }}&#34;
        if b2 == 1:
            str += &#34; + y&#39;^2&#34;
        else:
            str += f&#34; + \\frac{{y&#39;^2}}{{ {latex(b2)} }}&#34;
        if c2 == 1:
            str += &#34; - z&#39;^2 = 0&#34;
        else:
            str += f&#34; - \\frac{{z&#39;^2}}{{ {latex(c2)} }} = 0&#34;
        return str</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Algebra.Quadrica" href="#Algebra.Quadrica">Quadrica</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="Algebra.Con.aleatoria"><code class="name flex">
<span>def <span class="ident">aleatoria</span></span>(<span>canonica=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna un hiperboloide de dues fulles de manera aleatòria aleatòria</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def aleatoria(cls,canonica=False):
    &#34;&#34;&#34;
    Retorna un hiperboloide de dues fulles de manera aleatòria aleatòria
    &#34;&#34;&#34;
    if canonica:
        v = [Vector(1,0,0),Vector(0,1,0),Vector(0,0,1)]
        random.shuffle(v)
        eix1, eix2, _ = v
    else:
        trobat = False
        while not trobat:
            eix1 = Vector.aleatori(l=3,maxim=3)
            eix2 = Vector.aleatori(l=3,maxim=3)
            if eix1.nzeros() &gt; 1 or eix2.nzeros() &gt; 1:
                continue
            trobat = Matriu.from_vectors_columna([eix1,eix2]).rank() == 2
    trobat = False
    while not trobat:
        centre = Punt.aleatori(l=3,maxim=4,nuls=False)
        trobat = centre.length() &gt; 0
    c = [1,2,3,4,5,8,10,12,16,18,20,25,36]
    trobat = False
    while not trobat:
        a = random.randint(0,len(c) - 1)
        a2 = c[a]
        a = random.randint(0,len(c) - 1)
        b2 = c[a]
        a = random.randint(0,len(c) - 1)
        c2 = c[a]
        trobat = a2 != b2 or a2 != c2
    a2, b2 = sorted([a2,b2])[::-1]
    return cls(a2,b2,c2,centre,eix1,eix2)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Algebra.Con.centre"><code class="name flex">
<span>def <span class="ident">centre</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el centre o vèrtex del con</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def centre(self):
    &#34;&#34;&#34;
    Retorna el centre o vèrtex del con
    &#34;&#34;&#34;
    return (self.ref.origen)</code></pre>
</details>
</dd>
<dt id="Algebra.Con.equacio_reduida"><code class="name flex">
<span>def <span class="ident">equacio_reduida</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna l'equacio reduïda del con</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def equacio_reduida(self):
    &#34;&#34;&#34;
    Retorna l&#39;equacio reduïda del con
    &#34;&#34;&#34;
    a2, b2, c2 = self.semieixos_quadrats()
    if a2 == 1:
        str = &#34;x&#39;^2&#34;
    else:
        str = f&#34;\\frac{{x&#39;^2}}{{ {latex(a2)} }}&#34;
    if b2 == 1:
        str += &#34; + y&#39;^2&#34;
    else:
        str += f&#34; + \\frac{{y&#39;^2}}{{ {latex(b2)} }}&#34;
    if c2 == 1:
        str += &#34; - z&#39;^2 = 0&#34;
    else:
        str += f&#34; - \\frac{{z&#39;^2}}{{ {latex(c2)} }} = 0&#34;
    return str</code></pre>
</details>
</dd>
<dt id="Algebra.Con.semieixos"><code class="name flex">
<span>def <span class="ident">semieixos</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna els semieixos del con</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def semieixos(self):
    &#34;&#34;&#34;
    Retorna els semieixos del con
    &#34;&#34;&#34;
    a = self.matriu[0,0]
    b = self.matriu[1,1]
    c = - self.matriu[2,2]
    m = mcm_llista([a,b,c])
    return (sqrt(Rational(m,a)),sqrt(Rational(m,b)),sqrt(Rational(m,c)))</code></pre>
</details>
</dd>
<dt id="Algebra.Con.semieixos_quadrats"><code class="name flex">
<span>def <span class="ident">semieixos_quadrats</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna els semieixos al quadrat del con</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def semieixos_quadrats(self):
    &#34;&#34;&#34;
    Retorna els semieixos al quadrat del con
    &#34;&#34;&#34;
    a = self.matriu[0,0]
    b = self.matriu[1,1]
    c = - self.matriu[2,2]
    m = mcm_llista([a,b,c])
    return (Rational(m,a),Rational(m,b),Rational(m,c))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Algebra.Quadrica" href="#Algebra.Quadrica">Quadrica</a></b></code>:
<ul class="hlist">
<li><code><a title="Algebra.Quadrica.cilindreelliptic" href="#Algebra.Quadrica.cilindreelliptic">cilindreelliptic</a></code></li>
<li><code><a title="Algebra.Quadrica.cilindrehiperbolic" href="#Algebra.Quadrica.cilindrehiperbolic">cilindrehiperbolic</a></code></li>
<li><code><a title="Algebra.Quadrica.cilindreparabolic" href="#Algebra.Quadrica.cilindreparabolic">cilindreparabolic</a></code></li>
<li><code><a title="Algebra.Quadrica.con" href="#Algebra.Quadrica.con">con</a></code></li>
<li><code><a title="Algebra.Quadrica.ellipsoide" href="#Algebra.Quadrica.ellipsoide">ellipsoide</a></code></li>
<li><code><a title="Algebra.Quadrica.equacio" href="#Algebra.Quadrica.equacio">equacio</a></code></li>
<li><code><a title="Algebra.Quadrica.from_equacio" href="#Algebra.Quadrica.from_equacio">from_equacio</a></code></li>
<li><code><a title="Algebra.Quadrica.hiperboloideduesfulles" href="#Algebra.Quadrica.hiperboloideduesfulles">hiperboloideduesfulles</a></code></li>
<li><code><a title="Algebra.Quadrica.hiperboloideunafulla" href="#Algebra.Quadrica.hiperboloideunafulla">hiperboloideunafulla</a></code></li>
<li><code><a title="Algebra.Quadrica.paraboloideelliptic" href="#Algebra.Quadrica.paraboloideelliptic">paraboloideelliptic</a></code></li>
<li><code><a title="Algebra.Quadrica.paraboloidehiperbolic" href="#Algebra.Quadrica.paraboloidehiperbolic">paraboloidehiperbolic</a></code></li>
<li><code><a title="Algebra.Quadrica.referencia_principal" href="#Algebra.Quadrica.referencia_principal">referencia_principal</a></code></li>
<li><code><a title="Algebra.Quadrica.tipus" href="#Algebra.Quadrica.tipus">tipus</a></code></li>
<li><code><a title="Algebra.Quadrica.vectors" href="#Algebra.Quadrica.vectors">vectors</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Algebra.Conica"><code class="flex name class">
<span>class <span class="ident">Conica</span></span>
<span>(</span><span>matriu, ref=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Classe per treballar amb còniques. L'objectiu no és classificar còniques,
sinó generar coniques a partir dels elements característics o de manera
aleatòria.</p>
<h2 id="atributs">Atributs</h2>
<p>ref: referència euclidiana
matriu: matriu projectiva de la cònica en la referència "ref"
canonica: matriu projectiva de la cònica en la referència canònica</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Conica(object):
    &#34;&#34;&#34;
    Classe per treballar amb còniques. L&#39;objectiu no és classificar còniques,
    sinó generar coniques a partir dels elements característics o de manera
    aleatòria.
    Atributs:
        ref: referència euclidiana
        matriu: matriu projectiva de la cònica en la referència &#34;ref&#34;
        canonica: matriu projectiva de la cònica en la referència canònica
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,matriu,ref=None):
        &#34;&#34;&#34;
        Retorna una nova cònica
        Paràmetres:
            matriu: matriu projectiva de la cònica en la referència &#34;ref&#34;
            Ha de ser 3x3
            ref: referència afí. Si és None, serà la referència canònica
        &#34;&#34;&#34;
        if not isinstance(matriu,Matriu):
            return None
        if matriu.files != matriu.columnes:
            return None
        if matriu.files != 3:
            return None
        if not matriu.es_simetrica():
            return None
        if ref is not None:
            if ref.dimensio != 2:
                return None
            if not ref.base.es_unitaria():
                return None
            if not ref.base.es_ortogonal():
                return None
        return super(Conica,cls).__new__(cls)
    #
    #
    #
    def __init__(self,matriu,ref=None):
        self.ref = ref
        self.matriu = matriu
        if ref is None:
            self.canonica = matriu
        else:
            a = ref.base.matriu()
            a = a.inserta_columna(2,ref.origen)
            a = a.inserta_fila(2,Vector([0,0,1]))
            b = a.inversa()
            self.canonica = b.transposada() * matriu * b
            self.canonica.simplificar()
    #
    #
    #
    @classmethod
    def from_equacio(cls,eq):
        &#34;&#34;&#34;
        Retorna i classifica la cònica a partir de la seva equació.
        Només per a el·lipses, hipèrboles i paràboles
        &#34;&#34;&#34;
        x, y = symbols(&#39;x y&#39;)
        unknowns = [x,y]
        a = diff(eq,x,2) / 2
        b = diff(eq,x,y) / 2
        c = diff(eq,y,2) / 2
        d = (diff(eq,x).subs({x:1,y:0}) - 2 * a) / 2
        e = (diff(eq,y).subs({x:0,y:1}) - 2 * c) / 2
        f = eq.subs({x:0,y:0})
        Q = Matrix([[a,b],[b,c]])
        L = Matrix(2,1,[d,e])
        l = Vector(d,e)
        vs = Q.eigenvects()
        (t1,t2), veps = vaps_veps(vs)
        s = list(linsolve((Q,-L),*unknowns))
        if t1 * t2 &lt; 0:
            #
            # Hipèrbola
            #
            s = Punt(list(s[0]))
            fp = eq.subs({x:s[0],y:s[1]})
            a2 = -fp/t1
            b2 = -fp/t2
            if a2 &gt; 0:
                u = veps[0]
            else:
                a2, b2 = b2, a2
                u = veps[1]
            return Hiperbola(a2,-b2,s,u)
        if t1 * t2 &gt; 0:
            #
            # El·lipse
            #
            s = Punt(list(s[0]))
            fp = eq.subs({x:s[0],y:s[1]})
            if fp == 0:
                return None
            a2 = -fp/t1
            b2 = -fp/t2
            if a2 &lt; 0:
                return None
            if a2 &gt;= b2:
                u = veps[0]
            else:
                a2, b2 = b2, a2
                u = veps[1]
            return Ellipse(a2,b2,s,u)
        if len(s) &gt; 0:
            return None
        if t1 == 0 and t2 == 0:
            return None
        #
        # Paràbola
        #
        if t1 == 0:
            t1, t2 = t2, t1
            veps.reverse()
        veps[0].simplificar()
        veps[1].simplificar()
        b = Base(veps,unitaria=True)
        b.orientacio_positiva()
        es = t1 * veps[0].dot(Vector(x,y)) + veps[0].dot(l)
        vertex = Punt(solve([es,eq],x,y)[0])
        ref = ReferenciaAfi(vertex,b)
        ep = veps[1].dot(l)/veps[1].length()
        p = - ep/t1
        focus = ref.punt_de_coordenades(Punt(0,p/2))
        return Parabola(vertex,focus)
    #
    #
    #
    def __repr__(self):
        &#34;&#34;&#34;
        Retorna l&#39;equació en latex de l&#39;equació de la cònica en la referència
        canònica
        &#34;&#34;&#34;
        x, y = symbols(&#39;x y&#39;)
        m = Matriu.matriu_columna(Vector([x,y,1]))
        r = m.transposada() * self.canonica * m
        r.simplificar()
        return mylatex(r[0,0].expand()) + &#34; = 0&#34;
        #
        #
        #
    def equacio(self):
        &#34;&#34;&#34;
        Retorna l&#39;equació en latex de l&#39;equació de la quàdrica
        &#34;&#34;&#34;
        x, y = symbols(&#39;x y&#39;)
        m = Matriu.matriu_columna(Vector([x,y,1]))
        r = m.transposada() * self.canonica * m
        r.simplificar()
        return r[0,0].expand()
    #
    #
    #
    @classmethod
    def ellipse(cls,maxim=30,canonica=False):
        &#34;&#34;&#34;
        Retorna una el·lipse aleatòria
        Paràmetres:
            maxim: nombre màxim de la matriu projectiva de la cònica
        &#34;&#34;&#34;
        trobat = False
        while not trobat:
            e = Ellipse.aleatoria(canonica=canonica)
            trobat = canonica or e.canonica.norma_maxim() &lt;= maxim
        return e
    #
    #
    #
    @classmethod
    def hiperbola(cls,maxim=30,canonica=False,focus=False):
        &#34;&#34;&#34;
        Retorna una hipèrbola aleatòria
        Paràmetres:
            maxim: nombre màxim de la matriu projectiva de la cònica
        &#34;&#34;&#34;
        trobat = False
        while not trobat:
            h = Hiperbola.aleatoria(canonica=canonica,focus=focus)
            trobat = canonica or h.canonica.norma_maxim() &lt;= maxim
        return h
    #
    #
    #
    @classmethod
    def parabola(cls,maxim=30,canonica=False):
        &#34;&#34;&#34;
        Retorna una paràbola aleatòria
        Paràmetres:
            maxim: nombre màxim de la matriu projectiva de la cònica
        &#34;&#34;&#34;
        trobat = False
        while not trobat:
            p = Parabola.aleatoria(canonica=canonica)
            trobat = canonica or p.canonica.norma_maxim() &lt;= maxim
        return p
    #
    #
    #
    @classmethod
    def aleatoria(cls,maxim=40,canonica=False):
        &#34;&#34;&#34;
        Retorna una el·lipse, hipèrbola o paràbola aleatòries
        Paràmetres:
            maxim: nombre màxim de la matriu projectiva de la cònica
        &#34;&#34;&#34;
        r = random.randint(0,2)
        if r == 0:
            return Conica.ellipse(maxim,canonica=canonica)
        if r == 1:
            return Conica.hiperbola(maxim,canonica=canonica)
        return Conica.parabola(maxim,canonica=canonica)
    #
    #
    #
    def tipus(self):
        &#34;&#34;&#34;
        Retorna el tipus de cònica
        &#34;&#34;&#34;
        if isinstance(self,Ellipse):
            return &#34;El·lipse&#34;
        if isinstance(self,Hiperbola):
            return &#34;Hipèrbola&#34;
        if isinstance(self,Parabola):
            return &#34;Paràbola&#34;
        return &#34;&#34;
    #
    #
    #
    def referencia_principal(self):
        &#34;&#34;&#34;
        Retorna la referencia principal
        &#34;&#34;&#34;
        return self.ref
    #
    #
    #
    def vectors(self,unitaris=False):
        &#34;&#34;&#34;
        Retorna els vectors de la base de la referència principal
        Paràmetres:
            unitaris: si és True, els retorna unitaris
        &#34;&#34;&#34;
        return self.ref.vectors(unitaris)
    #
    #
    #
    def eix_principal(self):
        &#34;&#34;&#34;
        Retorna l&#39;eix principal com a recta afí
        &#34;&#34;&#34;
        return RectaAfi(self.ref.origen,self.ref.base.vecs[0])
    #
    #
    #
    def eix_secundari(self):
        &#34;&#34;&#34;
        Retorna l&#39;eix secundari com a recta afí
        &#34;&#34;&#34;
        return RectaAfi(self.ref.origen,self.ref.base.vecs[1])</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="Algebra.Ellipse" href="#Algebra.Ellipse">Ellipse</a></li>
<li><a title="Algebra.Hiperbola" href="#Algebra.Hiperbola">Hiperbola</a></li>
<li><a title="Algebra.Parabola" href="#Algebra.Parabola">Parabola</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="Algebra.Conica.aleatoria"><code class="name flex">
<span>def <span class="ident">aleatoria</span></span>(<span>maxim=40, canonica=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna una el·lipse, hipèrbola o paràbola aleatòries</p>
<h2 id="parametres">Paràmetres</h2>
<p>maxim: nombre màxim de la matriu projectiva de la cònica</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def aleatoria(cls,maxim=40,canonica=False):
    &#34;&#34;&#34;
    Retorna una el·lipse, hipèrbola o paràbola aleatòries
    Paràmetres:
        maxim: nombre màxim de la matriu projectiva de la cònica
    &#34;&#34;&#34;
    r = random.randint(0,2)
    if r == 0:
        return Conica.ellipse(maxim,canonica=canonica)
    if r == 1:
        return Conica.hiperbola(maxim,canonica=canonica)
    return Conica.parabola(maxim,canonica=canonica)</code></pre>
</details>
</dd>
<dt id="Algebra.Conica.ellipse"><code class="name flex">
<span>def <span class="ident">ellipse</span></span>(<span>maxim=30, canonica=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna una el·lipse aleatòria</p>
<h2 id="parametres">Paràmetres</h2>
<p>maxim: nombre màxim de la matriu projectiva de la cònica</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def ellipse(cls,maxim=30,canonica=False):
    &#34;&#34;&#34;
    Retorna una el·lipse aleatòria
    Paràmetres:
        maxim: nombre màxim de la matriu projectiva de la cònica
    &#34;&#34;&#34;
    trobat = False
    while not trobat:
        e = Ellipse.aleatoria(canonica=canonica)
        trobat = canonica or e.canonica.norma_maxim() &lt;= maxim
    return e</code></pre>
</details>
</dd>
<dt id="Algebra.Conica.from_equacio"><code class="name flex">
<span>def <span class="ident">from_equacio</span></span>(<span>eq)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna i classifica la cònica a partir de la seva equació.
Només per a el·lipses, hipèrboles i paràboles</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_equacio(cls,eq):
    &#34;&#34;&#34;
    Retorna i classifica la cònica a partir de la seva equació.
    Només per a el·lipses, hipèrboles i paràboles
    &#34;&#34;&#34;
    x, y = symbols(&#39;x y&#39;)
    unknowns = [x,y]
    a = diff(eq,x,2) / 2
    b = diff(eq,x,y) / 2
    c = diff(eq,y,2) / 2
    d = (diff(eq,x).subs({x:1,y:0}) - 2 * a) / 2
    e = (diff(eq,y).subs({x:0,y:1}) - 2 * c) / 2
    f = eq.subs({x:0,y:0})
    Q = Matrix([[a,b],[b,c]])
    L = Matrix(2,1,[d,e])
    l = Vector(d,e)
    vs = Q.eigenvects()
    (t1,t2), veps = vaps_veps(vs)
    s = list(linsolve((Q,-L),*unknowns))
    if t1 * t2 &lt; 0:
        #
        # Hipèrbola
        #
        s = Punt(list(s[0]))
        fp = eq.subs({x:s[0],y:s[1]})
        a2 = -fp/t1
        b2 = -fp/t2
        if a2 &gt; 0:
            u = veps[0]
        else:
            a2, b2 = b2, a2
            u = veps[1]
        return Hiperbola(a2,-b2,s,u)
    if t1 * t2 &gt; 0:
        #
        # El·lipse
        #
        s = Punt(list(s[0]))
        fp = eq.subs({x:s[0],y:s[1]})
        if fp == 0:
            return None
        a2 = -fp/t1
        b2 = -fp/t2
        if a2 &lt; 0:
            return None
        if a2 &gt;= b2:
            u = veps[0]
        else:
            a2, b2 = b2, a2
            u = veps[1]
        return Ellipse(a2,b2,s,u)
    if len(s) &gt; 0:
        return None
    if t1 == 0 and t2 == 0:
        return None
    #
    # Paràbola
    #
    if t1 == 0:
        t1, t2 = t2, t1
        veps.reverse()
    veps[0].simplificar()
    veps[1].simplificar()
    b = Base(veps,unitaria=True)
    b.orientacio_positiva()
    es = t1 * veps[0].dot(Vector(x,y)) + veps[0].dot(l)
    vertex = Punt(solve([es,eq],x,y)[0])
    ref = ReferenciaAfi(vertex,b)
    ep = veps[1].dot(l)/veps[1].length()
    p = - ep/t1
    focus = ref.punt_de_coordenades(Punt(0,p/2))
    return Parabola(vertex,focus)</code></pre>
</details>
</dd>
<dt id="Algebra.Conica.hiperbola"><code class="name flex">
<span>def <span class="ident">hiperbola</span></span>(<span>maxim=30, canonica=False, focus=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna una hipèrbola aleatòria</p>
<h2 id="parametres">Paràmetres</h2>
<p>maxim: nombre màxim de la matriu projectiva de la cònica</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def hiperbola(cls,maxim=30,canonica=False,focus=False):
    &#34;&#34;&#34;
    Retorna una hipèrbola aleatòria
    Paràmetres:
        maxim: nombre màxim de la matriu projectiva de la cònica
    &#34;&#34;&#34;
    trobat = False
    while not trobat:
        h = Hiperbola.aleatoria(canonica=canonica,focus=focus)
        trobat = canonica or h.canonica.norma_maxim() &lt;= maxim
    return h</code></pre>
</details>
</dd>
<dt id="Algebra.Conica.parabola"><code class="name flex">
<span>def <span class="ident">parabola</span></span>(<span>maxim=30, canonica=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna una paràbola aleatòria</p>
<h2 id="parametres">Paràmetres</h2>
<p>maxim: nombre màxim de la matriu projectiva de la cònica</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parabola(cls,maxim=30,canonica=False):
    &#34;&#34;&#34;
    Retorna una paràbola aleatòria
    Paràmetres:
        maxim: nombre màxim de la matriu projectiva de la cònica
    &#34;&#34;&#34;
    trobat = False
    while not trobat:
        p = Parabola.aleatoria(canonica=canonica)
        trobat = canonica or p.canonica.norma_maxim() &lt;= maxim
    return p</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Algebra.Conica.eix_principal"><code class="name flex">
<span>def <span class="ident">eix_principal</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna l'eix principal com a recta afí</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eix_principal(self):
    &#34;&#34;&#34;
    Retorna l&#39;eix principal com a recta afí
    &#34;&#34;&#34;
    return RectaAfi(self.ref.origen,self.ref.base.vecs[0])</code></pre>
</details>
</dd>
<dt id="Algebra.Conica.eix_secundari"><code class="name flex">
<span>def <span class="ident">eix_secundari</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna l'eix secundari com a recta afí</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eix_secundari(self):
    &#34;&#34;&#34;
    Retorna l&#39;eix secundari com a recta afí
    &#34;&#34;&#34;
    return RectaAfi(self.ref.origen,self.ref.base.vecs[1])</code></pre>
</details>
</dd>
<dt id="Algebra.Conica.equacio"><code class="name flex">
<span>def <span class="ident">equacio</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna l'equació en latex de l'equació de la quàdrica</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def equacio(self):
    &#34;&#34;&#34;
    Retorna l&#39;equació en latex de l&#39;equació de la quàdrica
    &#34;&#34;&#34;
    x, y = symbols(&#39;x y&#39;)
    m = Matriu.matriu_columna(Vector([x,y,1]))
    r = m.transposada() * self.canonica * m
    r.simplificar()
    return r[0,0].expand()</code></pre>
</details>
</dd>
<dt id="Algebra.Conica.referencia_principal"><code class="name flex">
<span>def <span class="ident">referencia_principal</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la referencia principal</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def referencia_principal(self):
    &#34;&#34;&#34;
    Retorna la referencia principal
    &#34;&#34;&#34;
    return self.ref</code></pre>
</details>
</dd>
<dt id="Algebra.Conica.tipus"><code class="name flex">
<span>def <span class="ident">tipus</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el tipus de cònica</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tipus(self):
    &#34;&#34;&#34;
    Retorna el tipus de cònica
    &#34;&#34;&#34;
    if isinstance(self,Ellipse):
        return &#34;El·lipse&#34;
    if isinstance(self,Hiperbola):
        return &#34;Hipèrbola&#34;
    if isinstance(self,Parabola):
        return &#34;Paràbola&#34;
    return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="Algebra.Conica.vectors"><code class="name flex">
<span>def <span class="ident">vectors</span></span>(<span>self, unitaris=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna els vectors de la base de la referència principal</p>
<h2 id="parametres">Paràmetres</h2>
<p>unitaris: si és True, els retorna unitaris</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vectors(self,unitaris=False):
    &#34;&#34;&#34;
    Retorna els vectors de la base de la referència principal
    Paràmetres:
        unitaris: si és True, els retorna unitaris
    &#34;&#34;&#34;
    return self.ref.vectors(unitaris)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Algebra.Ellipse"><code class="flex name class">
<span>class <span class="ident">Ellipse</span></span>
<span>(</span><span>a2, b2, centre, eix)</span>
</code></dt>
<dd>
<div class="desc"><p>Classe per treballar amb el·lipses</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Ellipse(Conica):
    &#34;&#34;&#34;
    Classe per treballar amb el·lipses
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,a2,b2,centre,eix):
        &#34;&#34;&#34;
        Constructor.
        Retorna una el·lipse
        Paràmetres:
            a2: semieix major al quadrat
            b2: semieix menor al quadrat
            centre: centre de l&#39;el·lipse
            eix: direcció de l&#39;eix principal (de les x&#39;)
        &#34;&#34;&#34;
        if not isinstance(centre,Punt):
            return None
        if not isinstance(eix,Vector):
            return None
        if centre.dimensio != 2:
            return None
        if eix.dimensio != 2:
            return None
        if eix.length() == 0:
            return None
        if a2 &lt;= 0:
            return None
        if b2 &lt;= 0:
            return None
        if a2 &lt; b2:
            return None
        return super(Conica,cls).__new__(cls)
    #
    #
    #
    def __init__(self,a2,b2,centre,eix):
        if eix[0] &lt; 0:
            eix = -eix
        s = SubespaiVectorial([eix])
        base = s.amplia_base(unitaria=True)
        r = ReferenciaAfi(centre,base)
        g = gcd(a2,b2)
        t = a2 * b2 // g
        a2 = a2 // g
        b2 = b2 // g
        m = Matriu.diagonal(Vector([b2,a2,-t]))
        Conica.__init__(self,m,r)
    #
    #
    #
    @classmethod
    def aleatoria(cls,canonica=False,):
        &#34;&#34;&#34;
        Retorna una el·lipse aleatòria
        &#34;&#34;&#34;
        if canonica:
            base = [Vector(1,0),Vector(0,1)]
            random.shuffle(base)
            eix = base[0]
        else:
            eix = Vector.aleatori(l=2,maxim=5,nuls=False)
        centre = Punt.aleatori(l=2,maxim=3,nuls=False)
        c = [1,2,3,4,5,6,7,8,9,10]
        trobat = False
        while not trobat:
            a = random.randint(0,len(c) - 1)
            a2 = c[a]
            a = random.randint(0,len(c) - 1)
            b2 = c[a]
            trobat = a2 != b2
        if b2 &gt; a2:
            a2, b2 = b2, a2
        l = eix.length()
        a2 = (a2*l)**2
        b2 = (b2*l)**2
        return cls(a2,b2,centre,eix)
    #
    #
    #
    def centre(self):
        &#34;&#34;&#34;
        Retorna el centre de la el·lipse
        &#34;&#34;&#34;
        return (self.ref.origen)
    #
    #
    #
    def maxim_origen(self):
        &#34;&#34;&#34;
        Retorna el màxim dels valors absoluts de les coordenades del centre
        &#34;&#34;&#34;
        return self.ref.origen.maxim()
    #
    #
    #
    def semieix_major(self):
        &#34;&#34;&#34;
        Retorna el semieix major
        &#34;&#34;&#34;
        l1 = self.matriu[0,0]
        f = - self.matriu[2,2]
        return sqrt(Rational(f,l1))
    #
    #
    #
    def semieix_menor(self):
        &#34;&#34;&#34;
        Retorna el semieix menor
        &#34;&#34;&#34;
        l2 = self.matriu[1,1]
        f = - self.matriu[2,2]
        return sqrt(Rational(f,l2))
    #
    #
    #
    def semidistancia_focal(self):
        &#34;&#34;&#34;
        Retorna la simidistància focal
        &#34;&#34;&#34;
        a2 = self.semieix_major()**2
        b2 = self.semieix_menor()**2
        return sqrt(a2 - b2)
    #
    #
    #
    def focus(self):
        &#34;&#34;&#34;
        Retorna els focus de l&#39;el·lipse
        &#34;&#34;&#34;
        c = self.semidistancia_focal()
        f = [Punt(c,0),Punt(-c,0)]
        return list(map(self.ref.punt_de_coordenades,f))
    #
    #
    #
    def vertexs(self):
        &#34;&#34;&#34;
        Retorna els vèrtex de l&#39;el·lipse
        &#34;&#34;&#34;
        a = self.semieix_major()
        b = self.semieix_menor()
        v = [Punt(a,0),Punt(-a,0),Punt(0,b),Punt(0,-b)]
        return list(map(self.ref.punt_de_coordenades,v))
    #
    #
    #
    def equacio_reduida(self):
        &#34;&#34;&#34;
        Retorna l&#39;equacio reduïda de l&#39;el·lipse en format LaTeX
        &#34;&#34;&#34;
        a2 = self.semieix_major()**2
        b2 = self.semieix_menor()**2
        if a2 == 1:
            return f&#34;x&#39;^2 + \\frac{{y&#39;^2}}{{{b2}}} = 1&#34;
        if b2 == 1:
            return f&#34;\\frac{{x&#39;^2}}{{{a2}}} + y&#39;^2 = 1&#34;
        return f&#34;\\frac{{x&#39;^2}}{{{a2}}} + \\frac{{y&#39;^2}}{{{b2}}} = 1&#34;
    #
    #
    #
    def to_asy(self,scaled=1.0,canonica=10,x=9,y=9):
        &#34;&#34;&#34;
        Retorna una expressió per fer servir amb el programa Asymtote
        Paràmetres:
            scaled: factor d&#39;escalat
            canonica = valors de partida dels eixos de la referència canònica
        &#34;&#34;&#34;
        a2 = self.semieix_major()**2
        b2 = self.semieix_menor()**2
        centre = self.centre()
        vector = self.vectors()[0]
        if vector[0] &lt; 0:
            vector = -vector
        mx, Mx  = -canonica + centre[0],canonica + centre[0]
        my, My  = -canonica + centre[1],canonica + centre[1]
        x = int(self.semieix_major()+3)
        if x &lt; 8:
            x = 8
        y = int(self.semieix_menor()+3)
        if y &lt; 8:
            y = 8
        str = f&#34;Canonica({mx},{Mx},{my},{My},scaled={scaled});&#34;
        clip = f&#34;path cl = ({mx},{my})--({Mx},{my})--({Mx},{My})--({mx},{My})--cycle;\n&#34;
        clip += f&#34;cl = scale({scaled}) * cl;\nclip(cl);&#34;
        return f&#34;{str}\nElipse({centre},{vector},{a2},{b2},x={x},y={y},scaled={scaled},x={x},y={y});\n{clip}&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Algebra.Conica" href="#Algebra.Conica">Conica</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="Algebra.Ellipse.aleatoria"><code class="name flex">
<span>def <span class="ident">aleatoria</span></span>(<span>canonica=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna una el·lipse aleatòria</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def aleatoria(cls,canonica=False,):
    &#34;&#34;&#34;
    Retorna una el·lipse aleatòria
    &#34;&#34;&#34;
    if canonica:
        base = [Vector(1,0),Vector(0,1)]
        random.shuffle(base)
        eix = base[0]
    else:
        eix = Vector.aleatori(l=2,maxim=5,nuls=False)
    centre = Punt.aleatori(l=2,maxim=3,nuls=False)
    c = [1,2,3,4,5,6,7,8,9,10]
    trobat = False
    while not trobat:
        a = random.randint(0,len(c) - 1)
        a2 = c[a]
        a = random.randint(0,len(c) - 1)
        b2 = c[a]
        trobat = a2 != b2
    if b2 &gt; a2:
        a2, b2 = b2, a2
    l = eix.length()
    a2 = (a2*l)**2
    b2 = (b2*l)**2
    return cls(a2,b2,centre,eix)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Algebra.Ellipse.centre"><code class="name flex">
<span>def <span class="ident">centre</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el centre de la el·lipse</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def centre(self):
    &#34;&#34;&#34;
    Retorna el centre de la el·lipse
    &#34;&#34;&#34;
    return (self.ref.origen)</code></pre>
</details>
</dd>
<dt id="Algebra.Ellipse.equacio_reduida"><code class="name flex">
<span>def <span class="ident">equacio_reduida</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna l'equacio reduïda de l'el·lipse en format LaTeX</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def equacio_reduida(self):
    &#34;&#34;&#34;
    Retorna l&#39;equacio reduïda de l&#39;el·lipse en format LaTeX
    &#34;&#34;&#34;
    a2 = self.semieix_major()**2
    b2 = self.semieix_menor()**2
    if a2 == 1:
        return f&#34;x&#39;^2 + \\frac{{y&#39;^2}}{{{b2}}} = 1&#34;
    if b2 == 1:
        return f&#34;\\frac{{x&#39;^2}}{{{a2}}} + y&#39;^2 = 1&#34;
    return f&#34;\\frac{{x&#39;^2}}{{{a2}}} + \\frac{{y&#39;^2}}{{{b2}}} = 1&#34;</code></pre>
</details>
</dd>
<dt id="Algebra.Ellipse.focus"><code class="name flex">
<span>def <span class="ident">focus</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna els focus de l'el·lipse</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def focus(self):
    &#34;&#34;&#34;
    Retorna els focus de l&#39;el·lipse
    &#34;&#34;&#34;
    c = self.semidistancia_focal()
    f = [Punt(c,0),Punt(-c,0)]
    return list(map(self.ref.punt_de_coordenades,f))</code></pre>
</details>
</dd>
<dt id="Algebra.Ellipse.maxim_origen"><code class="name flex">
<span>def <span class="ident">maxim_origen</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el màxim dels valors absoluts de les coordenades del centre</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def maxim_origen(self):
    &#34;&#34;&#34;
    Retorna el màxim dels valors absoluts de les coordenades del centre
    &#34;&#34;&#34;
    return self.ref.origen.maxim()</code></pre>
</details>
</dd>
<dt id="Algebra.Ellipse.semidistancia_focal"><code class="name flex">
<span>def <span class="ident">semidistancia_focal</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la simidistància focal</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def semidistancia_focal(self):
    &#34;&#34;&#34;
    Retorna la simidistància focal
    &#34;&#34;&#34;
    a2 = self.semieix_major()**2
    b2 = self.semieix_menor()**2
    return sqrt(a2 - b2)</code></pre>
</details>
</dd>
<dt id="Algebra.Ellipse.semieix_major"><code class="name flex">
<span>def <span class="ident">semieix_major</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el semieix major</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def semieix_major(self):
    &#34;&#34;&#34;
    Retorna el semieix major
    &#34;&#34;&#34;
    l1 = self.matriu[0,0]
    f = - self.matriu[2,2]
    return sqrt(Rational(f,l1))</code></pre>
</details>
</dd>
<dt id="Algebra.Ellipse.semieix_menor"><code class="name flex">
<span>def <span class="ident">semieix_menor</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el semieix menor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def semieix_menor(self):
    &#34;&#34;&#34;
    Retorna el semieix menor
    &#34;&#34;&#34;
    l2 = self.matriu[1,1]
    f = - self.matriu[2,2]
    return sqrt(Rational(f,l2))</code></pre>
</details>
</dd>
<dt id="Algebra.Ellipse.to_asy"><code class="name flex">
<span>def <span class="ident">to_asy</span></span>(<span>self, scaled=1.0, canonica=10, x=9, y=9)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna una expressió per fer servir amb el programa Asymtote</p>
<h2 id="parametres">Paràmetres</h2>
<p>scaled: factor d'escalat
canonica = valors de partida dels eixos de la referència canònica</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_asy(self,scaled=1.0,canonica=10,x=9,y=9):
    &#34;&#34;&#34;
    Retorna una expressió per fer servir amb el programa Asymtote
    Paràmetres:
        scaled: factor d&#39;escalat
        canonica = valors de partida dels eixos de la referència canònica
    &#34;&#34;&#34;
    a2 = self.semieix_major()**2
    b2 = self.semieix_menor()**2
    centre = self.centre()
    vector = self.vectors()[0]
    if vector[0] &lt; 0:
        vector = -vector
    mx, Mx  = -canonica + centre[0],canonica + centre[0]
    my, My  = -canonica + centre[1],canonica + centre[1]
    x = int(self.semieix_major()+3)
    if x &lt; 8:
        x = 8
    y = int(self.semieix_menor()+3)
    if y &lt; 8:
        y = 8
    str = f&#34;Canonica({mx},{Mx},{my},{My},scaled={scaled});&#34;
    clip = f&#34;path cl = ({mx},{my})--({Mx},{my})--({Mx},{My})--({mx},{My})--cycle;\n&#34;
    clip += f&#34;cl = scale({scaled}) * cl;\nclip(cl);&#34;
    return f&#34;{str}\nElipse({centre},{vector},{a2},{b2},x={x},y={y},scaled={scaled},x={x},y={y});\n{clip}&#34;</code></pre>
</details>
</dd>
<dt id="Algebra.Ellipse.vertexs"><code class="name flex">
<span>def <span class="ident">vertexs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna els vèrtex de l'el·lipse</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertexs(self):
    &#34;&#34;&#34;
    Retorna els vèrtex de l&#39;el·lipse
    &#34;&#34;&#34;
    a = self.semieix_major()
    b = self.semieix_menor()
    v = [Punt(a,0),Punt(-a,0),Punt(0,b),Punt(0,-b)]
    return list(map(self.ref.punt_de_coordenades,v))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Algebra.Conica" href="#Algebra.Conica">Conica</a></b></code>:
<ul class="hlist">
<li><code><a title="Algebra.Conica.eix_principal" href="#Algebra.Conica.eix_principal">eix_principal</a></code></li>
<li><code><a title="Algebra.Conica.eix_secundari" href="#Algebra.Conica.eix_secundari">eix_secundari</a></code></li>
<li><code><a title="Algebra.Conica.ellipse" href="#Algebra.Conica.ellipse">ellipse</a></code></li>
<li><code><a title="Algebra.Conica.equacio" href="#Algebra.Conica.equacio">equacio</a></code></li>
<li><code><a title="Algebra.Conica.from_equacio" href="#Algebra.Conica.from_equacio">from_equacio</a></code></li>
<li><code><a title="Algebra.Conica.hiperbola" href="#Algebra.Conica.hiperbola">hiperbola</a></code></li>
<li><code><a title="Algebra.Conica.parabola" href="#Algebra.Conica.parabola">parabola</a></code></li>
<li><code><a title="Algebra.Conica.referencia_principal" href="#Algebra.Conica.referencia_principal">referencia_principal</a></code></li>
<li><code><a title="Algebra.Conica.tipus" href="#Algebra.Conica.tipus">tipus</a></code></li>
<li><code><a title="Algebra.Conica.vectors" href="#Algebra.Conica.vectors">vectors</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Algebra.Ellipsoide"><code class="flex name class">
<span>class <span class="ident">Ellipsoide</span></span>
<span>(</span><span>a2, b2, c2, centre, eix1, eix2)</span>
</code></dt>
<dd>
<div class="desc"><p>Classe per treballar amb el·lipsoides</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Ellipsoide(Quadrica):
    &#34;&#34;&#34;
    Classe per treballar amb el·lipsoides
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,a2,b2,c2,centre,eix1,eix2):
        &#34;&#34;&#34;
        Constructor.
        Paràmetres:
           a2, b2, c2: semieixos al quadrat
           eix1: direcció de l&#39;eix principal (de les x&#39;)
           eix2: en pricipi és la direcció de l&#39;eix de les y&#39;, però si no és
                 perpendicular a eix1, es calcula el perpendicular que està
                 en el mateix pla vectorial que &lt;eix1,eix2&gt; aplicant el
                 mètode de Gram-Schmidt
        &#34;&#34;&#34;
        if not isinstance(centre,Punt):
            return None
        if not isinstance(eix1,Vector):
            return None
        if not isinstance(eix2,Vector):
            return None
        if centre.dimensio != 3:
            return None
        if eix1.dimensio != 3:
            return None
        if eix2.dimensio != 3:
            return None
        if eix1.length() == 0:
            return None
        if eix2.length() == 0:
            return None
        m = Matriu.from_vectors_columna([eix1,eix2])
        if m.rank() != 2:
            return None
        if a2 &lt;= 0:
            return None
        if b2 &lt;= 0:
            return None
        if c2 &lt;= 0:
            return None
        return super(Quadrica,cls).__new__(cls)
    #
    #
    #
    def __init__(self,a2,b2,c2,centre,eix1,eix2):
        s = SubespaiVectorial([eix1,eix2])
        base = s.amplia_base(unitaria=True)
        r = ReferenciaAfi(centre,base)
        g = mcm_llista([a2,b2,c2])
        t = g
        a2 = g // a2
        b2 = g // b2
        c2 = g // c2
        m = Matriu.diagonal(Vector([a2,b2,c2,-g]))
        Quadrica.__init__(self,m,r)
    #
    #
    #
    @classmethod
    def aleatoria(cls,canonica=False):
        &#34;&#34;&#34;
        Retorna un el·lipsoide de manera aleatòria aleatòria
        &#34;&#34;&#34;
        if canonica:
            v = [Vector(1,0,0),Vector(0,1,0),Vector(0,0,1)]
            random.shuffle(v)
            eix1, eix2, _ = v
        else:
            trobat = False
            while not trobat:
                eix1 = Vector.aleatori(l=3,maxim=3)
                eix2 = Vector.aleatori(l=3,maxim=3)
                if eix1.nzeros() &gt; 1 or eix2.nzeros() &gt; 1:
                    continue
                trobat = Matriu.from_vectors_columna([eix1,eix2]).rank() == 2
        trobat = False
        while not trobat:
            centre = Punt.aleatori(l=3,maxim=4,nuls=False)
            trobat = centre.length() &gt; 0
        c = [1,2,3,4,5,8,10,12,16,18,20,25,36]
        trobat = False
        while not trobat:
            a = random.randint(0,len(c) - 1)
            a2 = c[a]
            a = random.randint(0,len(c) - 1)
            b2 = c[a]
            a = random.randint(0,len(c) - 1)
            c2 = c[a]
            trobat = a2 != b2 or a2 != c2
        a2, b2, c2 = sorted([a2,b2,c2])[::-1]
        return cls(a2,b2,c2,centre,eix1,eix2)
    #
    #
    #
    def centre(self):
        &#34;&#34;&#34;
        Retorna el centre de l&#39;el·lipsoide
        &#34;&#34;&#34;
        return (self.ref.origen)
    #
    #
    #
    def semieixos(self):
        &#34;&#34;&#34;
        Retorna els semieixos de l&#39;el·lipsoide
        &#34;&#34;&#34;
        a = self.matriu[0,0]
        b = self.matriu[1,1]
        c = self.matriu[2,2]
        f = - self.matriu[3,3]
        return (sqrt(Rational(f,a)),sqrt(Rational(f,b)),sqrt(Rational(f,c)))
    #
    #
    #
    def semieixos_quadrats(self):
        &#34;&#34;&#34;
        Retorna els semieixos al quadrat de l&#39;el·lipsoide
        &#34;&#34;&#34;
        a = self.matriu[0,0]
        b = self.matriu[1,1]
        c = self.matriu[2,2]
        f = - self.matriu[3,3]
        return (Rational(f,a),Rational(f,b),Rational(f,c))
    #
    #
    #
    def equacio_reduida(self):
        &#34;&#34;&#34;
        Retorna l&#39;equacio reduïda de l&#39;el·lipsoide
        &#34;&#34;&#34;
        a2, b2, c2 = self.semieixos_quadrats()
        if a2 == 1:
            str = &#34;x&#39;^2&#34;
        else:
            str = f&#34;\\frac{{x&#39;^2}}{{ {latex(a2)} }}&#34;
        if b2 == 1:
            str += &#34; + y&#39;^2&#34;
        else:
            str += f&#34; + \\frac{{y&#39;^2}}{{ {latex(b2)} }}&#34;
        if c2 == 1:
            str += &#34; + z&#39;^2 = 1&#34;
        else:
            str += f&#34; + \\frac{{z&#39;^2}}{{ {latex(c2)} }} = 1&#34;
        return str</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Algebra.Quadrica" href="#Algebra.Quadrica">Quadrica</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="Algebra.Ellipsoide.aleatoria"><code class="name flex">
<span>def <span class="ident">aleatoria</span></span>(<span>canonica=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna un el·lipsoide de manera aleatòria aleatòria</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def aleatoria(cls,canonica=False):
    &#34;&#34;&#34;
    Retorna un el·lipsoide de manera aleatòria aleatòria
    &#34;&#34;&#34;
    if canonica:
        v = [Vector(1,0,0),Vector(0,1,0),Vector(0,0,1)]
        random.shuffle(v)
        eix1, eix2, _ = v
    else:
        trobat = False
        while not trobat:
            eix1 = Vector.aleatori(l=3,maxim=3)
            eix2 = Vector.aleatori(l=3,maxim=3)
            if eix1.nzeros() &gt; 1 or eix2.nzeros() &gt; 1:
                continue
            trobat = Matriu.from_vectors_columna([eix1,eix2]).rank() == 2
    trobat = False
    while not trobat:
        centre = Punt.aleatori(l=3,maxim=4,nuls=False)
        trobat = centre.length() &gt; 0
    c = [1,2,3,4,5,8,10,12,16,18,20,25,36]
    trobat = False
    while not trobat:
        a = random.randint(0,len(c) - 1)
        a2 = c[a]
        a = random.randint(0,len(c) - 1)
        b2 = c[a]
        a = random.randint(0,len(c) - 1)
        c2 = c[a]
        trobat = a2 != b2 or a2 != c2
    a2, b2, c2 = sorted([a2,b2,c2])[::-1]
    return cls(a2,b2,c2,centre,eix1,eix2)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Algebra.Ellipsoide.centre"><code class="name flex">
<span>def <span class="ident">centre</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el centre de l'el·lipsoide</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def centre(self):
    &#34;&#34;&#34;
    Retorna el centre de l&#39;el·lipsoide
    &#34;&#34;&#34;
    return (self.ref.origen)</code></pre>
</details>
</dd>
<dt id="Algebra.Ellipsoide.equacio_reduida"><code class="name flex">
<span>def <span class="ident">equacio_reduida</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna l'equacio reduïda de l'el·lipsoide</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def equacio_reduida(self):
    &#34;&#34;&#34;
    Retorna l&#39;equacio reduïda de l&#39;el·lipsoide
    &#34;&#34;&#34;
    a2, b2, c2 = self.semieixos_quadrats()
    if a2 == 1:
        str = &#34;x&#39;^2&#34;
    else:
        str = f&#34;\\frac{{x&#39;^2}}{{ {latex(a2)} }}&#34;
    if b2 == 1:
        str += &#34; + y&#39;^2&#34;
    else:
        str += f&#34; + \\frac{{y&#39;^2}}{{ {latex(b2)} }}&#34;
    if c2 == 1:
        str += &#34; + z&#39;^2 = 1&#34;
    else:
        str += f&#34; + \\frac{{z&#39;^2}}{{ {latex(c2)} }} = 1&#34;
    return str</code></pre>
</details>
</dd>
<dt id="Algebra.Ellipsoide.semieixos"><code class="name flex">
<span>def <span class="ident">semieixos</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna els semieixos de l'el·lipsoide</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def semieixos(self):
    &#34;&#34;&#34;
    Retorna els semieixos de l&#39;el·lipsoide
    &#34;&#34;&#34;
    a = self.matriu[0,0]
    b = self.matriu[1,1]
    c = self.matriu[2,2]
    f = - self.matriu[3,3]
    return (sqrt(Rational(f,a)),sqrt(Rational(f,b)),sqrt(Rational(f,c)))</code></pre>
</details>
</dd>
<dt id="Algebra.Ellipsoide.semieixos_quadrats"><code class="name flex">
<span>def <span class="ident">semieixos_quadrats</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna els semieixos al quadrat de l'el·lipsoide</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def semieixos_quadrats(self):
    &#34;&#34;&#34;
    Retorna els semieixos al quadrat de l&#39;el·lipsoide
    &#34;&#34;&#34;
    a = self.matriu[0,0]
    b = self.matriu[1,1]
    c = self.matriu[2,2]
    f = - self.matriu[3,3]
    return (Rational(f,a),Rational(f,b),Rational(f,c))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Algebra.Quadrica" href="#Algebra.Quadrica">Quadrica</a></b></code>:
<ul class="hlist">
<li><code><a title="Algebra.Quadrica.cilindreelliptic" href="#Algebra.Quadrica.cilindreelliptic">cilindreelliptic</a></code></li>
<li><code><a title="Algebra.Quadrica.cilindrehiperbolic" href="#Algebra.Quadrica.cilindrehiperbolic">cilindrehiperbolic</a></code></li>
<li><code><a title="Algebra.Quadrica.cilindreparabolic" href="#Algebra.Quadrica.cilindreparabolic">cilindreparabolic</a></code></li>
<li><code><a title="Algebra.Quadrica.con" href="#Algebra.Quadrica.con">con</a></code></li>
<li><code><a title="Algebra.Quadrica.ellipsoide" href="#Algebra.Quadrica.ellipsoide">ellipsoide</a></code></li>
<li><code><a title="Algebra.Quadrica.equacio" href="#Algebra.Quadrica.equacio">equacio</a></code></li>
<li><code><a title="Algebra.Quadrica.from_equacio" href="#Algebra.Quadrica.from_equacio">from_equacio</a></code></li>
<li><code><a title="Algebra.Quadrica.hiperboloideduesfulles" href="#Algebra.Quadrica.hiperboloideduesfulles">hiperboloideduesfulles</a></code></li>
<li><code><a title="Algebra.Quadrica.hiperboloideunafulla" href="#Algebra.Quadrica.hiperboloideunafulla">hiperboloideunafulla</a></code></li>
<li><code><a title="Algebra.Quadrica.paraboloideelliptic" href="#Algebra.Quadrica.paraboloideelliptic">paraboloideelliptic</a></code></li>
<li><code><a title="Algebra.Quadrica.paraboloidehiperbolic" href="#Algebra.Quadrica.paraboloidehiperbolic">paraboloidehiperbolic</a></code></li>
<li><code><a title="Algebra.Quadrica.referencia_principal" href="#Algebra.Quadrica.referencia_principal">referencia_principal</a></code></li>
<li><code><a title="Algebra.Quadrica.tipus" href="#Algebra.Quadrica.tipus">tipus</a></code></li>
<li><code><a title="Algebra.Quadrica.vectors" href="#Algebra.Quadrica.vectors">vectors</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Algebra.EquacioLineal"><code class="flex name class">
<span>class <span class="ident">EquacioLineal</span></span>
<span>(</span><span>eq, amp=False, prime=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Classe per treballar amb equacions lineals.</p>
<h2 id="atributs">Atributs</h2>
<p>equacio: terme de l'esquerra en la equacio "eq = 0"
unknowns: incògnites que apareixen a l'equació
amp: True o False
prime: nombre de primes que escriurem a l'equació</p>
<p>Constructor.</p>
<h2 id="paramentres">Paràmentres</h2>
<p>eq: expressió lineal que ha de contenir tots els termes, aleshores
l'equació serà "eq = 0". Només guardem la part "eq"
amp: quan escrivim l'equació en latex ha d'aparèixer &amp;= o només =
prime: nombre de primes que s'han de posar a les incògnites</p>
<p>Per exemple:
x, y, z, t = symbols('x y z t')
eq = 2<em>x-3</em>y+4<em>z-3</em>t-4
e = EquacioLineal(eq)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EquacioLineal:
    &#34;&#34;&#34;
    Classe per treballar amb equacions lineals.
    Atributs:
        equacio: terme de l&#39;esquerra en la equacio &#34;eq = 0&#34;
        unknowns: incògnites que apareixen a l&#39;equació
        amp: True o False
        prime: nombre de primes que escriurem a l&#39;equació
    &#34;&#34;&#34;
    #
    #
    #
    def __init__(self,eq,amp=False,prime=0):
        &#34;&#34;&#34;
        Constructor.
        Paràmentres:
           eq: expressió lineal que ha de contenir tots els termes, aleshores
               l&#39;equació serà &#34;eq = 0&#34;. Només guardem la part &#34;eq&#34;
           amp: quan escrivim l&#39;equació en latex ha d&#39;aparèixer &amp;= o només =
           prime: nombre de primes que s&#39;han de posar a les incògnites

         Per exemple:
         x, y, z, t = symbols(&#39;x y z t&#39;)
         eq = 2*x-3*y+4*z-3*t-4
         e = EquacioLineal(eq)
        &#34;&#34;&#34;
        x, y, z, t = symbols(&#39;x y z t&#39;)
        x1, x2, x3, x4, x5, x6, x7, x8 = symbols(&#39;x1 x2 x3 x4 x5 x6 x7 x8&#39;)
        incognites = [x,y,z,t,x1,x2,x3,x4,x5,x6,x7,x8]
        self.equacio = eq
        self.amp = amp
        d = self.equacio.as_coefficients_dict()
        self.unknowns = []
        for k in incognites:
            if diff(eq,k) != 0:
                self.unknowns.append(k)
        self.prime = prime
    #
    #
    #
    @classmethod
    def coeficients(cls,a,b,amp=False,prime=0):
        &#34;&#34;&#34;
        Retorna una nova equació amb coeficients de les incògnites el vector &#34;a&#34; i
        terme independent b
        Paràmetres:
            a: Vector amb els coeficients de les incògnites
            b: terme independents
            amp: si és True l&#39;equació s&#39;escriurà amb el &amp;= per al LaTeX
            prime: nombre de primes que s&#39;escriuran a les incògnites
        &#34;&#34;&#34;
        if not isinstance(a,Vector):
            return None
        if a.dimensio &lt;= 4:
            x, y, z, t = symbols(&#39;x y z t&#39;)
            unknowns = [x,y,z,t]
        else:
            x1, x2, x3, x4, x5, x6, x7, x8 = symbols(&#39;x1 x2 x3 x4 x5 x6 x7 x8&#39;)
            unknowns = [x1,x2,x3,x4,x5,x6,x7,x8]
        eq = 0
        for k in range(a.dimensio):
            eq += a[k] * unknowns[k]
        eq = simplify((eq - b).expand())
        return cls(eq,amp,prime)
    #
    #
    #
    def set_coeficient_positiu(self,incogs):
        &#34;&#34;&#34;
        Busca el primer coeficient no nul d&#39;entre les incògnites &#34;incogs&#34;, si el primer
        que troba és negatiu, canvia l&#39;equació de signe

        canvia de signe tota l&#39;equació, de
        manera que el coeficients de &#34;k&#34; passa a ser positiu
        &#34;&#34;&#34;
        d = self.equacio.as_coefficients_dict()
        for k in incogs:
            if d[k] == 0:
                continue
            if d[k] &lt; 0:
                self.equacio *= -1
                return
            return
    #
    #
    #
    def terme_independent(self):
        &#34;&#34;&#34;
        Retorna el terme independent de l&#39;equació
        &#34;&#34;&#34;
        d = self.equacio.as_coefficients_dict()
        return -d[1]

    #
    #
    #
    def __repr__(self):
        &#34;&#34;&#34;
        Retorna l&#39;expressió en latex de l&#39;equació.
        Si els coeficients són enters o racionals, treu el denominador comú
        &#34;&#34;&#34;
        t = symbols(&#39;t&#39;)
        x1, x2, x3, x4, x5, x6, x7, x8 = symbols(&#39;x1 x2 x3 x4 x5 x6 x7 x8&#39;)
        incgs = {x1, x2, x3, x4, x5, x6, x7, x8}
        other = False
        d = self.equacio.as_coefficients_dict()
        l = list(d.values())
        m = []
        for k in l:
            if isinstance(k,Rational):
                m.append(k.q)
            elif isinstance(k,int) or isinstance(k,Integer):
                pass
            else:
                other = True
        if not other:
            mcm = mcm_llista(m)
            v = [mcm * x for x in l]
            mcd = mcd_llista(v)
            factor = Rational(mcm,mcd)
            eq = 0
            terme = 0
            for k in d.keys():
                if k.is_symbol and k not in self.unknowns:
                    terme += factor * d[k] * k
                else:
                    d[k] = factor * d[k]
                    eq += d[k] * k
        else:
            eq = self.equacio
        eq -= d[1]
        if t in self.unknowns:
            str = mylatex(eq)
        else:
            if len(incgs &amp; set(self.unknowns)) &gt; 0:
                str = latex(simplify(eq.expand()))
            else:
                str = mylatex(simplify(eq.expand()))
        if self.amp:
            str = f&#34;{str} &amp;= {latex(-d[1] - terme)}&#34;
        else:
            str = f&#34;{str} = {latex(-d[1] - terme)}&#34;
        if self.prime &gt; 0:
            s = self.prime * &#34;&#39;&#34;
            for i in self.unknowns:
                str = str.replace(latex(i),latex(i) + s)
        return str
    #
    #
    #
    def __add__(self,other):
        &#34;&#34;&#34;
        Suma d&#39;equacions
        Paràmetres:
            other: una altra equació
        &#34;&#34;&#34;
        if not isinstance(other,EquacioLineal):
            return None
        if self.prime != other.prime:
            return None
        eq = self.equacio + other.equacio
        return EquacioLineal(eq,self.amp or other.amp)
    #
    #
    #
    def __sub__(self,other):
        &#34;&#34;&#34;
        Resta d&#39;equacions
        Paràmetres:
            other: una altra equació
        &#34;&#34;&#34;
        if not isinstance(other,EquacioLineal):
            return None
        if self.prime != other.prime:
            return None
        eq = self.equacio - other.equacio
        return EquacioLineal(eq,self.amp or other.amp)
    #
    #
    #
    def __mul__(self,other):
        &#34;&#34;&#34;
        Producte d&#39;un escalar per una equació
        Paràmetres:
            other: un escalar
        &#34;&#34;&#34;
        types = [Rational,float,int,Float,Pow,Add,Mul]
        for t in types:
            if isinstance(other,t):
                return EquacioLineal(other * self.equacio,self.amp)
        return None
    #
    #
    #
    __rmul__ = __mul__
    #
    #
    #
    def to_sistema_equacions(self):
        &#34;&#34;&#34;
        Retorna un sistema d&#39;equacions (class SistemaEquacions) que té com a única
        equació l&#39;actual
        &#34;&#34;&#34;
        x, y, z, t = symbols(&#39;x y z t&#39;)
        unknowns = [x,y,z,t]
        n = -1
        for u in self.unknowns:
            m = unknowns.index(u)
            if m &gt; n:
                n = m
        if n &gt;= 0:
            return SistemaEquacions.from_equacions([self.equacio],n+1,self.prime)
        x1, x2, x3, x4, x5, x6, x7, x8 = symbols(&#39;x1 x2 x3 x4 x5 x6 x7 x8&#39;)
        unknowns = [x1,x2,x3,x4,x5,x6,x7,x8]
        for u in self.unknowns:
            m = unknowns.index(u)
            if m &gt; n:
                n = m
        return SistemaEquacions.from_equacions([self.equacio],n+1,self.prime)
    #
    #
    #
    def resol(self,unknown):
        &#34;&#34;&#34;
        Resol l&#39;equació aïllant la incògnita &#39;unknown&#39;
        &#34;&#34;&#34;
        return solve(self.equacio,unknown)[0]</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="Algebra.EquacioLineal.coeficients"><code class="name flex">
<span>def <span class="ident">coeficients</span></span>(<span>a, b, amp=False, prime=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna una nova equació amb coeficients de les incògnites el vector "a" i
terme independent b</p>
<h2 id="parametres">Paràmetres</h2>
<p>a: Vector amb els coeficients de les incògnites
b: terme independents
amp: si és True l'equació s'escriurà amb el &amp;= per al LaTeX
prime: nombre de primes que s'escriuran a les incògnites</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def coeficients(cls,a,b,amp=False,prime=0):
    &#34;&#34;&#34;
    Retorna una nova equació amb coeficients de les incògnites el vector &#34;a&#34; i
    terme independent b
    Paràmetres:
        a: Vector amb els coeficients de les incògnites
        b: terme independents
        amp: si és True l&#39;equació s&#39;escriurà amb el &amp;= per al LaTeX
        prime: nombre de primes que s&#39;escriuran a les incògnites
    &#34;&#34;&#34;
    if not isinstance(a,Vector):
        return None
    if a.dimensio &lt;= 4:
        x, y, z, t = symbols(&#39;x y z t&#39;)
        unknowns = [x,y,z,t]
    else:
        x1, x2, x3, x4, x5, x6, x7, x8 = symbols(&#39;x1 x2 x3 x4 x5 x6 x7 x8&#39;)
        unknowns = [x1,x2,x3,x4,x5,x6,x7,x8]
    eq = 0
    for k in range(a.dimensio):
        eq += a[k] * unknowns[k]
    eq = simplify((eq - b).expand())
    return cls(eq,amp,prime)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Algebra.EquacioLineal.resol"><code class="name flex">
<span>def <span class="ident">resol</span></span>(<span>self, unknown)</span>
</code></dt>
<dd>
<div class="desc"><p>Resol l'equació aïllant la incògnita 'unknown'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resol(self,unknown):
    &#34;&#34;&#34;
    Resol l&#39;equació aïllant la incògnita &#39;unknown&#39;
    &#34;&#34;&#34;
    return solve(self.equacio,unknown)[0]</code></pre>
</details>
</dd>
<dt id="Algebra.EquacioLineal.set_coeficient_positiu"><code class="name flex">
<span>def <span class="ident">set_coeficient_positiu</span></span>(<span>self, incogs)</span>
</code></dt>
<dd>
<div class="desc"><p>Busca el primer coeficient no nul d'entre les incògnites "incogs", si el primer
que troba és negatiu, canvia l'equació de signe</p>
<p>canvia de signe tota l'equació, de
manera que el coeficients de "k" passa a ser positiu</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_coeficient_positiu(self,incogs):
    &#34;&#34;&#34;
    Busca el primer coeficient no nul d&#39;entre les incògnites &#34;incogs&#34;, si el primer
    que troba és negatiu, canvia l&#39;equació de signe

    canvia de signe tota l&#39;equació, de
    manera que el coeficients de &#34;k&#34; passa a ser positiu
    &#34;&#34;&#34;
    d = self.equacio.as_coefficients_dict()
    for k in incogs:
        if d[k] == 0:
            continue
        if d[k] &lt; 0:
            self.equacio *= -1
            return
        return</code></pre>
</details>
</dd>
<dt id="Algebra.EquacioLineal.terme_independent"><code class="name flex">
<span>def <span class="ident">terme_independent</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el terme independent de l'equació</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def terme_independent(self):
    &#34;&#34;&#34;
    Retorna el terme independent de l&#39;equació
    &#34;&#34;&#34;
    d = self.equacio.as_coefficients_dict()
    return -d[1]</code></pre>
</details>
</dd>
<dt id="Algebra.EquacioLineal.to_sistema_equacions"><code class="name flex">
<span>def <span class="ident">to_sistema_equacions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna un sistema d'equacions (class SistemaEquacions) que té com a única
equació l'actual</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_sistema_equacions(self):
    &#34;&#34;&#34;
    Retorna un sistema d&#39;equacions (class SistemaEquacions) que té com a única
    equació l&#39;actual
    &#34;&#34;&#34;
    x, y, z, t = symbols(&#39;x y z t&#39;)
    unknowns = [x,y,z,t]
    n = -1
    for u in self.unknowns:
        m = unknowns.index(u)
        if m &gt; n:
            n = m
    if n &gt;= 0:
        return SistemaEquacions.from_equacions([self.equacio],n+1,self.prime)
    x1, x2, x3, x4, x5, x6, x7, x8 = symbols(&#39;x1 x2 x3 x4 x5 x6 x7 x8&#39;)
    unknowns = [x1,x2,x3,x4,x5,x6,x7,x8]
    for u in self.unknowns:
        m = unknowns.index(u)
        if m &gt; n:
            n = m
    return SistemaEquacions.from_equacions([self.equacio],n+1,self.prime)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Algebra.EquacioParametrica"><code class="flex name class">
<span>class <span class="ident">EquacioParametrica</span></span>
<span>(</span><span>eq, amp=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Classe per treballar amb equacions paramètriques</p>
<h2 id="atributs">Atributs</h2>
<p>equacio: l'equació paramètrica
b: terme independent de l'equaqció
coefs: coeficients dels paràmetres
unknown: incògina de l'equació paramètrica</p>
<p>Contructor.</p>
<h2 id="parametres">Paràmetres</h2>
<p>eq: equació paramètrica. Ha de ser del tipus
-x + 2<em>t1 - 3</em>t2 + t3 - 4
amb el signe menys a la incògnita
amp: True o False en funció si hem d'escriure &amp;= o només = en la representació
en LaTeX de l'equació</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EquacioParametrica:
    &#34;&#34;&#34;
    Classe per treballar amb equacions paramètriques
    Atributs:
        equacio: l&#39;equació paramètrica
        b: terme independent de l&#39;equaqció
        coefs: coeficients dels paràmetres
        unknown: incògina de l&#39;equació paramètrica
    &#34;&#34;&#34;
    #
    #
    #
    def __init__(self,eq,amp=True):
        &#34;&#34;&#34;
        Contructor.
        Paràmetres:
          eq: equació paramètrica. Ha de ser del tipus
              -x + 2*t1 - 3*t2 + t3 - 4
             amb el signe menys a la incògnita
          amp: True o False en funció si hem d&#39;escriure &amp;= o només = en la representació
               en LaTeX de l&#39;equació
        &#34;&#34;&#34;
        x, y, z, t = symbols(&#39;x y z t&#39;)
        x1, x2, x3, x4, x5, x6, x7, x8 = symbols(&#39;x1 x2 x3 x4 x5 x6 x7 x8&#39;)
        unknowns = [x1,x2,x3,x4,x5,x6,x7,x8] + [x,y,z,t]
        self.equacio = eq
        self.amp = amp
        d = eq.as_coefficients_dict()
        self.b = 0
        self.coefs = {}
        self.params = []
        for k in d.keys():
            if k == 1:
                self.b = d[k]
            elif k in unknowns:
                self.unknown = k
            else:
                if k not in self.params:
                    self.params.append(k)
                self.coefs[k] = d[k]
        self.params.sort(key=latex)
    #
    #
    #
    @classmethod
    def coeficients(cls,a,b,p=0,total=1,amp=True):
        &#34;&#34;&#34;
        Genera una equació amb coeficients dels paràmtres el vector &#34;a&#34;, terme
        independent b i incògnita número p d&#39;un total de &#34;total&#34;.
        Paràmetres:
            a: vector amb els coeficients dels paràmetres
            b: terme independent
            p: índex que representa la incògnita
            total: nombre total d&#39;incònites
        Exemple:
           e = EquacioParametrica(Vector(3,-2,1),5,1,4) genera l&#39;equació
                        - y + 3*t1 - 2*t2 + t3 + 5
           e = EquacioParametrica(Vector(3,-2,1,3],-5,3,7) genera l&#39;equació
               - x3 + 3*t1 - 2*t2 + t3 + 3*t4 + 7*t5 - 5
        Observació:
            si hi ha un màxim de quatre incògnites, son (x,y,z,t)
            si n&#39;hi ha més, són (x1,x2,x3,x4,...)
        &#34;&#34;&#34;
        if not isinstance(a,Vector):
            return None
        if p &gt;= total:
            return None
        if total &lt;= 4:
            x, y, z, t = symbols(&#39;x y z t&#39;)
            unknowns = [x,y,z,t]
        else:
            x1, x2, x3, x4, x5, x6, x7, x8 = symbols(&#39;x1 x2 x3 x4 x5 x6 x7 x8&#39;)
            unknowns = [x1,x2,x3,x4,x5,x6,x7,x8]
        t1, t2, t3, t4, t5, t6, t7, t8 = symbols(&#39;t1 t2 t3 t4 t5 t6 t7 t8&#39;)
        parameters = [t1,t2,t3,t4,t5,t6,t7,t8]
        eq = - unknowns[p]
        cls.unknown = unknowns[p]
        for k in range(a.dimensio):
            eq += a[k] * parameters[k]
        eq += b
        return cls(eq,amp)
    #
    #
    #
    def __repr__(self):
        &#34;&#34;&#34;
        Retorna l&#39;expessió en LaTeX de l&#39;equació paramètrica
        &#34;&#34;&#34;
        t1, t2, t3, t4, t5, t6, t7, t8 = symbols(&#39;t1 t2 t3 t4 t5 t6 t7 t8&#39;)
        x1, x2, x3, x4, x5, x6, x7, x8 = symbols(&#39;x1 x2 x3 x4 x5 x6 x7 x8&#39;)
        x, y, z, t = symbols(&#39;x y z t&#39;)
        if self.amp:
            s = f&#34;{latex(self.unknown)} &amp;= &#34;
        else:
            s = f&#34;{latex(self.unknown)} = &#34;
        d = []
        if isinstance(self.b,Rational):
            d.append(self.b.q)
        for k,v in self.coefs.items():
            if isinstance(v,Rational):
                d.append(v.q)
        if len(d) == 0:
            factor = 1
        else:
            factor = mcm_llista(d)
        if factor != 1:
            s += f&#34;\\frac{{NUMERADOR}}{{{factor}}}&#34;
        else:
            s += &#34;NUMERADOR&#34;
        e = 0
        first = None
        for k in self.params:
            try:
                self.coefs[k]
            except:
                continue
            if first is None and self.coefs[k] != 0:
                first = k
            e += factor * self.coefs[k] * k
        f = &#34;&#34;
        if first is not None and self.b != 0:
            if self.coefs[first] &gt; 0:
                f = f&#34;{factor*self.b} + &#34;
            else:
                f = f&#34;{factor*self.b} &#34;
        s = s.replace(&#39;NUMERADOR&#39;,f + latex(e))
        return s</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="Algebra.EquacioParametrica.coeficients"><code class="name flex">
<span>def <span class="ident">coeficients</span></span>(<span>a, b, p=0, total=1, amp=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Genera una equació amb coeficients dels paràmtres el vector "a", terme
independent b i incògnita número p d'un total de "total".</p>
<h2 id="parametres">Paràmetres</h2>
<p>a: vector amb els coeficients dels paràmetres
b: terme independent
p: índex que representa la incògnita
total: nombre total d'incònites</p>
<h2 id="exemple">Exemple</h2>
<p>e = EquacioParametrica(Vector(3,-2,1),5,1,4) genera l'equació
- y + 3<em>t1 - 2</em>t2 + t3 + 5
e = EquacioParametrica(Vector(3,-2,1,3],-5,3,7) genera l'equació
- x3 + 3<em>t1 - 2</em>t2 + t3 + 3<em>t4 + 7</em>t5 - 5</p>
<h2 id="observacio">Observació</h2>
<p>si hi ha un màxim de quatre incògnites, son (x,y,z,t)
si n'hi ha més, són (x1,x2,x3,x4,&hellip;)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def coeficients(cls,a,b,p=0,total=1,amp=True):
    &#34;&#34;&#34;
    Genera una equació amb coeficients dels paràmtres el vector &#34;a&#34;, terme
    independent b i incògnita número p d&#39;un total de &#34;total&#34;.
    Paràmetres:
        a: vector amb els coeficients dels paràmetres
        b: terme independent
        p: índex que representa la incògnita
        total: nombre total d&#39;incònites
    Exemple:
       e = EquacioParametrica(Vector(3,-2,1),5,1,4) genera l&#39;equació
                    - y + 3*t1 - 2*t2 + t3 + 5
       e = EquacioParametrica(Vector(3,-2,1,3],-5,3,7) genera l&#39;equació
           - x3 + 3*t1 - 2*t2 + t3 + 3*t4 + 7*t5 - 5
    Observació:
        si hi ha un màxim de quatre incògnites, son (x,y,z,t)
        si n&#39;hi ha més, són (x1,x2,x3,x4,...)
    &#34;&#34;&#34;
    if not isinstance(a,Vector):
        return None
    if p &gt;= total:
        return None
    if total &lt;= 4:
        x, y, z, t = symbols(&#39;x y z t&#39;)
        unknowns = [x,y,z,t]
    else:
        x1, x2, x3, x4, x5, x6, x7, x8 = symbols(&#39;x1 x2 x3 x4 x5 x6 x7 x8&#39;)
        unknowns = [x1,x2,x3,x4,x5,x6,x7,x8]
    t1, t2, t3, t4, t5, t6, t7, t8 = symbols(&#39;t1 t2 t3 t4 t5 t6 t7 t8&#39;)
    parameters = [t1,t2,t3,t4,t5,t6,t7,t8]
    eq = - unknowns[p]
    cls.unknown = unknowns[p]
    for k in range(a.dimensio):
        eq += a[k] * parameters[k]
    eq += b
    return cls(eq,amp)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Algebra.EquacionsParametriques"><code class="flex name class">
<span>class <span class="ident">EquacionsParametriques</span></span>
<span>(</span><span>a, b, amp=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Classe per treballar amb sistemes d'equacions paramètriques</p>
<h2 id="atributs">Atributs</h2>
<p>A: matriu dels coeficients dels paràmetres
B: vector dels termes independents
equacions: llista de EquacioParametrica
nombre: nombre d'equacions</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EquacionsParametriques(object):
    &#34;&#34;&#34;
    Classe per treballar amb sistemes d&#39;equacions paramètriques
    Atributs:
        A: matriu dels coeficients dels paràmetres
        B: vector dels termes independents
        equacions: llista de EquacioParametrica
        nombre: nombre d&#39;equacions
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,a,b,amp=True):
        &#34;&#34;&#34;
        Contructor.
        Genera les equacions X = b + a.T on X són les incògnites i T els paràmetres

        Paràmetres:
          a: matriu dels coeficients dels paràmetres
          b: vector de termes independents
          amp: True o False en funció si s&#39;ha d&#39;escriure &amp;= o només = en la representació
               en LaTeX del sistema
        &#34;&#34;&#34;
        if not isinstance(a,Matriu):
            return None
        if not isinstance(b,Vector):
            return None
        if a.files != b.dimensio:
            return None
        return super(EquacionsParametriques,cls).__new__(cls)
    #
    #
    #
    def __init__(self,a,b,amp=True):
        self.A = a
        self.B = b
        eq = []
        files = a.vectors_fila()
        for k in range(self.A.files):
            eq.append(EquacioParametrica.coeficients(files[k],b[k],k,self.A.files,amp))
        self.equacions = eq
        self.nombre = len(eq)
    #
    #
    #
    def __repr__(self):
        &#34;&#34;&#34;
        Retorna la representació en LaTeX del sistema d&#39;equacions paramètriques
        &#34;&#34;&#34;
        l = list(map(str,self.equacions))
        eqs = &#34; \\\\ &#34;.join(l)
        return f&#34;\\left.\\aligned {eqs} \\endaligned\\;\\right\\}}&#34;
    #
    #
    #
    def eliminar_parametres(self,prime=0):
        &#34;&#34;&#34;
        Retorna el SistemaEquacions que s&#39;obté en eliminar els paràmetres dels
        sistema
        &#34;&#34;&#34;
        L, U, _ = self.A.matriu.LUdecomposition()
        r = U.rank()
        v = Vector([e.unknown for e in self.equacions])
        t = Matrix(self.nombre,1,(v - self.B).components)
        t = (L**(-1) * t)[r:]
        return SistemaEquacions.from_equacions(t,self.A.files,prime)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="Algebra.EquacionsParametriques.eliminar_parametres"><code class="name flex">
<span>def <span class="ident">eliminar_parametres</span></span>(<span>self, prime=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el SistemaEquacions que s'obté en eliminar els paràmetres dels
sistema</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eliminar_parametres(self,prime=0):
    &#34;&#34;&#34;
    Retorna el SistemaEquacions que s&#39;obté en eliminar els paràmetres dels
    sistema
    &#34;&#34;&#34;
    L, U, _ = self.A.matriu.LUdecomposition()
    r = U.rank()
    v = Vector([e.unknown for e in self.equacions])
    t = Matrix(self.nombre,1,(v - self.B).components)
    t = (L**(-1) * t)[r:]
    return SistemaEquacions.from_equacions(t,self.A.files,prime)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Algebra.FormaQuadratica"><code class="flex name class">
<span>class <span class="ident">FormaQuadratica</span></span>
<span>(</span><span>matriu, base=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Classe per treballar amb formes quadràtiques</p>
<h2 id="atributs">Atributs</h2>
<p>matriu: matriu de la forma quadrètica en la base canònica
dimensio: n
vaps: valors propis
base: base oronormal en la que diagonalitza</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FormaQuadratica(object):
    &#34;&#34;&#34;
    Classe per treballar amb formes quadràtiques
    Atributs:
        matriu: matriu de la forma quadrètica en la base canònica
        dimensio: n
        vaps: valors propis
        base: base oronormal en la que diagonalitza
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,matriu,base=None):
        &#34;&#34;&#34;
        Contructor:
        Retorna una forma quadràtica
        Paràmetres:
           matriu: matriu simètrica de la forma quadratica en la base &#34;base&#34;
           base: base ortonormal de R^n. Si és None, serà la canònica
        &#34;&#34;&#34;
        if not isinstance(matriu,Matriu):
            return None
        if matriu.files != matriu.columnes:
            return None
        if matriu != matriu.transposada():
            return None
        if base is not None:
            if not isinstance(base,Base):
                return None
            if not base.es_ortogonal():
                return None
            if not base.es_unitaria():
                return None
        return super(FormaQuadratica,cls).__new__(cls)
    #
    #
    #
    def __init__(self,matriu,base=None):
        self.dimensio = matriu.columnes
        if base is None:
            self.matriu = matriu
        else:
            c = base.matriu()
            self.matriu = c * matriu * c.transposada()
        e = self.matriu.matriu.eigenvects()
        vaps = []
        veps = []
        va, ve = vaps_veps_amb_signe(e,signe=1)
        vaps += va
        veps += ve
        va, ve = vaps_veps_amb_signe(e,signe=-1)
        vaps += va
        veps += ve
        s = SubespaiVectorial(veps)
        self.base = s.amplia_base(unitaria=True)
        self.vaps = Vector(vaps + (self.dimensio - len(vaps)) * [0])
    #
    #
    #
    def __repr__(self):
        &#34;&#34;&#34;
        Retorna l&#39;expressió en latex de la forma quadràtica com a polinomi
        de segon grau en la base canònica
        &#34;&#34;&#34;
        return self.latex()
    #
    #
    #
    def latex(self,base=None,prime=0):
        &#34;&#34;&#34;
        Retorna l&#39;expressió en latex de la forma quadràtica com a polinomi
        de segon grau en la base &#34;base&#34;
        Paràmetres:
            base: base de R^n. No cal que sigui ortormal. Si és None, serà la
            base canònica
            prime: nombre de primes que s&#39;escriuran a les variables del polinomi
            segon grau
        &#34;&#34;&#34;
        if self.dimensio &lt;= 4:
            x, y, z, t = symbols(&#39;x y z t&#39;)
            s = [x,y,z,t]
        else:
            x1, x2, x3, x4, x5, x6, x7, x8 = symbols(&#39;x1 x2 x3 x4 x5 x6 x7 x8&#39;)
            s = [x1, x2, x3, x4, x5, x6, x7, x8]
        s = Vector(s[0:self.dimensio])
        m = Matriu.matriu_columna(s)
        if base is None:
            q = self.matriu
        else:
            c = base.matriu()
            q = c.transposada() * self.matriu * c
        r = m.transposada() * q * m
        if self.dimensio &lt;= 4:
            expr = mylatex(r[0,0].expand())
        else:
            expr = latex(r[0,0].expand())
        if prime == 0:
            return expr
        p = prime * &#34;&#39;&#34;
        for k in s.components:
            expr = expr.replace(latex(k),latex(k)+p)
        return expr
    #
    #
    #
    @classmethod
    def aleatoria(cls,ordre=3,maxim=20,vapsnonuls=2):
        &#34;&#34;&#34;
        Retorna una forma quadràtica aleatòria
        Paràmetres:
            ordre: ordre de la matriu simètrica de la forma quadràtica
            maxim: nombre màxim dels coeficients de la matriu
            vapsnonuls: nombre mínim de valrs propis no nuls
        &#34;&#34;&#34;
        trobat = False
        while not trobat:
            vaps = Vector.aleatori(l=ordre,maxim=3)
            if len(set(vaps.components)) == 1:
                continue
            nonuls = [x for x in vaps.components if x != 0]
            if len(nonuls) &lt; vapsnonuls:
                continue
            d = Matriu.diagonal(vaps)
            b = Base.ortogonal(ordre=ordre,maxim=5)
            c = b.matriu()
            m = c * d * c.transposada()
            if m.norma_maxim() &gt; maxim:
                continue
            trobat = not m.es_diagonal()
        return cls(m)
    #
    #
    #
    def signatura(self):
        &#34;&#34;&#34;
        Retorna la signatura o índexs d&#39;inèrcia de la forma quadràtica
        &#34;&#34;&#34;
        r = 0
        s = 0
        for k in self.vaps.components:
            if k &gt; 0:
                r += 1
            elif k &lt; 0:
                s += 1
        return (r,s)
    #
    #
    #
    def classificacio(self):
        &#34;&#34;&#34;
        Retorna la classificació de la forma quadràtica
        &#34;&#34;&#34;
        r, s = self.signatura()
        if r == self.dimensio:
            return &#34;definida positiva&#34;
        if s == self.dimensio:
            return &#34;definida negativa&#34;
        if s == 0:
            return &#34;semidefinida positiva&#34;
        if r == 0:
            return &#34;semidefinida negativa&#34;
        return &#34;indefinida&#34;
    #
    #
    #
    def rank(self):
        &#34;&#34;&#34;
        Retorna el rang de la forma quadràtica
        &#34;&#34;&#34;
        r, s = self.signatura()
        return r + s
    #
    #
    #
    def polinomi_caracteristic(self):
        &#34;&#34;&#34;
        Retorna el polinomi característic de la forma quadràtica
        &#34;&#34;&#34;
        return self.matriu.polinomi_caracteristic()
    #
    #
    #
    def expressio_euclidiana(self,prime=1):
        &#34;&#34;&#34;
        Retorna l&#39;expressió euclidiana reduïda de la forma de polinomi
        expressat en LaTeX
        Paràmetres:
            prime: nombre de primes que s&#39;escriuran a les variables
        &#34;&#34;&#34;
        return self.latex(self.base,prime=prime)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="Algebra.FormaQuadratica.aleatoria"><code class="name flex">
<span>def <span class="ident">aleatoria</span></span>(<span>ordre=3, maxim=20, vapsnonuls=2)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna una forma quadràtica aleatòria</p>
<h2 id="parametres">Paràmetres</h2>
<p>ordre: ordre de la matriu simètrica de la forma quadràtica
maxim: nombre màxim dels coeficients de la matriu
vapsnonuls: nombre mínim de valrs propis no nuls</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def aleatoria(cls,ordre=3,maxim=20,vapsnonuls=2):
    &#34;&#34;&#34;
    Retorna una forma quadràtica aleatòria
    Paràmetres:
        ordre: ordre de la matriu simètrica de la forma quadràtica
        maxim: nombre màxim dels coeficients de la matriu
        vapsnonuls: nombre mínim de valrs propis no nuls
    &#34;&#34;&#34;
    trobat = False
    while not trobat:
        vaps = Vector.aleatori(l=ordre,maxim=3)
        if len(set(vaps.components)) == 1:
            continue
        nonuls = [x for x in vaps.components if x != 0]
        if len(nonuls) &lt; vapsnonuls:
            continue
        d = Matriu.diagonal(vaps)
        b = Base.ortogonal(ordre=ordre,maxim=5)
        c = b.matriu()
        m = c * d * c.transposada()
        if m.norma_maxim() &gt; maxim:
            continue
        trobat = not m.es_diagonal()
    return cls(m)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Algebra.FormaQuadratica.classificacio"><code class="name flex">
<span>def <span class="ident">classificacio</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la classificació de la forma quadràtica</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def classificacio(self):
    &#34;&#34;&#34;
    Retorna la classificació de la forma quadràtica
    &#34;&#34;&#34;
    r, s = self.signatura()
    if r == self.dimensio:
        return &#34;definida positiva&#34;
    if s == self.dimensio:
        return &#34;definida negativa&#34;
    if s == 0:
        return &#34;semidefinida positiva&#34;
    if r == 0:
        return &#34;semidefinida negativa&#34;
    return &#34;indefinida&#34;</code></pre>
</details>
</dd>
<dt id="Algebra.FormaQuadratica.expressio_euclidiana"><code class="name flex">
<span>def <span class="ident">expressio_euclidiana</span></span>(<span>self, prime=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna l'expressió euclidiana reduïda de la forma de polinomi
expressat en LaTeX</p>
<h2 id="parametres">Paràmetres</h2>
<p>prime: nombre de primes que s'escriuran a les variables</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expressio_euclidiana(self,prime=1):
    &#34;&#34;&#34;
    Retorna l&#39;expressió euclidiana reduïda de la forma de polinomi
    expressat en LaTeX
    Paràmetres:
        prime: nombre de primes que s&#39;escriuran a les variables
    &#34;&#34;&#34;
    return self.latex(self.base,prime=prime)</code></pre>
</details>
</dd>
<dt id="Algebra.FormaQuadratica.latex"><code class="name flex">
<span>def <span class="ident">latex</span></span>(<span>self, base=None, prime=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna l'expressió en latex de la forma quadràtica com a polinomi
de segon grau en la base "base"</p>
<h2 id="parametres">Paràmetres</h2>
<p>base: base de R^n. No cal que sigui ortormal. Si és None, serà la
base canònica
prime: nombre de primes que s'escriuran a les variables del polinomi
segon grau</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def latex(self,base=None,prime=0):
    &#34;&#34;&#34;
    Retorna l&#39;expressió en latex de la forma quadràtica com a polinomi
    de segon grau en la base &#34;base&#34;
    Paràmetres:
        base: base de R^n. No cal que sigui ortormal. Si és None, serà la
        base canònica
        prime: nombre de primes que s&#39;escriuran a les variables del polinomi
        segon grau
    &#34;&#34;&#34;
    if self.dimensio &lt;= 4:
        x, y, z, t = symbols(&#39;x y z t&#39;)
        s = [x,y,z,t]
    else:
        x1, x2, x3, x4, x5, x6, x7, x8 = symbols(&#39;x1 x2 x3 x4 x5 x6 x7 x8&#39;)
        s = [x1, x2, x3, x4, x5, x6, x7, x8]
    s = Vector(s[0:self.dimensio])
    m = Matriu.matriu_columna(s)
    if base is None:
        q = self.matriu
    else:
        c = base.matriu()
        q = c.transposada() * self.matriu * c
    r = m.transposada() * q * m
    if self.dimensio &lt;= 4:
        expr = mylatex(r[0,0].expand())
    else:
        expr = latex(r[0,0].expand())
    if prime == 0:
        return expr
    p = prime * &#34;&#39;&#34;
    for k in s.components:
        expr = expr.replace(latex(k),latex(k)+p)
    return expr</code></pre>
</details>
</dd>
<dt id="Algebra.FormaQuadratica.polinomi_caracteristic"><code class="name flex">
<span>def <span class="ident">polinomi_caracteristic</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el polinomi característic de la forma quadràtica</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def polinomi_caracteristic(self):
    &#34;&#34;&#34;
    Retorna el polinomi característic de la forma quadràtica
    &#34;&#34;&#34;
    return self.matriu.polinomi_caracteristic()</code></pre>
</details>
</dd>
<dt id="Algebra.FormaQuadratica.rank"><code class="name flex">
<span>def <span class="ident">rank</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el rang de la forma quadràtica</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rank(self):
    &#34;&#34;&#34;
    Retorna el rang de la forma quadràtica
    &#34;&#34;&#34;
    r, s = self.signatura()
    return r + s</code></pre>
</details>
</dd>
<dt id="Algebra.FormaQuadratica.signatura"><code class="name flex">
<span>def <span class="ident">signatura</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la signatura o índexs d'inèrcia de la forma quadràtica</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def signatura(self):
    &#34;&#34;&#34;
    Retorna la signatura o índexs d&#39;inèrcia de la forma quadràtica
    &#34;&#34;&#34;
    r = 0
    s = 0
    for k in self.vaps.components:
        if k &gt; 0:
            r += 1
        elif k &lt; 0:
            s += 1
    return (r,s)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Algebra.Hiperbola"><code class="flex name class">
<span>class <span class="ident">Hiperbola</span></span>
<span>(</span><span>a2, b2, centre, eix)</span>
</code></dt>
<dd>
<div class="desc"><p>Classe per treballar amb hipèrboles</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Hiperbola(Conica):
    &#34;&#34;&#34;
    Classe per treballar amb hipèrboles
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,a2,b2,centre,eix):
        &#34;&#34;&#34;
        Constructor.
        Retorna una hipèrbola
        Paràmetres:
            a2: semieix real al quadrat
            b2: semieix imaginari al quadrat
            centre: centre de la hipèrbola
            eix: direcció de l&#39;eix principal (de les x&#39;)
        &#34;&#34;&#34;
        if not isinstance(centre,Punt):
            return None
        if not isinstance(eix,Vector):
            return None
        if centre.dimensio != 2:
            return None
        if eix.dimensio != 2:
            return None
        if eix.length() == 0:
            return None
        if a2 &lt;= 0:
            return None
        if b2 &lt;= 0:
            return None
        return super(Conica,cls).__new__(cls)
    #
    #
    #
    def __init__(self,a2,b2,centre,eix):
        if eix[0] &lt; 0:
            eix = -eix
        s = SubespaiVectorial([eix])
        base = s.amplia_base(unitaria=True)
        r = ReferenciaAfi(centre,base)
        g = gcd(a2,b2)
        t = a2 * b2 // g
        a2 = a2 // g
        b2 = b2 // g
        m = Matriu.diagonal(Vector([b2,-a2,-t]))
        Conica.__init__(self,m,r)
    #
    #
    #
    @classmethod
    def aleatoria(cls,canonica=False,focus=False):
        &#34;&#34;&#34;
        Retorna una hipèrbola aleatòria
        Paràmetres:
          canonica: si els eixos principals són paral·lels als de la
             referència canònica
          focus: si els focus han de tenir coordenades enteres
        &#34;&#34;&#34;
        if canonica:
            base = [Vector(1,0),Vector(0,1)]
            random.shuffle(base)
            eix = base[0]
        else:
            eix = Vector.aleatori(l=2,maxim=3,nuls=False)
        centre = Punt.aleatori(l=2,maxim=3,nuls=False)
        values = [1,2,3,4,5,5,7,8,9,10]
        trobat = False
        while not trobat:
            a = random.randint(0,len(values) - 1)
            a2 = values[a]
            if focus:
                c2 = a2 + random.randint(1,3)
                b2 = sqrt(c2 - a2)
            else:
                a = random.randint(0,len(values) - 1)
                b2 = values[a]
            trobat = a2 != b2
        l = eix.length()
        a2 = (a2*l)**2
        if focus:
            c2 = (c2*l)**2
            b2 = c2 - a2
        else:
            b2 = (b2*l)**2
        return cls(a2,b2,centre,eix)
    #
    #
    #
    def centre(self):
        &#34;&#34;&#34;
        Retorna el centre de la el·lipse
        &#34;&#34;&#34;
        return (self.ref.origen)
    #
    #
    #
    def maxim_origen(self):
        &#34;&#34;&#34;
        Retorna el màxim dels valors absoluts de les coordenades del centre
        &#34;&#34;&#34;
        return self.ref.origen.maxim()
    #
    #
    #
    def semieix_real(self):
        &#34;&#34;&#34;
        Retorna el semieix real
        &#34;&#34;&#34;
        l1 = self.matriu[0,0]
        f = - self.matriu[2,2]
        return sqrt(Rational(f,l1))
    #
    #
    #
    def semieix_imaginari(self):
        &#34;&#34;&#34;
        Retorna el semieix imaginari
        &#34;&#34;&#34;
        l2 = - self.matriu[1,1]
        f = - self.matriu[2,2]
        return sqrt(Rational(f,l2))
    #
    #
    #
    def semidistancia_focal(self):
        &#34;&#34;&#34;
        Retorna la simidistància focal
        &#34;&#34;&#34;
        a2 = self.semieix_real()**2
        b2 = self.semieix_imaginari()**2
        return sqrt(a2 + b2)
    #
    #
    #
    def equacio_reduida(self):
        &#34;&#34;&#34;
        Retorna l&#39;equacio reduïda de la hipèrbola en format LaTeX
        &#34;&#34;&#34;
        a2 = self.semieix_real()**2
        b2 = self.semieix_imaginari()**2
        if a2 == 1:
            return f&#34;x&#39;^2 - \\frac{{y&#39;^2}}{{{b2}}} = 1&#34;
        if b2 == 1:
            return f&#34;\\frac{{x&#39;^2}}{{{a2}}} - y&#39;^2 = 1&#34;
        return f&#34;\\frac{{x&#39;^2}}{{{a2}}} - \\frac{{y&#39;^2}}{{{b2}}} = 1&#34;
    #
    #
    #
    def focus(self):
        &#34;&#34;&#34;
        Retorna els focus de la hipèrbola
        &#34;&#34;&#34;
        c = self.semidistancia_focal()
        f = [Punt(c,0),Punt(-c,0)]
        return list(map(self.ref.punt_de_coordenades,f))
    #
    #
    #
    def vertexs(self):
        &#34;&#34;&#34;
        Retorna els vèrtexs de la hipèrbola
        &#34;&#34;&#34;
        a = self.semieix_real()
        v = [Punt(a,0),Punt(-a,0)]
        return list(map(self.ref.punt_de_coordenades,v))
    #
    #
    #
    def vectors_directors_asimptotes(self):
        &#34;&#34;&#34;
        Retorna els vectors directors de les asímptotes expressats en la
        base canònica
        &#34;&#34;&#34;
        l = self.ref.base.vecs[0].length()
        a = l * self.semieix_real()
        b = l * self.semieix_imaginari()
        v1 = self.ref.base.vector_de_components(Vector([a,b]))
        v2 = self.ref.base.vector_de_components(Vector([a,-b]))
        v1.radsimplificar()
        v2.radsimplificar()
        return (v1,v2)
    #
    #
    #
    def equacio_continua_asimptota(self,v):
        &#34;&#34;&#34;
        Retorna l&#39;equació contínua de l&#39;asímptota amb direccio v en format LaTeX
        Paràmetres:
            v: vector director de l&#39;asímptota
        &#34;&#34;&#34;
        x, y = symbols(&#39;x y&#39;)
        centre = self.centre()
        if v[0] == 1:
            str = latex(x - centre[0])
        else:
            str = f&#34;\\frac{{ {latex(x - centre[0])} }}{{ {v[0]} }}&#34;
        str += &#34; = &#34;
        if v[1] == 1:
            str += latex(y - centre[1])
        else:
            str += f&#34;\\frac{{ {latex(y - centre[1])} }}{{ {v[1]} }}&#34;
        return str
    #
    #
    #
    def to_asy(self,scaled=1.0,canonica=10,x=8,y=8):
        &#34;&#34;&#34;
        Retorna una expressió per fer servir amb el programa Asymtote
        Paràmetres:
            scaled: factor d&#39;escalat
            canonica = valors de partida dels eixos de la referència canònica
            x, y: nombres enters. El gràfic es representarà en una quadricula
            de límits (-x,x) i (-y,y)
        &#34;&#34;&#34;
        a2 = self.semieix_real()**2
        b2 = self.semieix_imaginari()**2
        centre = self.centre()
        vector = self.vectors()[0]
        if vector[0] &lt; 0:
            vector = -vector
        mx, Mx  = -canonica + centre[0],canonica + centre[0]
        my, My  = -canonica + centre[1],canonica + centre[1]
        str = f&#34;Canonica({mx},{Mx},{my},{My},scaled={scaled});&#34;
        clip = f&#34;path cl = ({mx},{my})--({Mx},{my})--({Mx},{My})--({mx},{My})--cycle;\n&#34;
        clip += f&#34;cl = scale({scaled}) * cl;\nclip(cl);&#34;
        return f&#34;{str}\nHiperbola({centre},{vector},{a2},{b2},x={x},y={y},scaled={scaled});\n{clip}&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Algebra.Conica" href="#Algebra.Conica">Conica</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="Algebra.Hiperbola.aleatoria"><code class="name flex">
<span>def <span class="ident">aleatoria</span></span>(<span>canonica=False, focus=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna una hipèrbola aleatòria</p>
<h2 id="parametres">Paràmetres</h2>
<p>canonica: si els eixos principals són paral·lels als de la
referència canònica
focus: si els focus han de tenir coordenades enteres</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def aleatoria(cls,canonica=False,focus=False):
    &#34;&#34;&#34;
    Retorna una hipèrbola aleatòria
    Paràmetres:
      canonica: si els eixos principals són paral·lels als de la
         referència canònica
      focus: si els focus han de tenir coordenades enteres
    &#34;&#34;&#34;
    if canonica:
        base = [Vector(1,0),Vector(0,1)]
        random.shuffle(base)
        eix = base[0]
    else:
        eix = Vector.aleatori(l=2,maxim=3,nuls=False)
    centre = Punt.aleatori(l=2,maxim=3,nuls=False)
    values = [1,2,3,4,5,5,7,8,9,10]
    trobat = False
    while not trobat:
        a = random.randint(0,len(values) - 1)
        a2 = values[a]
        if focus:
            c2 = a2 + random.randint(1,3)
            b2 = sqrt(c2 - a2)
        else:
            a = random.randint(0,len(values) - 1)
            b2 = values[a]
        trobat = a2 != b2
    l = eix.length()
    a2 = (a2*l)**2
    if focus:
        c2 = (c2*l)**2
        b2 = c2 - a2
    else:
        b2 = (b2*l)**2
    return cls(a2,b2,centre,eix)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Algebra.Hiperbola.centre"><code class="name flex">
<span>def <span class="ident">centre</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el centre de la el·lipse</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def centre(self):
    &#34;&#34;&#34;
    Retorna el centre de la el·lipse
    &#34;&#34;&#34;
    return (self.ref.origen)</code></pre>
</details>
</dd>
<dt id="Algebra.Hiperbola.equacio_continua_asimptota"><code class="name flex">
<span>def <span class="ident">equacio_continua_asimptota</span></span>(<span>self, v)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna l'equació contínua de l'asímptota amb direccio v en format LaTeX</p>
<h2 id="parametres">Paràmetres</h2>
<p>v: vector director de l'asímptota</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def equacio_continua_asimptota(self,v):
    &#34;&#34;&#34;
    Retorna l&#39;equació contínua de l&#39;asímptota amb direccio v en format LaTeX
    Paràmetres:
        v: vector director de l&#39;asímptota
    &#34;&#34;&#34;
    x, y = symbols(&#39;x y&#39;)
    centre = self.centre()
    if v[0] == 1:
        str = latex(x - centre[0])
    else:
        str = f&#34;\\frac{{ {latex(x - centre[0])} }}{{ {v[0]} }}&#34;
    str += &#34; = &#34;
    if v[1] == 1:
        str += latex(y - centre[1])
    else:
        str += f&#34;\\frac{{ {latex(y - centre[1])} }}{{ {v[1]} }}&#34;
    return str</code></pre>
</details>
</dd>
<dt id="Algebra.Hiperbola.equacio_reduida"><code class="name flex">
<span>def <span class="ident">equacio_reduida</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna l'equacio reduïda de la hipèrbola en format LaTeX</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def equacio_reduida(self):
    &#34;&#34;&#34;
    Retorna l&#39;equacio reduïda de la hipèrbola en format LaTeX
    &#34;&#34;&#34;
    a2 = self.semieix_real()**2
    b2 = self.semieix_imaginari()**2
    if a2 == 1:
        return f&#34;x&#39;^2 - \\frac{{y&#39;^2}}{{{b2}}} = 1&#34;
    if b2 == 1:
        return f&#34;\\frac{{x&#39;^2}}{{{a2}}} - y&#39;^2 = 1&#34;
    return f&#34;\\frac{{x&#39;^2}}{{{a2}}} - \\frac{{y&#39;^2}}{{{b2}}} = 1&#34;</code></pre>
</details>
</dd>
<dt id="Algebra.Hiperbola.focus"><code class="name flex">
<span>def <span class="ident">focus</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna els focus de la hipèrbola</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def focus(self):
    &#34;&#34;&#34;
    Retorna els focus de la hipèrbola
    &#34;&#34;&#34;
    c = self.semidistancia_focal()
    f = [Punt(c,0),Punt(-c,0)]
    return list(map(self.ref.punt_de_coordenades,f))</code></pre>
</details>
</dd>
<dt id="Algebra.Hiperbola.maxim_origen"><code class="name flex">
<span>def <span class="ident">maxim_origen</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el màxim dels valors absoluts de les coordenades del centre</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def maxim_origen(self):
    &#34;&#34;&#34;
    Retorna el màxim dels valors absoluts de les coordenades del centre
    &#34;&#34;&#34;
    return self.ref.origen.maxim()</code></pre>
</details>
</dd>
<dt id="Algebra.Hiperbola.semidistancia_focal"><code class="name flex">
<span>def <span class="ident">semidistancia_focal</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la simidistància focal</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def semidistancia_focal(self):
    &#34;&#34;&#34;
    Retorna la simidistància focal
    &#34;&#34;&#34;
    a2 = self.semieix_real()**2
    b2 = self.semieix_imaginari()**2
    return sqrt(a2 + b2)</code></pre>
</details>
</dd>
<dt id="Algebra.Hiperbola.semieix_imaginari"><code class="name flex">
<span>def <span class="ident">semieix_imaginari</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el semieix imaginari</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def semieix_imaginari(self):
    &#34;&#34;&#34;
    Retorna el semieix imaginari
    &#34;&#34;&#34;
    l2 = - self.matriu[1,1]
    f = - self.matriu[2,2]
    return sqrt(Rational(f,l2))</code></pre>
</details>
</dd>
<dt id="Algebra.Hiperbola.semieix_real"><code class="name flex">
<span>def <span class="ident">semieix_real</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el semieix real</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def semieix_real(self):
    &#34;&#34;&#34;
    Retorna el semieix real
    &#34;&#34;&#34;
    l1 = self.matriu[0,0]
    f = - self.matriu[2,2]
    return sqrt(Rational(f,l1))</code></pre>
</details>
</dd>
<dt id="Algebra.Hiperbola.to_asy"><code class="name flex">
<span>def <span class="ident">to_asy</span></span>(<span>self, scaled=1.0, canonica=10, x=8, y=8)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna una expressió per fer servir amb el programa Asymtote</p>
<h2 id="parametres">Paràmetres</h2>
<p>scaled: factor d'escalat
canonica = valors de partida dels eixos de la referència canònica
x, y: nombres enters. El gràfic es representarà en una quadricula
de límits (-x,x) i (-y,y)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_asy(self,scaled=1.0,canonica=10,x=8,y=8):
    &#34;&#34;&#34;
    Retorna una expressió per fer servir amb el programa Asymtote
    Paràmetres:
        scaled: factor d&#39;escalat
        canonica = valors de partida dels eixos de la referència canònica
        x, y: nombres enters. El gràfic es representarà en una quadricula
        de límits (-x,x) i (-y,y)
    &#34;&#34;&#34;
    a2 = self.semieix_real()**2
    b2 = self.semieix_imaginari()**2
    centre = self.centre()
    vector = self.vectors()[0]
    if vector[0] &lt; 0:
        vector = -vector
    mx, Mx  = -canonica + centre[0],canonica + centre[0]
    my, My  = -canonica + centre[1],canonica + centre[1]
    str = f&#34;Canonica({mx},{Mx},{my},{My},scaled={scaled});&#34;
    clip = f&#34;path cl = ({mx},{my})--({Mx},{my})--({Mx},{My})--({mx},{My})--cycle;\n&#34;
    clip += f&#34;cl = scale({scaled}) * cl;\nclip(cl);&#34;
    return f&#34;{str}\nHiperbola({centre},{vector},{a2},{b2},x={x},y={y},scaled={scaled});\n{clip}&#34;</code></pre>
</details>
</dd>
<dt id="Algebra.Hiperbola.vectors_directors_asimptotes"><code class="name flex">
<span>def <span class="ident">vectors_directors_asimptotes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna els vectors directors de les asímptotes expressats en la
base canònica</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vectors_directors_asimptotes(self):
    &#34;&#34;&#34;
    Retorna els vectors directors de les asímptotes expressats en la
    base canònica
    &#34;&#34;&#34;
    l = self.ref.base.vecs[0].length()
    a = l * self.semieix_real()
    b = l * self.semieix_imaginari()
    v1 = self.ref.base.vector_de_components(Vector([a,b]))
    v2 = self.ref.base.vector_de_components(Vector([a,-b]))
    v1.radsimplificar()
    v2.radsimplificar()
    return (v1,v2)</code></pre>
</details>
</dd>
<dt id="Algebra.Hiperbola.vertexs"><code class="name flex">
<span>def <span class="ident">vertexs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna els vèrtexs de la hipèrbola</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertexs(self):
    &#34;&#34;&#34;
    Retorna els vèrtexs de la hipèrbola
    &#34;&#34;&#34;
    a = self.semieix_real()
    v = [Punt(a,0),Punt(-a,0)]
    return list(map(self.ref.punt_de_coordenades,v))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Algebra.Conica" href="#Algebra.Conica">Conica</a></b></code>:
<ul class="hlist">
<li><code><a title="Algebra.Conica.eix_principal" href="#Algebra.Conica.eix_principal">eix_principal</a></code></li>
<li><code><a title="Algebra.Conica.eix_secundari" href="#Algebra.Conica.eix_secundari">eix_secundari</a></code></li>
<li><code><a title="Algebra.Conica.ellipse" href="#Algebra.Conica.ellipse">ellipse</a></code></li>
<li><code><a title="Algebra.Conica.equacio" href="#Algebra.Conica.equacio">equacio</a></code></li>
<li><code><a title="Algebra.Conica.from_equacio" href="#Algebra.Conica.from_equacio">from_equacio</a></code></li>
<li><code><a title="Algebra.Conica.hiperbola" href="#Algebra.Conica.hiperbola">hiperbola</a></code></li>
<li><code><a title="Algebra.Conica.parabola" href="#Algebra.Conica.parabola">parabola</a></code></li>
<li><code><a title="Algebra.Conica.referencia_principal" href="#Algebra.Conica.referencia_principal">referencia_principal</a></code></li>
<li><code><a title="Algebra.Conica.tipus" href="#Algebra.Conica.tipus">tipus</a></code></li>
<li><code><a title="Algebra.Conica.vectors" href="#Algebra.Conica.vectors">vectors</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Algebra.HiperboloideDuesFulles"><code class="flex name class">
<span>class <span class="ident">HiperboloideDuesFulles</span></span>
<span>(</span><span>a2, b2, c2, centre, eix1, eix2)</span>
</code></dt>
<dd>
<div class="desc"><p>Classe per treballar amb hiperboloides de dues fulles</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HiperboloideDuesFulles(Quadrica):
    &#34;&#34;&#34;
    Classe per treballar amb hiperboloides de dues fulles
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,a2,b2,c2,centre,eix1,eix2):
        &#34;&#34;&#34;
        Constructor.
        Paràmetres:
           a2, b2, c2: semieixos al quadrat
           eix1: direcció de l&#39;eix principal (de les x&#39;)
           eix2: en pricipi és la direcció de l&#39;eix de les y&#39;, però si no és
                 perpendicular a eix1, es calcula el perpendicular que està
                 en el mateix pla vectorial que &lt;eix1,eix2&gt; aplicant el
                 mètode de Gram-Schmidt
        &#34;&#34;&#34;
        if not isinstance(centre,Punt):
            return None
        if not isinstance(eix1,Vector):
            return None
        if not isinstance(eix2,Vector):
            return None
        if centre.dimensio != 3:
            return None
        if eix1.dimensio != 3:
            return None
        if eix2.dimensio != 3:
            return None
        if eix1.length() == 0:
            return None
        if eix2.length() == 0:
            return None
        m = Matriu.from_vectors_columna([eix1,eix2])
        if m.rank() != 2:
            return None
        if a2 &lt;= 0:
            return None
        if b2 &lt;= 0:
            return None
        if c2 &lt;= 0:
            return None
        return super(Quadrica,cls).__new__(cls)
    #
    #
    #
    def __init__(self,a2,b2,c2,centre,eix1,eix2):
        s = SubespaiVectorial([eix1,eix2])
        base = s.amplia_base(unitaria=True)
        r = ReferenciaAfi(centre,base)
        g = mcm_llista([a2,b2,c2])
        t = g
        a2 = g // a2
        b2 = g // b2
        c2 = g // c2
        m = Matriu.diagonal(Vector([a2,b2,-c2,g]))
        Quadrica.__init__(self,m,r)
    #
    #
    #
    @classmethod
    def aleatoria(cls,canonica=False):
        &#34;&#34;&#34;
        Retorna un hiperboloide de dues fulles de manera aleatòria aleatòria
        &#34;&#34;&#34;
        if canonica:
            v = [Vector(1,0,0),Vector(0,1,0),Vector(0,0,1)]
            random.shuffle(v)
            eix1, eix2, _ = v
        else:
            trobat = False
            while not trobat:
                eix1 = Vector.aleatori(l=3,maxim=3)
                eix2 = Vector.aleatori(l=3,maxim=3)
                if eix1.nzeros() &gt; 1 or eix2.nzeros() &gt; 1:
                    continue
                trobat = Matriu.from_vectors_columna([eix1,eix2]).rank() == 2
        trobat = False
        while not trobat:
            centre = Punt.aleatori(l=3,maxim=4,nuls=False)
            trobat = centre.length() &gt; 0
        c = [1,2,3,4,5,8,10,12,16,18,20,25,36]
        trobat = False
        while not trobat:
            a = random.randint(0,len(c) - 1)
            a2 = c[a]
            a = random.randint(0,len(c) - 1)
            b2 = c[a]
            a = random.randint(0,len(c) - 1)
            c2 = c[a]
            trobat = a2 != b2 or a2 != c2
        a2, b2 = sorted([a2,b2])[::-1]
        return cls(a2,b2,c2,centre,eix1,eix2)
    #
    #
    #
    def centre(self):
        &#34;&#34;&#34;
        Retorna el centre de l&#39;hiperboloide de dues fulles
        &#34;&#34;&#34;
        return (self.ref.origen)
    #
    #
    #
    def semieixos(self):
        &#34;&#34;&#34;
        Retorna els semieixos de l&#39;hiperboloide de dues fulles
        &#34;&#34;&#34;
        a = self.matriu[0,0]
        b = self.matriu[1,1]
        c = - self.matriu[2,2]
        f = self.matriu[3,3]
        return (sqrt(Rational(f,a)),sqrt(Rational(f,b)),sqrt(Rational(f,c)))
    #
    #
    #
    def semieixos_quadrats(self):
        &#34;&#34;&#34;
        Retorna els semieixos al quadrat de l&#39;hiperboloide de dues fulles
        &#34;&#34;&#34;
        a = self.matriu[0,0]
        b = self.matriu[1,1]
        c = - self.matriu[2,2]
        f = self.matriu[3,3]
        return (Rational(f,a),Rational(f,b),Rational(f,c))
    #
    #
    #
    def equacio_reduida(self):
        &#34;&#34;&#34;
        Retorna l&#39;equacio reduïda de l&#39;hiperboloide de dues fulles
        &#34;&#34;&#34;

        a2, b2, c2 = self.semieixos_quadrats()
        if a2 == 1:
            str = &#34;x&#39;^2&#34;
        else:
            str = f&#34;\\frac{{x&#39;^2}}{{ {latex(a2)} }}&#34;
        if b2 == 1:
            str += &#34; + y&#39;^2&#34;
        else:
            str += f&#34; + \\frac{{y&#39;^2}}{{ {latex(b2)} }}&#34;
        if c2 == 1:
            str += &#34; - z&#39;^2 = -1&#34;
        else:
            str += f&#34; - \\frac{{z&#39;^2}}{{ {latex(c2)} }} = -1&#34;
        return str</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Algebra.Quadrica" href="#Algebra.Quadrica">Quadrica</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="Algebra.HiperboloideDuesFulles.aleatoria"><code class="name flex">
<span>def <span class="ident">aleatoria</span></span>(<span>canonica=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna un hiperboloide de dues fulles de manera aleatòria aleatòria</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def aleatoria(cls,canonica=False):
    &#34;&#34;&#34;
    Retorna un hiperboloide de dues fulles de manera aleatòria aleatòria
    &#34;&#34;&#34;
    if canonica:
        v = [Vector(1,0,0),Vector(0,1,0),Vector(0,0,1)]
        random.shuffle(v)
        eix1, eix2, _ = v
    else:
        trobat = False
        while not trobat:
            eix1 = Vector.aleatori(l=3,maxim=3)
            eix2 = Vector.aleatori(l=3,maxim=3)
            if eix1.nzeros() &gt; 1 or eix2.nzeros() &gt; 1:
                continue
            trobat = Matriu.from_vectors_columna([eix1,eix2]).rank() == 2
    trobat = False
    while not trobat:
        centre = Punt.aleatori(l=3,maxim=4,nuls=False)
        trobat = centre.length() &gt; 0
    c = [1,2,3,4,5,8,10,12,16,18,20,25,36]
    trobat = False
    while not trobat:
        a = random.randint(0,len(c) - 1)
        a2 = c[a]
        a = random.randint(0,len(c) - 1)
        b2 = c[a]
        a = random.randint(0,len(c) - 1)
        c2 = c[a]
        trobat = a2 != b2 or a2 != c2
    a2, b2 = sorted([a2,b2])[::-1]
    return cls(a2,b2,c2,centre,eix1,eix2)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Algebra.HiperboloideDuesFulles.centre"><code class="name flex">
<span>def <span class="ident">centre</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el centre de l'hiperboloide de dues fulles</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def centre(self):
    &#34;&#34;&#34;
    Retorna el centre de l&#39;hiperboloide de dues fulles
    &#34;&#34;&#34;
    return (self.ref.origen)</code></pre>
</details>
</dd>
<dt id="Algebra.HiperboloideDuesFulles.equacio_reduida"><code class="name flex">
<span>def <span class="ident">equacio_reduida</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna l'equacio reduïda de l'hiperboloide de dues fulles</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def equacio_reduida(self):
    &#34;&#34;&#34;
    Retorna l&#39;equacio reduïda de l&#39;hiperboloide de dues fulles
    &#34;&#34;&#34;

    a2, b2, c2 = self.semieixos_quadrats()
    if a2 == 1:
        str = &#34;x&#39;^2&#34;
    else:
        str = f&#34;\\frac{{x&#39;^2}}{{ {latex(a2)} }}&#34;
    if b2 == 1:
        str += &#34; + y&#39;^2&#34;
    else:
        str += f&#34; + \\frac{{y&#39;^2}}{{ {latex(b2)} }}&#34;
    if c2 == 1:
        str += &#34; - z&#39;^2 = -1&#34;
    else:
        str += f&#34; - \\frac{{z&#39;^2}}{{ {latex(c2)} }} = -1&#34;
    return str</code></pre>
</details>
</dd>
<dt id="Algebra.HiperboloideDuesFulles.semieixos"><code class="name flex">
<span>def <span class="ident">semieixos</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna els semieixos de l'hiperboloide de dues fulles</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def semieixos(self):
    &#34;&#34;&#34;
    Retorna els semieixos de l&#39;hiperboloide de dues fulles
    &#34;&#34;&#34;
    a = self.matriu[0,0]
    b = self.matriu[1,1]
    c = - self.matriu[2,2]
    f = self.matriu[3,3]
    return (sqrt(Rational(f,a)),sqrt(Rational(f,b)),sqrt(Rational(f,c)))</code></pre>
</details>
</dd>
<dt id="Algebra.HiperboloideDuesFulles.semieixos_quadrats"><code class="name flex">
<span>def <span class="ident">semieixos_quadrats</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna els semieixos al quadrat de l'hiperboloide de dues fulles</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def semieixos_quadrats(self):
    &#34;&#34;&#34;
    Retorna els semieixos al quadrat de l&#39;hiperboloide de dues fulles
    &#34;&#34;&#34;
    a = self.matriu[0,0]
    b = self.matriu[1,1]
    c = - self.matriu[2,2]
    f = self.matriu[3,3]
    return (Rational(f,a),Rational(f,b),Rational(f,c))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Algebra.Quadrica" href="#Algebra.Quadrica">Quadrica</a></b></code>:
<ul class="hlist">
<li><code><a title="Algebra.Quadrica.cilindreelliptic" href="#Algebra.Quadrica.cilindreelliptic">cilindreelliptic</a></code></li>
<li><code><a title="Algebra.Quadrica.cilindrehiperbolic" href="#Algebra.Quadrica.cilindrehiperbolic">cilindrehiperbolic</a></code></li>
<li><code><a title="Algebra.Quadrica.cilindreparabolic" href="#Algebra.Quadrica.cilindreparabolic">cilindreparabolic</a></code></li>
<li><code><a title="Algebra.Quadrica.con" href="#Algebra.Quadrica.con">con</a></code></li>
<li><code><a title="Algebra.Quadrica.ellipsoide" href="#Algebra.Quadrica.ellipsoide">ellipsoide</a></code></li>
<li><code><a title="Algebra.Quadrica.equacio" href="#Algebra.Quadrica.equacio">equacio</a></code></li>
<li><code><a title="Algebra.Quadrica.from_equacio" href="#Algebra.Quadrica.from_equacio">from_equacio</a></code></li>
<li><code><a title="Algebra.Quadrica.hiperboloideduesfulles" href="#Algebra.Quadrica.hiperboloideduesfulles">hiperboloideduesfulles</a></code></li>
<li><code><a title="Algebra.Quadrica.hiperboloideunafulla" href="#Algebra.Quadrica.hiperboloideunafulla">hiperboloideunafulla</a></code></li>
<li><code><a title="Algebra.Quadrica.paraboloideelliptic" href="#Algebra.Quadrica.paraboloideelliptic">paraboloideelliptic</a></code></li>
<li><code><a title="Algebra.Quadrica.paraboloidehiperbolic" href="#Algebra.Quadrica.paraboloidehiperbolic">paraboloidehiperbolic</a></code></li>
<li><code><a title="Algebra.Quadrica.referencia_principal" href="#Algebra.Quadrica.referencia_principal">referencia_principal</a></code></li>
<li><code><a title="Algebra.Quadrica.tipus" href="#Algebra.Quadrica.tipus">tipus</a></code></li>
<li><code><a title="Algebra.Quadrica.vectors" href="#Algebra.Quadrica.vectors">vectors</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Algebra.HiperboloideUnaFulla"><code class="flex name class">
<span>class <span class="ident">HiperboloideUnaFulla</span></span>
<span>(</span><span>a2, b2, c2, centre, eix1, eix2)</span>
</code></dt>
<dd>
<div class="desc"><p>Classe per treballar amb hiperboloides d'una fulla</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HiperboloideUnaFulla(Quadrica):
    &#34;&#34;&#34;
    Classe per treballar amb hiperboloides d&#39;una fulla
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,a2,b2,c2,centre,eix1,eix2):
        &#34;&#34;&#34;
        Constructor.
        Paràmetres:
           a2, b2, c2: semieixos al quadrat
           eix1: direcció de l&#39;eix principal (de les x&#39;)
           eix2: en pricipi és la direcció de l&#39;eix de les y&#39;, però si no és
                 perpendicular a eix1, es calcula el perpendicular que està
                 en el mateix pla vectorial que &lt;eix1,eix2&gt; aplicant el
                 mètode de Gram-Schmidt
        &#34;&#34;&#34;
        if not isinstance(centre,Punt):
            return None
        if not isinstance(eix1,Vector):
            return None
        if not isinstance(eix2,Vector):
            return None
        if centre.dimensio != 3:
            return None
        if eix1.dimensio != 3:
            return None
        if eix2.dimensio != 3:
            return None
        if eix1.length() == 0:
            return None
        if eix2.length() == 0:
            return None
        m = Matriu.from_vectors_columna([eix1,eix2])
        if m.rank() != 2:
            return None
        if a2 &lt;= 0:
            return None
        if b2 &lt;= 0:
            return None
        if c2 &lt;= 0:
            return None
        return super(Quadrica,cls).__new__(cls)
    #
    #
    #
    def __init__(self,a2,b2,c2,centre,eix1,eix2):
        s = SubespaiVectorial([eix1,eix2])
        base = s.amplia_base(unitaria=True)
        r = ReferenciaAfi(centre,base)
        g = mcm_llista([a2,b2,c2])
        t = g
        a2 = g // a2
        b2 = g // b2
        c2 = g // c2
        m = Matriu.diagonal(Vector([a2,b2,-c2,-g]))
        Quadrica.__init__(self,m,r)
    #
    #
    #
    @classmethod
    def aleatoria(cls,canonica=False):
        &#34;&#34;&#34;
        Retorna un hiperboloide d&#39;una fulla de manera aleatòria
        &#34;&#34;&#34;
        if canonica:
            v = [Vector(1,0,0),Vector(0,1,0),Vector(0,0,1)]
            random.shuffle(v)
            eix1, eix2, _ = v
        else:
            trobat = False
            while not trobat:
                eix1 = Vector.aleatori(l=3,maxim=3)
                eix2 = Vector.aleatori(l=3,maxim=3)
                if eix1.nzeros() &gt; 1 or eix2.nzeros() &gt; 1:
                    continue
                trobat = Matriu.from_vectors_columna([eix1,eix2]).rank() == 2
        trobat = False
        while not trobat:
            centre = Punt.aleatori(l=3,maxim=4,nuls=False)
            trobat = centre.length() &gt; 0
        c = [1,2,3,4,5,8,10,12,16,18,20,25,36]
        trobat = False
        while not trobat:
            a = random.randint(0,len(c) - 1)
            a2 = c[a]
            a = random.randint(0,len(c) - 1)
            b2 = c[a]
            a = random.randint(0,len(c) - 1)
            c2 = c[a]
            trobat = a2 != b2 or a2 != c2
        a2, b2 = sorted([a2,b2])[::-1]
        return cls(a2,b2,c2,centre,eix1,eix2)
    #
    #
    #
    def centre(self):
        &#34;&#34;&#34;
        Retorna el centre de l&#39;el·lipsoide
        &#34;&#34;&#34;
        return (self.ref.origen)
    #
    #
    #
    def semieixos(self):
        &#34;&#34;&#34;
        Retorna els semieixos de l&#39;el·lipsoide
        &#34;&#34;&#34;
        a = self.matriu[0,0]
        b = self.matriu[1,1]
        c = - self.matriu[2,2]
        f = - self.matriu[3,3]
        return (sqrt(Rational(f,a)),sqrt(Rational(f,b)),sqrt(Rational(f,c)))
    #
    #
    #
    def semieixos_quadrats(self):
        &#34;&#34;&#34;
        Retorna els semieixos al quadrat de l&#39;el·lipsoide
        &#34;&#34;&#34;
        a = self.matriu[0,0]
        b = self.matriu[1,1]
        c = - self.matriu[2,2]
        f = - self.matriu[3,3]
        return (Rational(f,a),Rational(f,b),Rational(f,c))
    #
    #
    #
    def equacio_reduida(self):
        &#34;&#34;&#34;
        Retorna l&#39;equacio reduïda de l&#39;hiperboloide d&#39;una fulla
        &#34;&#34;&#34;
        a2, b2, c2 = self.semieixos_quadrats()
        if a2 == 1:
            str = &#34;x&#39;^2&#34;
        else:
            str = f&#34;\\frac{{x&#39;^2}}{{ {latex(a2)} }}&#34;
        if b2 == 1:
            str += &#34; + y&#39;^2&#34;
        else:
            str += f&#34; + \\frac{{y&#39;^2}}{{ {latex(b2)} }}&#34;
        if c2 == 1:
            str += &#34; - z&#39;^2 = 1&#34;
        else:
            str += f&#34; - \\frac{{z&#39;^2}}{{ {latex(c2)} }} = 1&#34;
        return str</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Algebra.Quadrica" href="#Algebra.Quadrica">Quadrica</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="Algebra.HiperboloideUnaFulla.aleatoria"><code class="name flex">
<span>def <span class="ident">aleatoria</span></span>(<span>canonica=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna un hiperboloide d'una fulla de manera aleatòria</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def aleatoria(cls,canonica=False):
    &#34;&#34;&#34;
    Retorna un hiperboloide d&#39;una fulla de manera aleatòria
    &#34;&#34;&#34;
    if canonica:
        v = [Vector(1,0,0),Vector(0,1,0),Vector(0,0,1)]
        random.shuffle(v)
        eix1, eix2, _ = v
    else:
        trobat = False
        while not trobat:
            eix1 = Vector.aleatori(l=3,maxim=3)
            eix2 = Vector.aleatori(l=3,maxim=3)
            if eix1.nzeros() &gt; 1 or eix2.nzeros() &gt; 1:
                continue
            trobat = Matriu.from_vectors_columna([eix1,eix2]).rank() == 2
    trobat = False
    while not trobat:
        centre = Punt.aleatori(l=3,maxim=4,nuls=False)
        trobat = centre.length() &gt; 0
    c = [1,2,3,4,5,8,10,12,16,18,20,25,36]
    trobat = False
    while not trobat:
        a = random.randint(0,len(c) - 1)
        a2 = c[a]
        a = random.randint(0,len(c) - 1)
        b2 = c[a]
        a = random.randint(0,len(c) - 1)
        c2 = c[a]
        trobat = a2 != b2 or a2 != c2
    a2, b2 = sorted([a2,b2])[::-1]
    return cls(a2,b2,c2,centre,eix1,eix2)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Algebra.HiperboloideUnaFulla.centre"><code class="name flex">
<span>def <span class="ident">centre</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el centre de l'el·lipsoide</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def centre(self):
    &#34;&#34;&#34;
    Retorna el centre de l&#39;el·lipsoide
    &#34;&#34;&#34;
    return (self.ref.origen)</code></pre>
</details>
</dd>
<dt id="Algebra.HiperboloideUnaFulla.equacio_reduida"><code class="name flex">
<span>def <span class="ident">equacio_reduida</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna l'equacio reduïda de l'hiperboloide d'una fulla</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def equacio_reduida(self):
    &#34;&#34;&#34;
    Retorna l&#39;equacio reduïda de l&#39;hiperboloide d&#39;una fulla
    &#34;&#34;&#34;
    a2, b2, c2 = self.semieixos_quadrats()
    if a2 == 1:
        str = &#34;x&#39;^2&#34;
    else:
        str = f&#34;\\frac{{x&#39;^2}}{{ {latex(a2)} }}&#34;
    if b2 == 1:
        str += &#34; + y&#39;^2&#34;
    else:
        str += f&#34; + \\frac{{y&#39;^2}}{{ {latex(b2)} }}&#34;
    if c2 == 1:
        str += &#34; - z&#39;^2 = 1&#34;
    else:
        str += f&#34; - \\frac{{z&#39;^2}}{{ {latex(c2)} }} = 1&#34;
    return str</code></pre>
</details>
</dd>
<dt id="Algebra.HiperboloideUnaFulla.semieixos"><code class="name flex">
<span>def <span class="ident">semieixos</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna els semieixos de l'el·lipsoide</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def semieixos(self):
    &#34;&#34;&#34;
    Retorna els semieixos de l&#39;el·lipsoide
    &#34;&#34;&#34;
    a = self.matriu[0,0]
    b = self.matriu[1,1]
    c = - self.matriu[2,2]
    f = - self.matriu[3,3]
    return (sqrt(Rational(f,a)),sqrt(Rational(f,b)),sqrt(Rational(f,c)))</code></pre>
</details>
</dd>
<dt id="Algebra.HiperboloideUnaFulla.semieixos_quadrats"><code class="name flex">
<span>def <span class="ident">semieixos_quadrats</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna els semieixos al quadrat de l'el·lipsoide</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def semieixos_quadrats(self):
    &#34;&#34;&#34;
    Retorna els semieixos al quadrat de l&#39;el·lipsoide
    &#34;&#34;&#34;
    a = self.matriu[0,0]
    b = self.matriu[1,1]
    c = - self.matriu[2,2]
    f = - self.matriu[3,3]
    return (Rational(f,a),Rational(f,b),Rational(f,c))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Algebra.Quadrica" href="#Algebra.Quadrica">Quadrica</a></b></code>:
<ul class="hlist">
<li><code><a title="Algebra.Quadrica.cilindreelliptic" href="#Algebra.Quadrica.cilindreelliptic">cilindreelliptic</a></code></li>
<li><code><a title="Algebra.Quadrica.cilindrehiperbolic" href="#Algebra.Quadrica.cilindrehiperbolic">cilindrehiperbolic</a></code></li>
<li><code><a title="Algebra.Quadrica.cilindreparabolic" href="#Algebra.Quadrica.cilindreparabolic">cilindreparabolic</a></code></li>
<li><code><a title="Algebra.Quadrica.con" href="#Algebra.Quadrica.con">con</a></code></li>
<li><code><a title="Algebra.Quadrica.ellipsoide" href="#Algebra.Quadrica.ellipsoide">ellipsoide</a></code></li>
<li><code><a title="Algebra.Quadrica.equacio" href="#Algebra.Quadrica.equacio">equacio</a></code></li>
<li><code><a title="Algebra.Quadrica.from_equacio" href="#Algebra.Quadrica.from_equacio">from_equacio</a></code></li>
<li><code><a title="Algebra.Quadrica.hiperboloideduesfulles" href="#Algebra.Quadrica.hiperboloideduesfulles">hiperboloideduesfulles</a></code></li>
<li><code><a title="Algebra.Quadrica.hiperboloideunafulla" href="#Algebra.Quadrica.hiperboloideunafulla">hiperboloideunafulla</a></code></li>
<li><code><a title="Algebra.Quadrica.paraboloideelliptic" href="#Algebra.Quadrica.paraboloideelliptic">paraboloideelliptic</a></code></li>
<li><code><a title="Algebra.Quadrica.paraboloidehiperbolic" href="#Algebra.Quadrica.paraboloidehiperbolic">paraboloidehiperbolic</a></code></li>
<li><code><a title="Algebra.Quadrica.referencia_principal" href="#Algebra.Quadrica.referencia_principal">referencia_principal</a></code></li>
<li><code><a title="Algebra.Quadrica.tipus" href="#Algebra.Quadrica.tipus">tipus</a></code></li>
<li><code><a title="Algebra.Quadrica.vectors" href="#Algebra.Quadrica.vectors">vectors</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Algebra.Impresora"><code class="flex name class">
<span>class <span class="ident">Impresora</span></span>
<span>(</span><span>settings=None)</span>
</code></dt>
<dd>
<div class="desc"><p>La funció latex() del sympy té la mania d'escriure les variables x, y, z i t
en l'ordre t, x, y i z. L'única manera que, de moment, he trobat per resoldre
aquest inconvenient és definir la classe Impresora i la funció mylatex().
Ho he trobat a StackOverflow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Impresora(Printer):
    &#34;&#34;&#34;
    La funció latex() del sympy té la mania d&#39;escriure les variables x, y, z i t
    en l&#39;ordre t, x, y i z. L&#39;única manera que, de moment, he trobat per resoldre
    aquest inconvenient és definir la classe Impresora i la funció mylatex().
    Ho he trobat a StackOverflow.
    &#34;&#34;&#34;
    printmethod = &#39;impresora&#39;
    #
    #
    #
    def _print_Add(self,expr):
        expr_args=expr.args

        def new_place(el):
            if el in ddict:
                return ddict[el]
            else:
                return len(ddict)+1

        def get_place(el):
            p, q, r, s = symbols(&#39;p q u v&#39;)
            if isinstance(el,Pow):
                return new_place(el)
            if el.is_integer:
                return new_place(el)
            elif el.is_symbol:
                return new_place(el)
            if len(el.args) == 2:
                if el.args[0].is_symbol and el.args[1].is_symbol:
                    k = -1
                    for i in range(0,2):
                        if el.args[i] not in [p,q,r,s]:
                            k = i
                    if k &gt;= 0:
                        k = (k+1) % 2
                        return new_place(el.args[k])
                    return new_place(el.args)
                q = el.args[len(el.args)-1]
                if q.is_symbol or q.is_integer or q.is_rational:
                    return new_place(q)
                elif q.args[0].is_symbol:
                    return new_place(q)
                else:
                    return 0
            elif len(el.args) == 3:
                k = -1
                for i in range(0,2):
                    if el.args[i+1] not in [p,q,r,s]:
                        k = i
                if k &gt;= 0:
                    k = (k+1) % 2
                    return new_place(el.args[k+1])
                return new_place(el.args[1:])
            else:
                return 0

        def write_coeff(el):
            if isinstance(el,Pow):
                return &#34; + %s&#34; % latex(el)
            if el.is_integer:
                if el &gt; 0:
                    return &#34; + %s&#34; % el
                else:
                    return &#34; %s&#34; % el
            elif el.is_symbol:
                return &#34; + %s&#34; % el
            elif len(el.args) == 2 and el.args[0].is_symbol and el.args[1].is_symbol:
                return &#34; + %s&#34; % latex(el)
            elif len(el.args) &gt; 0:
                if el.args[len(el.args)-1].is_symbol:
                    if el.args[0].is_rational or el.args[0].is_integer:
                        if el.args[0] &gt; 0:
                            return &#34; + %s&#34; % latex(el)
                        else:
                            return &#34; %s&#34; % latex(el)
                    else:
                        return &#34; %s&#34; % latex(el)
                else:
                    if el.args[0].is_rational or el.args[0].is_integer:
                        if el.args[0] &gt; 0:
                            return &#34; + %s&#34; % latex(el)
                    return &#34; %s&#34; % latex(el)
            else:
                return &#34; %s&#34; % el
        list_place = [get_place(a) for a in expr.args]
        expr_args = list(zip(*sorted(zip(list_place,expr_args))))[1]
        to_print = [write_coeff(a) for a in expr_args]
        to_print[0] = str(latex(expr_args[0]))
        return &#34;&#34;.join(a for a in to_print)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>sympy.printing.printer.Printer</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="Algebra.Impresora.printmethod"><code class="name">var <span class="ident">printmethod</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="Algebra.Matriu"><code class="flex name class">
<span>class <span class="ident">Matriu</span></span>
<span>(</span><span>matrix=Matrix([
[1, 0, 0],
[0, 1, 0],
[0, 0, 1]]))</span>
</code></dt>
<dd>
<div class="desc"><p>Classe que ens permetrà representar matrius. El problema de la classe
Matrix del sympy és que només es poden multiplicar per elements del tipus
Matrix.
Ens insteressa poder multiplicar Matrius per Vectors</p>
<h2 id="atributs">Atributs</h2>
<p>dimensio: nombre de files de la matriu
columnes: nombre de columnes de la matriu
matriu: matriu de la classe Matrix del sympy
format: format LateX per a la matriu
diagonalitzable: si és o no diagonalitzable</p>
<p>Només s'utilitzen quan generem una matriu diagonalitzble
vaps: llista de vectors propis de la matriu
veps: llista de vectors propis de la matriu</p>
<p>Constructor.</p>
<h2 id="parametres">Paràmetres</h2>
<p>matrix: matriu del tipus Matrix de sympy
per defecte és la matriu unitat d'ordre 3</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Matriu:
    &#34;&#34;&#34;
    Classe que ens permetrà representar matrius. El problema de la classe
    Matrix del sympy és que només es poden multiplicar per elements del tipus
    Matrix.
    Ens insteressa poder multiplicar Matrius per Vectors
    Atributs:
        dimensio: nombre de files de la matriu
        columnes: nombre de columnes de la matriu
        matriu: matriu de la classe Matrix del sympy
        format: format LateX per a la matriu
        diagonalitzable: si és o no diagonalitzable

        Només s&#39;utilitzen quan generem una matriu diagonalitzble
          vaps: llista de vectors propis de la matriu
          veps: llista de vectors propis de la matriu
    &#34;&#34;&#34;
    #
    #
    #
    def __init__(self,matrix=eye(3)):
        &#34;&#34;&#34;
        Constructor.
        Paràmetres:
          matrix: matriu del tipus Matrix de sympy
                  per defecte és la matriu unitat d&#39;ordre 3
        &#34;&#34;&#34;
        f, c = matrix.shape
        self.files = f
        self.columnes = c
        self.matriu = matrix
        self.vaps = None
        self.veps = None
        self.format = None
        self.diagonalitzable = None
    #
    #
    #
    def set_vaps(self,vaps):
        &#34;&#34;&#34;
        Assigna un llista de valors propis a la variable self.vaps
        Paràmetres:
            vaps: llista de nombres
        &#34;&#34;&#34;
        self.vaps = vaps
    #
    #
    #
    def set_veps(self,veps):
        &#34;&#34;&#34;
        Assigna un llista de vectors propis simplificats a la variable self.veps
        Paràmetres:
            vaps: llista de vectors
        &#34;&#34;&#34;
        for v in veps:
            v.simplificar()
        self.veps = veps
    #
    #
    #
    @classmethod
    def aleatoria(cls,f=3,c=3,maxim=5,nuls=True):
        &#34;&#34;&#34;
        Genera una matriu aleatoria.
        Paràmetres:
            f: nombre de files de la matriu
            c: nombre de columnes de la matriu
            maxim: tots els elements tindran valor absolut menor que &#34;maxim&#34;
            nuls: la matriu pot contenir coeficients nuls o no
        &#34;&#34;&#34;
        m = Matrix(f,c,lambda i, j : random.randint(-maxim,maxim))
        if not nuls:
            values = [i for i in range(1,maxim + 1)] + [-i for i in range(1,maxim + 1)]
            for i in range(f):
                for j in range(c):
                    if m[i,j] == 0:
                        m[i,j] = values[random.randint(0,2 * maxim - 1)]
        if nnegatius(m) &gt; (f*c)/2:
            m *= -1
        return cls(m)
    #
    #
    #
    @classmethod
    def transformacio_elemental(cls,ordre,i,j,s,t):
        &#34;&#34;&#34;
        Retorna la matriu corresponent a la transformació elemental
        F_i \sim s F_i + t F_j
        &#34;&#34;&#34;
        a = eye(ordre)
        a[i,:] = s * a[i,:] + t * a[j,:]
        return cls(a)
    #
    #
    #
    def anula_coeficient_amb_pivot(self,fc,fp):
        &#34;&#34;&#34;
        Aplicar la transformació elemental
        F_fc \sim s F_fc - t F_fp
        on s i t s&#39;obtenen de la forma següent:
           1. s és el primer coeficient no nul de la fila fp, que ocuparà la columna col
           2. t és el coeficient que ocupa la fila fc, columna col
           3. Si s i t són enters, els dividim pel seu màxim comú divisor
        Retornem la transformació elemental feta en forma de tupla (s,t)
        &#34;&#34;&#34;
        k = primer_no_nul(self.matriu[fp,:])
        if k is None:
            return 1, None
        if self.matriu[fc,k] == 0:
            return 2, None
        if primer_no_nul(self.matriu[fc,:]) != k:
            return 3, None
        s = self.matriu[fp,k]
        t = self.matriu[fc,k]
        if isinstance(s,int) or isinstance(s,Integer):
             if isinstance(t,int) or isinstance(t,Integer):
                 d = mcd_llista([t,s])
                 if abs(d) != 1:
                     s /= d
                     t /= d
        if s &lt; 0:
            s, t = -s, -t
        self.matriu[fc,:] = s * self.matriu[fc,:] - t * self.matriu[fp,:]
        return 0, (s,t)
    #
    #
    #
    def norma_maxim(self):
        &#34;&#34;&#34;
        Retorna la norma del màxim de la matriu
        &#34;&#34;&#34;
        return norma_maxim(self.matriu)
    #
    #
    #
    def nzeros(self):
        &#34;&#34;&#34;
        Retorna el nombre de zeros de la matriu
        &#34;&#34;&#34;
        return nzeros(self.matriu)
    #
    #
    #
    def nnegatius(self):
        &#34;&#34;&#34;
        Retorna el nombre de coeficients negatius de la matriu
        &#34;&#34;&#34;
        return nnegatius(self.matriu)
    #
    #
    #
    def max_diagonal(self):
        &#34;&#34;&#34;
        Retorna el màxim en valor absolut dels coeficients de la diagonal
        Si la matriu no és quadrada retorna None
        &#34;&#34;&#34;
        if self.files == 0 or self.columnes == 0:
            return 0
        max = 0
        m = min(self.files,self.columnes)
        for i in range(m):
            k = abs(self.matriu[i,i])
            if k &gt; max:
                max = k
        return max
    #
    #
    #
    def rank(self):
        &#34;&#34;&#34;
        Retorna el rang de la matriu
        &#34;&#34;&#34;
        return self.matriu.rank()
    #
    #
    #
    def rang(self):
        &#34;&#34;&#34;
        Retorna el rang de la matriu
        &#34;&#34;&#34;
        return self.matriu.rank()
    #
    #
    #
    def determinant(self):
        &#34;&#34;&#34;
        Retorna el determiant de la matriu
        &#34;&#34;&#34;
        return self.matriu.det()
    #
    #
    #
    def det(self):
        &#34;&#34;&#34;
        Retorna el determiant de la matriu
        &#34;&#34;&#34;
        return self.matriu.det()
    #
    #
    #
    def clona(self):
        &#34;&#34;&#34;
        Retorma una còpia de la matriu
        &#34;&#34;&#34;
        return Matriu(self.matriu[:,:])
    #
    #
    #
    def set_format(self,format):
        &#34;&#34;&#34;
        Estableix el format LaTeX amb que s&#39;escriurà la matriu
        &#34;&#34;&#34;
        self.format = format
    #
    #
    #
    def latex(self,format=None,tipus=&#39;p&#39;):
        &#34;&#34;&#34;
        Retorna la representació en LaTeX de la matriu
        &#34;&#34;&#34;
        if format is None:
            format = self.format
        return matriu_latex(self.matriu,format,tipus)
    #
    #
    #
    def polinomi_caracteristic(self):
        &#34;&#34;&#34;
        Retorna el polinomi característic de la matriu
        &#34;&#34;&#34;
        lamda = symbols(&#39;lamda&#39;)
        p = (-1)**(self.files) * self.matriu.charpoly(lamda)
        return latex(p.as_expr())
    #
    #
    #
    def __getitem__(self,tup):
        &#34;&#34;&#34;
        Permet indexar els elements d&#39;una matriu.
        Paràmetres:
            tup: tupla d&#39;índexs
        Exemple:
        m = Matriu.aleatoria()
        k = m[2,1]
        &#34;&#34;&#34;
        i, j = tup
        try:
            return self.matriu[i,j]
        except:
            return None
    #
    #
    #
    def __setitem__(self,tup,value):
        &#34;&#34;&#34;
        Permet assignar valors mitjançant índexs.
        Paràmetres:
            tup: tupla d&#39;índexs
            valor: valor assignat
        Exemple:
            m = Matriu.aleatoria()
            m[2,1] = 5
        &#34;&#34;&#34;
        i, j = tup
        self.matriu[i,j] = value
    #
    #
    #
    def __add__(self,other):
        &#34;&#34;&#34;
        Defineix la suma de matrius.
        Paràmetres:
            other: una altra matriu
        Exemple:
            a1 = Matriu.aleatoria()
            a2 = Matriu.aleatoria())
            b = a1 + a2
        &#34;&#34;&#34;
        if not isinstance(other,Matriu):
            return None
        if self.files != other.files:
            return None
        if self.columnes != other.columnes:
            return None
        m = self.matriu + other.matriu
        return Matriu(m)
    #
    #
    #
    def __sub__(self,other):
        &#34;&#34;&#34;
        Defineix la resta de matrius.
        Paràmetres:
            other: una altra matriu
        Exemple:
            a1 = Matriu.aleatoria()
            a2 = Matriu.aleatoria())
            b = a1 - a2
        &#34;&#34;&#34;
        if not isinstance(other,Matriu):
            return None
        if self.files != other.files:
            return None
        if self.columnes != other.columnes:
            return None
        m = self.matriu - other.matriu
        return Matriu(m)
    #
    #
    #
    def __neg__(self):
        &#34;&#34;&#34;
        Retorna l&#39;oposada de la matriu
        &#34;&#34;&#34;
        return Matriu(-self.matriu)
    #
    #
    #
    def __rmul__(self,other):
        &#34;&#34;&#34;
        Defineix el producte d&#39;un escalar per una matriu
        Paràmetrers:
            other: un escalar
        Exemple:
            a = Matriu.aleatoria(f=4,c=3,maxim=7,nuls=False)
            c = 4 * a
        &#34;&#34;&#34;
        types = [Rational,float,int,Float,Pow,Add,Mul]
        for t in types:
            if isinstance(other,t):
                return Matriu(other * self.matriu)
        return None
    #
    #
    #
    def __mul__(self,other):
        &#34;&#34;&#34;
        Defineix el producte de matrius i el producte d&#39;una matriu per un vector
        Paràmetrers:
            other: un vector (classe Vector) o un matriu (classe Matriu)
        Exemple:
            a1 = Matriu.aleatoria()
            a2 = Matriu.aleatoria()
            b = a1 * a2
            v = Vector(2,1,-1)
            w = a1 * v
        &#34;&#34;&#34;
        if isinstance(other,Matriu):
            if self.columnes != other.files:
                return None
            m = self.matriu * other.matriu
            return Matriu(m)
        if isinstance(other,Vector):
            if self.columnes != other.dimensio:
                return None
            u = Matrix(other.dimensio,1,other.components)
            v = self.matriu * u
            f, c = v.shape
            c = []
            for i in range(f):
                c.append(v[i,0])
            return Vector(c)
        return None
    #
    #
    #
    def transposada(self):
        &#34;&#34;&#34;
        Retorna la transposada de la matriu
        &#34;&#34;&#34;
        return Matriu(self.matriu.T)
    #
    #
    #
    def __repr__(self):
        &#34;&#34;&#34;
        Retorna l&#39;expressió en LaTeX de la matriu
        &#34;&#34;&#34;
        l = []
        s = []
        square = False
        for i in range(self.files):
            for j in range(self.columnes):
                k = self.matriu[i,j]
                if isinstance(k,Rational):
                    l.append(k.q)
                    s.append(False)
                elif isinstance(k,int) or isinstance(k,Integer):
                    l.append(1)
                    s.append(False)
                elif isinstance(k**2,Rational):
                    square = True
                    k2 = k**2
                    l.append(k2.q)
                    s.append(True)
                elif isinstance(k,Add):
                    for a in k.args:
                        if isinstance(a,Rational):
                            l.append(a.q)
                            s.append(False)
                        elif isinstance(a,int) or isinstance(a,Integer):
                            l.append(1)
                            s.append(False)
                        elif isinstance(a**2,Rational):
                            square = True
                            a2 = a**2
                            l.append(a2.q)
                            s.append(True)
                else:
                    return matriu_latex(self.matriu,format=self.format)
        if square:
            for k in range(len(l)):
                if not s[k]:
                    l[k] = l[k]**2
        m = mcm_llista(l)
        if square:
            m = sqrt(m)
        l = []
        for i in range(self.files):
            for j in range(self.columnes):
                l.append(m * self.matriu[i,j])
        s = &#34;&#34;
        if m != 1:
            s = f&#34;\\deufrac{{1}}{{{latex(m)}}}&#34;
        m = Matrix(self.files,self.columnes,l)
        return s + matriu_latex(m,format=self.format)
    #
    #
    #
    def __eq__(self,other):
        &#34;&#34;&#34;
        Compara si dues matriu són iguals
        Paràmetres:
            other: una altra matriu
        Exemple:
            a1 = Matriu.aleatoria()
            a2 = Matriu.aleatoria()
            if a1 == a2:
                pass
        &#34;&#34;&#34;
        if self.files != other.files:
            return False
        if self.columnes != other.columnes:
            return False
        for i in range(self.files):
            for j in range(self.columnes):
                if self.matriu[i,j] != other.matriu[i,j]:
                    return False
        return True
    #
    #
    #
    @classmethod
    def diagonal(cls,vals):
        &#34;&#34;&#34;
        Retorna una matriu diagonal amb valors &#34;vals&#34; a la diagonal
        Paràmetres:
            vals: llista d&#39;escalars o vector (class Vector o Punt)
        &#34;&#34;&#34;
        if isinstance(vals,Vector):
            vals = vals.components
        if not isinstance(vals,list) and not isinstance(vals,tuple):
            return None
        d = len(vals)
        if d == 0:
            return None
        m = diag(*vals)
        return cls(m)
    #
    #
    #
    @classmethod
    def amb_rang(cls,f=3,c=3,r=3,maxim=5,mzeros=-1):
        &#34;&#34;&#34;
        Retorna una matriu aleatoria amb rang r.
        Paràmetres:
          f: nombre de files de la matriu
          c: nombre de columnes de la matriu
          r: rang de la matriu
          maxim: tots els elements tindran valor absolut menor que &#34;maxim&#34;
          mzeros: nombre màxim de zeros. Si és -1, no hi ha màxim
        &#34;&#34;&#34;
        values = [-1,1,2]
        trobat = False
        while not trobat:
            mc = cls.invertible(f,maxim=2,mzeros=2,unitaria=True)
            md = cls.invertible(c,maxim=2,mzeros=2,unitaria=True)
            m = Matrix.zeros(f,c)
            for k in range(r):
                m[k,k] = values[random.randint(0,2)]
            n = mc.matriu * m * md.matriu
            if mzeros &gt;= 0 and nzeros(n) &gt; mzeros:
                continue
            trobat = norma_maxim(n) &lt;= maxim
        if nnegatius(n) &gt; f*c/2:
            n *= -1
        return cls(n)
    #
    #
    #
    def inversa(self):
        &#34;&#34;&#34;
        Retorna una nova matriu que és la inversa de l&#39;actual
        &#34;&#34;&#34;
        return Matriu(self.matriu**(-1))
    #
    #
    #
    def adjunta(self):
        &#34;&#34;&#34;
        Retorna una nova matriu que és l&#39;adjunta de l&#39;actual
        &#34;&#34;&#34;
        return Matriu(self.matriu.adjugate().T)
    #
    #
    #
    @classmethod
    def invertible(cls,ordre=3,maxim=5,mzeros=-1,unitaria=False):
        &#34;&#34;&#34;
        Retorna una matriu quadrada aleatoria invertible.
        Paràmetres:
            ordre: nombre de files i columnes de la matriu
            maxim: tots els elements tindran valor absolut menor que &#34;maxim&#34;
            mzeros: si nzeros &gt;= 0, nombre màxim de zeros que tindrà la matrius
                    si nzeros &lt; 0, el nombre de zeros no està limitat
            unitaria: si volem que el determinant sigui 1 o -1
        &#34;&#34;&#34;
        opcions = []
        for i in range(1,13):
            opcions += [i for j in range(0,2**(13-i))] + [-i for j in range(0,2**(13-i))]
        unitats = (-1,1)
        els = len(opcions)
        random.shuffle(opcions)
        trobat = False
        while not trobat:
            if unitaria:
                values = [unitats[random.randint(0,1)] for i in range(ordre)]
            else:
                values = [opcions[random.randint(0,els-1)] for i in range(ordre)]
            ti = Matrix(ordre,ordre,lambda i, j : mti(i,j))
            ts = Matrix(ordre,ordre,lambda i, j : mts(i,j,values))
            m = ti * ts
            if norma_maxim(m) &gt; maxim:
                continue
            if mzeros &gt;= 0 and nzeros(m) &gt; mzeros:
                continue
            trobat = True
        if nnegatius(m) &gt; ordre**2/2:
            m *= -1
        return cls(m)
    #
    #
    #
    @classmethod
    def diagonalitzable(cls,ordre=3,maxim=5,mzeros=-1,mvaps=3,vapsnuls=False,vapsrepetits=True):
        &#34;&#34;&#34;
        Retorna una matriu quadrada aleatoria diagonalitzable.
        Paràmetres:
            ordre: nombre de files i columnes de la matriu
            maxim: tots els elements tindran valor absolut menor o igual que &#34;maxim&#34;
            mzeros: si nzeros &gt;= 0, nombre màxim de zeros que tindrà la matrius
                    si nzeros &lt; 0, el nombre de zeros no està limitat
            mvaps: tots els valors propis tindran valor absolut menor o igual que &#34;mvaps&#34;
            vapsnuls: si hi pot aparèixer el valor propi nul
            vapsrepetits: si hi pot aparèixer valors propis repetits
        &#34;&#34;&#34;
        trobat = False
        while not trobat:
            c = Matriu.invertible(ordre=ordre,maxim=3,mzeros=0,unitaria=True)
            v = [-i for i in range(1,mvaps+1)] + [i for i in range(1,mvaps+1)]
            if vapsnuls:
                vaps = [random.randint(-mvaps,mvaps) for i in range(ordre)]
            else:
                vaps = [v[random.randint(0,2*mvaps-1)] for i in range(ordre)]
            if not vapsnuls and 0 in vaps:
                continue
            if len(set(vaps)) == 1:
                continue
            if not vapsrepetits and len(set(vaps)) != ordre:
                continue
            if vapsrepetits and len(set(vaps)) == ordre:
                continue
            vaps.sort()
            d = diag(*vaps)
            a = c.matriu * d * c.matriu**(-1)
            if norma_maxim(a) &gt; maxim:
                continue
            if mzeros &gt;= 0 and nzeros(a) &gt; mzeros:
                continue
            trobat = True
        m = cls(a)
        m.set_vaps(vaps)
        m.set_veps(c.vectors_columna())
        m.diagonalitzable = True
        return m
    #
    #
    #
    def diagonalitza(self,ortogonals=False):
        &#34;&#34;&#34;
           Calcula els valors propis i els vectors propis de la matriu i els
           guarda a les variables self.vaps i self.veps. Actualitza el camp
           self.diagonalitzable
        &#34;&#34;&#34;
        if self.files != self.columnes:
            return
        e = self.matriu.eigenvects()
        self.vaps, self.veps = vaps_veps(e,ortogonals=ortogonals)
        self.diagonalitzable = False
        if len(self.vaps) == self.files:
            self.diagonalitzable = True
    #
    #
    #
    @classmethod
    def gram(cls,ordre=3,maxim=5,mzeros=-1):
        &#34;&#34;&#34;
        Retorna una matriu quadrada aleatoria que serà d&#39;un producte escalar,
        és a dir, una matriu de Gram
        Paràmetres:
            ordre: nombre de files i columnes de la matriu
            maxim: tots els elements tindran valor absolut menor o igual que &#34;maxim&#34;
            mzeros: si nzeros &gt;= 0, nombre màxim de zeros que tindrà la matrius
                    si nzeros &lt; 0, el nombre de zeros no està limitat
        &#34;&#34;&#34;
        trobat = False
        while not trobat:
            c = Matriu.invertible(ordre,maxim=5)
            g = c.transposada() * c
            if mzeros &gt;= 0 and g.nzeros() &gt; mzeros:
                continue
            if g.norma_maxim() &gt; maxim:
                continue
            trobat = True
        return cls(g.matriu)
    #
    #
    #
    @classmethod
    def matriu_fila(cls,v):
        &#34;&#34;&#34;
        Retorna una nova matriu fila a partir de les components del vector v
        Paràmetres:
            v: vector o punt
        &#34;&#34;&#34;
        if not isinstance(v,Vector):
            return None
        m = Matrix(1,v.dimensio,v.components)
        return cls(m)
    #
    #
    #
    @classmethod
    def matriu_columna(cls,v):
        &#34;&#34;&#34;
        Retorna una nova matriu columna a partir de les components del vector v
        Paràmetres:
            v: vector o punt
        &#34;&#34;&#34;
        if not isinstance(v,Vector):
            return None
        m = Matrix(v.dimensio,1,v.components)
        return cls(m)
    #
    #
    #
    @classmethod
    def from_vectors_fila(cls,vecs):
        &#34;&#34;&#34;
        Retorna una nova matriu a partir d&#39;una llista de vectors.
        Les components dels vectors seran les files de la nova matriu
        Paràmetres:
            v: llista de vectors o punts
        &#34;&#34;&#34;
        if len(vecs) == 0:
            return None
        if not isinstance(vecs[0],Vector):
            return None
        c = vecs[0].dimensio
        f = len(vecs)
        l = []
        for v in vecs:
            if not isinstance(v,Vector):
                return None
            if v.dimensio != c:
                return None
            l += v.components
        m = Matrix(f,c,l)
        return cls(m)
    #
    #
    #
    @classmethod
    def from_vectors_columna(cls,vecs):
        &#34;&#34;&#34;
        Retorna una nova matriu a partir d&#39;una llista de vectors.
        Les components dels vectors seran les columnes de la nova matriu
        Paràmetres:
            v: llista de vectors o punts
        &#34;&#34;&#34;
        if not (isinstance(vecs,list) or isinstance(vecs,tuple)):
            return None
        if len(vecs) == 0:
            return None
        if not isinstance(vecs[0],Vector):
            return None
        c = vecs[0].dimensio
        f = len(vecs)
        l = []
        for v in vecs:
            if not isinstance(v,Vector):
                return None
            if v.dimensio != c:
                return None
            l += v.components
        m = Matrix(f,c,l)
        return cls(m.T)
    #
    #
    #
    @classmethod
    def identitat(cls,ordre):
        &#34;&#34;&#34;
        Retorna la matriu identitat
        Paràmetres:
            ordre: ordre de la matriu identitat
        &#34;&#34;&#34;
        return cls(eye(ordre))
    #
    #
    #
    def vectors_columna(self,simplificar=False):
        &#34;&#34;&#34;
        Retorna una llista amb els vectors columna de la matriu
        Paràmetres:
            simplificar: si és True retornarà els vectors simplificats
        &#34;&#34;&#34;
        vecs = []
        m = self.matriu
        for i in range(self.columnes):
            v = [m[j,i] for j in range(self.files)]
            u = Vector(v)
            if simplificar:
                u.simplificar()
            vecs.append(u)
        return vecs
    #
    #
    #
    def vectors_fila(self,simplificar=False):
        &#34;&#34;&#34;
        Retorna una llista amb els vectors fila de la matriu
        Paràmetres:
            simplificar: si és True retornarà els vectors simplificats
        &#34;&#34;&#34;
        vecs = []
        m = self.matriu
        for i in range(self.files):
            v = [m[i,j] for j in range(self.columnes)]
            u = Vector(v)
            if simplificar:
                u.simplificar()
            vecs.append(u)
        return vecs
    #
    #
    #
    def nucli(self):
        &#34;&#34;&#34;
        Retorna una llista de vectors que formen una base del nucli de la matriu
        &#34;&#34;&#34;
        n = self.matriu.nullspace()
        vecs = []
        for i in range(len(n)):
            m = Matriu(n[i])
            vecs += m.vectors_columna()
        for v in vecs:
            v.simplificar()
        return vecs
    #
    #
    #
    def es_simetrica(self):
        &#34;&#34;&#34;
        Retorna True si és simètrica
        &#34;&#34;&#34;
        return self == self.transposada()
    #
    #
    #
    def es_diagonal(self):
        &#34;&#34;&#34;
        Retorna True si és una matriu diagonal
        &#34;&#34;&#34;
        for i in range(self.files):
            for j in range(self.columnes):
                if i != j and self.matriu[i,j] != 0:
                    return False
        return True
    #
    #
    #
    def intercanvia_columnes(self,i,j):
        &#34;&#34;&#34;
        Retorna una matriu amb les columnes i i j permutades
        Paràmetres:
            i, j: índexs de les columnes
        &#34;&#34;&#34;
        if i &gt;= self.columnes or j &gt;= self.columnes:
            return None
        if i == j:
            return Matriu(self.matriu)
        c = self.vectors_columna()
        k = c[i]
        c[i] = c[j]
        c[j] = k
        return Matriu.from_vectors_columna(c)
    #
    #
    #
    def reordena_aleatoriament_columnes(self):
        &#34;&#34;&#34;
        Retorna una nova matriu amb les columnes reordenades aleatòriament
        &#34;&#34;&#34;
        c = self.vectors_columna()
        p = list(range(self.columnes))
        random.shuffle(p)
        d = [c[i] for i in p]
        return Matriu.from_vectors_columna(d)
    #
    #
    #
    def reordena_aleatoriament_files(self):
        &#34;&#34;&#34;
        Retorna una nova matriu amb les files reordenades aleatòriament
        &#34;&#34;&#34;
        c = self.vectors_fila()
        p = list(range(self.files))
        random.shuffle(p)
        d = [c[i] for i in p]
        return Matriu.from_vectors_fila(d)
    #
    #
    #
    def inserta_fila(self,pos,fila):
        &#34;&#34;&#34;
        Retorna una nova matriu amb la fila &#34;fila&#34; insertada a la posició &#34;pos&#34;
        Paràmetrers:
            fila: nova fila de la matriu
            pos: posició que ha d&#39;ocupar la nova fila
        &#34;&#34;&#34;
        if not isinstance(fila,Vector):
            return None
        if fila.dimensio != self.columnes:
            return None
        if pos &gt; self.files:
            pos = self.files
        files = self.vectors_fila()
        files.insert(pos,fila)
        return Matriu.from_vectors_fila(files)
    #
    #
    #
    def inserta_columna(self,pos,columna):
        &#34;&#34;&#34;
        Retorna una nova matriu amb la columna &#34;columna&#34; insertada a la posició &#34;pos&#34;
        Paràmetrers:
            columna: nova columna de la matriu
            pos: posició que ha d&#39;ocupar la nova columna
        &#34;&#34;&#34;
        if not isinstance(columna,Vector):
            return None
        if columna.dimensio != self.files:
            return None
        if pos &gt; self.columnes:
            pos = self.columnes
        columnes = self.vectors_columna()
        columnes.insert(pos,columna)
        return Matriu.from_vectors_columna(columnes)
    #
    #
    #
    def factor_comu(self):
        &#34;&#34;&#34;
        Retorna quin factor comú podem treure de la matriu
        &#34;&#34;&#34;
        d = []
        for i in range(self.files):
            for j in range(self.columnes):
                k = self[i,j]
            if (isinstance(k,int) or isinstance(k,Integer)):
                d.append(k)
            else:
                return 1
        return (mcd_llista(d))
    #
    #
    #
    def simplificar(self):
        &#34;&#34;&#34;
        Simplifica la matriu, és a dir, converteix les seves entrades en una
        llista d&#39;enters amb mcd igual a 1.
        Només té sentit si totes les components del vector són nombres enters
        o racionals
        &#34;&#34;&#34;
        d = []
        for i in range(self.columnes):
            for j in range(self.files):
                if isinstance(self.matriu[i,j],Rational):
                    d.append(self.matriu[i,j].q)
                elif isinstance(self.matriu[i,j],int):
                    pass
                elif isinstance(self.matriu[i,j],Integer):
                    pass
                else:
                    return
        mcm = mcm_llista(d)
        m = mcm * self.matriu
        d = []
        for i in range(self.columnes):
            for j in range(self.files):
                d.append(m[i,j])
        mcd = mcd_llista(d)
        for i in range(self.columnes):
            for j in range(self.files):
                self.matriu[i,j] = m[i,j] // mcd
        if self.matriu[0,0] &lt; 0:
            self.matriu = - self.matriu
    #
    #
    #
    def submatriu(self,files,columnes):
        &#34;&#34;&#34;
        Retorna la submatriu determinada per les files &#34;files&#34; i les
        columnes &#34;columnes&#34;.
        Paràmetrers:
            files: llista de files
            columnes: llista de columnes
        &#34;&#34;&#34;
        if not (isinstance(files,list) or isinstance(files,tuple)):
            return None
        if not (isinstance(columnes,list) or isinstance(columnes,tuple)):
            return None
        if max(columnes) &gt;= self.columnes or min(columnes) &lt; 0:
            return None
        if max(files) &gt;= self.files or min(files) &lt; 0:
            return None
        m = self.matriu[files,columnes]
        return Matriu(m)
    #
    #
    #
    def subs(self,l):
        &#34;&#34;&#34;
        Aplica una llista de substitucions
        Paràmetres:
            l: llista de substitucions
        &#34;&#34;&#34;
        for i in range(self.columnes):
            for j in range(self.files):
                for d in l:
                    self[i,j] = self[i,j].subs(d)
    #
    #
    #
    def sistema_propi(self):
        &#34;&#34;&#34;
        Retorna el sistema d&#39;equacions en format latex corresponent al
        càlcul dels valors propis de la matriu
        &#34;&#34;&#34;
        if self.columnes &lt;= 4:
            x, y, z, t = symbols(&#39;x y z t&#39;)
            unknowns = [x,y,z,t]
        else:
            x1, x2, x3, x4, x5, x6, x7, x8 = symbols(&#39;x1 x2 x3 x4 x5 x6 x7 x8&#39;)
            unknowns = [x1,x2,x3,x4,x5,x6,x7,x8]
        unknowns = unknowns[0:self.columnes]
        A = self * Vector(unknowns)
        eqs = [f&#34;{latex(A[i])} &amp;= \\lambda {unknowns[i]}&#34; for i in range(A.dimensio)]
        eqs = &#34; \\\\ &#34;.join(eqs)
        return f&#34;\\left.\\aligned {eqs} \\endaligned\\;\\right\\}}&#34;</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="Algebra.Matriu.aleatoria"><code class="name flex">
<span>def <span class="ident">aleatoria</span></span>(<span>f=3, c=3, maxim=5, nuls=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Genera una matriu aleatoria.</p>
<h2 id="parametres">Paràmetres</h2>
<p>f: nombre de files de la matriu
c: nombre de columnes de la matriu
maxim: tots els elements tindran valor absolut menor que "maxim"
nuls: la matriu pot contenir coeficients nuls o no</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def aleatoria(cls,f=3,c=3,maxim=5,nuls=True):
    &#34;&#34;&#34;
    Genera una matriu aleatoria.
    Paràmetres:
        f: nombre de files de la matriu
        c: nombre de columnes de la matriu
        maxim: tots els elements tindran valor absolut menor que &#34;maxim&#34;
        nuls: la matriu pot contenir coeficients nuls o no
    &#34;&#34;&#34;
    m = Matrix(f,c,lambda i, j : random.randint(-maxim,maxim))
    if not nuls:
        values = [i for i in range(1,maxim + 1)] + [-i for i in range(1,maxim + 1)]
        for i in range(f):
            for j in range(c):
                if m[i,j] == 0:
                    m[i,j] = values[random.randint(0,2 * maxim - 1)]
    if nnegatius(m) &gt; (f*c)/2:
        m *= -1
    return cls(m)</code></pre>
</details>
</dd>
<dt id="Algebra.Matriu.amb_rang"><code class="name flex">
<span>def <span class="ident">amb_rang</span></span>(<span>f=3, c=3, r=3, maxim=5, mzeros=-1)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna una matriu aleatoria amb rang r.</p>
<h2 id="parametres">Paràmetres</h2>
<p>f: nombre de files de la matriu
c: nombre de columnes de la matriu
r: rang de la matriu
maxim: tots els elements tindran valor absolut menor que "maxim"
mzeros: nombre màxim de zeros. Si és -1, no hi ha màxim</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def amb_rang(cls,f=3,c=3,r=3,maxim=5,mzeros=-1):
    &#34;&#34;&#34;
    Retorna una matriu aleatoria amb rang r.
    Paràmetres:
      f: nombre de files de la matriu
      c: nombre de columnes de la matriu
      r: rang de la matriu
      maxim: tots els elements tindran valor absolut menor que &#34;maxim&#34;
      mzeros: nombre màxim de zeros. Si és -1, no hi ha màxim
    &#34;&#34;&#34;
    values = [-1,1,2]
    trobat = False
    while not trobat:
        mc = cls.invertible(f,maxim=2,mzeros=2,unitaria=True)
        md = cls.invertible(c,maxim=2,mzeros=2,unitaria=True)
        m = Matrix.zeros(f,c)
        for k in range(r):
            m[k,k] = values[random.randint(0,2)]
        n = mc.matriu * m * md.matriu
        if mzeros &gt;= 0 and nzeros(n) &gt; mzeros:
            continue
        trobat = norma_maxim(n) &lt;= maxim
    if nnegatius(n) &gt; f*c/2:
        n *= -1
    return cls(n)</code></pre>
</details>
</dd>
<dt id="Algebra.Matriu.diagonal"><code class="name flex">
<span>def <span class="ident">diagonal</span></span>(<span>vals)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna una matriu diagonal amb valors "vals" a la diagonal</p>
<h2 id="parametres">Paràmetres</h2>
<p>vals: llista d'escalars o vector (class Vector o Punt)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def diagonal(cls,vals):
    &#34;&#34;&#34;
    Retorna una matriu diagonal amb valors &#34;vals&#34; a la diagonal
    Paràmetres:
        vals: llista d&#39;escalars o vector (class Vector o Punt)
    &#34;&#34;&#34;
    if isinstance(vals,Vector):
        vals = vals.components
    if not isinstance(vals,list) and not isinstance(vals,tuple):
        return None
    d = len(vals)
    if d == 0:
        return None
    m = diag(*vals)
    return cls(m)</code></pre>
</details>
</dd>
<dt id="Algebra.Matriu.diagonalitzable"><code class="name flex">
<span>def <span class="ident">diagonalitzable</span></span>(<span>ordre=3, maxim=5, mzeros=-1, mvaps=3, vapsnuls=False, vapsrepetits=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna una matriu quadrada aleatoria diagonalitzable.</p>
<h2 id="parametres">Paràmetres</h2>
<p>ordre: nombre de files i columnes de la matriu
maxim: tots els elements tindran valor absolut menor o igual que "maxim"
mzeros: si nzeros &gt;= 0, nombre màxim de zeros que tindrà la matrius
si nzeros &lt; 0, el nombre de zeros no està limitat
mvaps: tots els valors propis tindran valor absolut menor o igual que "mvaps"
vapsnuls: si hi pot aparèixer el valor propi nul
vapsrepetits: si hi pot aparèixer valors propis repetits</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def diagonalitzable(cls,ordre=3,maxim=5,mzeros=-1,mvaps=3,vapsnuls=False,vapsrepetits=True):
    &#34;&#34;&#34;
    Retorna una matriu quadrada aleatoria diagonalitzable.
    Paràmetres:
        ordre: nombre de files i columnes de la matriu
        maxim: tots els elements tindran valor absolut menor o igual que &#34;maxim&#34;
        mzeros: si nzeros &gt;= 0, nombre màxim de zeros que tindrà la matrius
                si nzeros &lt; 0, el nombre de zeros no està limitat
        mvaps: tots els valors propis tindran valor absolut menor o igual que &#34;mvaps&#34;
        vapsnuls: si hi pot aparèixer el valor propi nul
        vapsrepetits: si hi pot aparèixer valors propis repetits
    &#34;&#34;&#34;
    trobat = False
    while not trobat:
        c = Matriu.invertible(ordre=ordre,maxim=3,mzeros=0,unitaria=True)
        v = [-i for i in range(1,mvaps+1)] + [i for i in range(1,mvaps+1)]
        if vapsnuls:
            vaps = [random.randint(-mvaps,mvaps) for i in range(ordre)]
        else:
            vaps = [v[random.randint(0,2*mvaps-1)] for i in range(ordre)]
        if not vapsnuls and 0 in vaps:
            continue
        if len(set(vaps)) == 1:
            continue
        if not vapsrepetits and len(set(vaps)) != ordre:
            continue
        if vapsrepetits and len(set(vaps)) == ordre:
            continue
        vaps.sort()
        d = diag(*vaps)
        a = c.matriu * d * c.matriu**(-1)
        if norma_maxim(a) &gt; maxim:
            continue
        if mzeros &gt;= 0 and nzeros(a) &gt; mzeros:
            continue
        trobat = True
    m = cls(a)
    m.set_vaps(vaps)
    m.set_veps(c.vectors_columna())
    m.diagonalitzable = True
    return m</code></pre>
</details>
</dd>
<dt id="Algebra.Matriu.from_vectors_columna"><code class="name flex">
<span>def <span class="ident">from_vectors_columna</span></span>(<span>vecs)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna una nova matriu a partir d'una llista de vectors.
Les components dels vectors seran les columnes de la nova matriu</p>
<h2 id="parametres">Paràmetres</h2>
<p>v: llista de vectors o punts</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_vectors_columna(cls,vecs):
    &#34;&#34;&#34;
    Retorna una nova matriu a partir d&#39;una llista de vectors.
    Les components dels vectors seran les columnes de la nova matriu
    Paràmetres:
        v: llista de vectors o punts
    &#34;&#34;&#34;
    if not (isinstance(vecs,list) or isinstance(vecs,tuple)):
        return None
    if len(vecs) == 0:
        return None
    if not isinstance(vecs[0],Vector):
        return None
    c = vecs[0].dimensio
    f = len(vecs)
    l = []
    for v in vecs:
        if not isinstance(v,Vector):
            return None
        if v.dimensio != c:
            return None
        l += v.components
    m = Matrix(f,c,l)
    return cls(m.T)</code></pre>
</details>
</dd>
<dt id="Algebra.Matriu.from_vectors_fila"><code class="name flex">
<span>def <span class="ident">from_vectors_fila</span></span>(<span>vecs)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna una nova matriu a partir d'una llista de vectors.
Les components dels vectors seran les files de la nova matriu</p>
<h2 id="parametres">Paràmetres</h2>
<p>v: llista de vectors o punts</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_vectors_fila(cls,vecs):
    &#34;&#34;&#34;
    Retorna una nova matriu a partir d&#39;una llista de vectors.
    Les components dels vectors seran les files de la nova matriu
    Paràmetres:
        v: llista de vectors o punts
    &#34;&#34;&#34;
    if len(vecs) == 0:
        return None
    if not isinstance(vecs[0],Vector):
        return None
    c = vecs[0].dimensio
    f = len(vecs)
    l = []
    for v in vecs:
        if not isinstance(v,Vector):
            return None
        if v.dimensio != c:
            return None
        l += v.components
    m = Matrix(f,c,l)
    return cls(m)</code></pre>
</details>
</dd>
<dt id="Algebra.Matriu.gram"><code class="name flex">
<span>def <span class="ident">gram</span></span>(<span>ordre=3, maxim=5, mzeros=-1)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna una matriu quadrada aleatoria que serà d'un producte escalar,
és a dir, una matriu de Gram</p>
<h2 id="parametres">Paràmetres</h2>
<p>ordre: nombre de files i columnes de la matriu
maxim: tots els elements tindran valor absolut menor o igual que "maxim"
mzeros: si nzeros &gt;= 0, nombre màxim de zeros que tindrà la matrius
si nzeros &lt; 0, el nombre de zeros no està limitat</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def gram(cls,ordre=3,maxim=5,mzeros=-1):
    &#34;&#34;&#34;
    Retorna una matriu quadrada aleatoria que serà d&#39;un producte escalar,
    és a dir, una matriu de Gram
    Paràmetres:
        ordre: nombre de files i columnes de la matriu
        maxim: tots els elements tindran valor absolut menor o igual que &#34;maxim&#34;
        mzeros: si nzeros &gt;= 0, nombre màxim de zeros que tindrà la matrius
                si nzeros &lt; 0, el nombre de zeros no està limitat
    &#34;&#34;&#34;
    trobat = False
    while not trobat:
        c = Matriu.invertible(ordre,maxim=5)
        g = c.transposada() * c
        if mzeros &gt;= 0 and g.nzeros() &gt; mzeros:
            continue
        if g.norma_maxim() &gt; maxim:
            continue
        trobat = True
    return cls(g.matriu)</code></pre>
</details>
</dd>
<dt id="Algebra.Matriu.identitat"><code class="name flex">
<span>def <span class="ident">identitat</span></span>(<span>ordre)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la matriu identitat</p>
<h2 id="parametres">Paràmetres</h2>
<p>ordre: ordre de la matriu identitat</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def identitat(cls,ordre):
    &#34;&#34;&#34;
    Retorna la matriu identitat
    Paràmetres:
        ordre: ordre de la matriu identitat
    &#34;&#34;&#34;
    return cls(eye(ordre))</code></pre>
</details>
</dd>
<dt id="Algebra.Matriu.invertible"><code class="name flex">
<span>def <span class="ident">invertible</span></span>(<span>ordre=3, maxim=5, mzeros=-1, unitaria=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna una matriu quadrada aleatoria invertible.</p>
<h2 id="parametres">Paràmetres</h2>
<p>ordre: nombre de files i columnes de la matriu
maxim: tots els elements tindran valor absolut menor que "maxim"
mzeros: si nzeros &gt;= 0, nombre màxim de zeros que tindrà la matrius
si nzeros &lt; 0, el nombre de zeros no està limitat
unitaria: si volem que el determinant sigui 1 o -1</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def invertible(cls,ordre=3,maxim=5,mzeros=-1,unitaria=False):
    &#34;&#34;&#34;
    Retorna una matriu quadrada aleatoria invertible.
    Paràmetres:
        ordre: nombre de files i columnes de la matriu
        maxim: tots els elements tindran valor absolut menor que &#34;maxim&#34;
        mzeros: si nzeros &gt;= 0, nombre màxim de zeros que tindrà la matrius
                si nzeros &lt; 0, el nombre de zeros no està limitat
        unitaria: si volem que el determinant sigui 1 o -1
    &#34;&#34;&#34;
    opcions = []
    for i in range(1,13):
        opcions += [i for j in range(0,2**(13-i))] + [-i for j in range(0,2**(13-i))]
    unitats = (-1,1)
    els = len(opcions)
    random.shuffle(opcions)
    trobat = False
    while not trobat:
        if unitaria:
            values = [unitats[random.randint(0,1)] for i in range(ordre)]
        else:
            values = [opcions[random.randint(0,els-1)] for i in range(ordre)]
        ti = Matrix(ordre,ordre,lambda i, j : mti(i,j))
        ts = Matrix(ordre,ordre,lambda i, j : mts(i,j,values))
        m = ti * ts
        if norma_maxim(m) &gt; maxim:
            continue
        if mzeros &gt;= 0 and nzeros(m) &gt; mzeros:
            continue
        trobat = True
    if nnegatius(m) &gt; ordre**2/2:
        m *= -1
    return cls(m)</code></pre>
</details>
</dd>
<dt id="Algebra.Matriu.matriu_columna"><code class="name flex">
<span>def <span class="ident">matriu_columna</span></span>(<span>v)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna una nova matriu columna a partir de les components del vector v</p>
<h2 id="parametres">Paràmetres</h2>
<p>v: vector o punt</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def matriu_columna(cls,v):
    &#34;&#34;&#34;
    Retorna una nova matriu columna a partir de les components del vector v
    Paràmetres:
        v: vector o punt
    &#34;&#34;&#34;
    if not isinstance(v,Vector):
        return None
    m = Matrix(v.dimensio,1,v.components)
    return cls(m)</code></pre>
</details>
</dd>
<dt id="Algebra.Matriu.matriu_fila"><code class="name flex">
<span>def <span class="ident">matriu_fila</span></span>(<span>v)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna una nova matriu fila a partir de les components del vector v</p>
<h2 id="parametres">Paràmetres</h2>
<p>v: vector o punt</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def matriu_fila(cls,v):
    &#34;&#34;&#34;
    Retorna una nova matriu fila a partir de les components del vector v
    Paràmetres:
        v: vector o punt
    &#34;&#34;&#34;
    if not isinstance(v,Vector):
        return None
    m = Matrix(1,v.dimensio,v.components)
    return cls(m)</code></pre>
</details>
</dd>
<dt id="Algebra.Matriu.transformacio_elemental"><code class="name flex">
<span>def <span class="ident">transformacio_elemental</span></span>(<span>ordre, i, j, s, t)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la matriu corresponent a la transformació elemental
F_i \sim s F_i + t F_j</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def transformacio_elemental(cls,ordre,i,j,s,t):
    &#34;&#34;&#34;
    Retorna la matriu corresponent a la transformació elemental
    F_i \sim s F_i + t F_j
    &#34;&#34;&#34;
    a = eye(ordre)
    a[i,:] = s * a[i,:] + t * a[j,:]
    return cls(a)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Algebra.Matriu.adjunta"><code class="name flex">
<span>def <span class="ident">adjunta</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna una nova matriu que és l'adjunta de l'actual</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def adjunta(self):
    &#34;&#34;&#34;
    Retorna una nova matriu que és l&#39;adjunta de l&#39;actual
    &#34;&#34;&#34;
    return Matriu(self.matriu.adjugate().T)</code></pre>
</details>
</dd>
<dt id="Algebra.Matriu.anula_coeficient_amb_pivot"><code class="name flex">
<span>def <span class="ident">anula_coeficient_amb_pivot</span></span>(<span>self, fc, fp)</span>
</code></dt>
<dd>
<div class="desc"><p>Aplicar la transformació elemental
F_fc \sim s F_fc - t F_fp
on s i t s'obtenen de la forma següent:
1. s és el primer coeficient no nul de la fila fp, que ocuparà la columna col
2. t és el coeficient que ocupa la fila fc, columna col
3. Si s i t són enters, els dividim pel seu màxim comú divisor
Retornem la transformació elemental feta en forma de tupla (s,t)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def anula_coeficient_amb_pivot(self,fc,fp):
    &#34;&#34;&#34;
    Aplicar la transformació elemental
    F_fc \sim s F_fc - t F_fp
    on s i t s&#39;obtenen de la forma següent:
       1. s és el primer coeficient no nul de la fila fp, que ocuparà la columna col
       2. t és el coeficient que ocupa la fila fc, columna col
       3. Si s i t són enters, els dividim pel seu màxim comú divisor
    Retornem la transformació elemental feta en forma de tupla (s,t)
    &#34;&#34;&#34;
    k = primer_no_nul(self.matriu[fp,:])
    if k is None:
        return 1, None
    if self.matriu[fc,k] == 0:
        return 2, None
    if primer_no_nul(self.matriu[fc,:]) != k:
        return 3, None
    s = self.matriu[fp,k]
    t = self.matriu[fc,k]
    if isinstance(s,int) or isinstance(s,Integer):
         if isinstance(t,int) or isinstance(t,Integer):
             d = mcd_llista([t,s])
             if abs(d) != 1:
                 s /= d
                 t /= d
    if s &lt; 0:
        s, t = -s, -t
    self.matriu[fc,:] = s * self.matriu[fc,:] - t * self.matriu[fp,:]
    return 0, (s,t)</code></pre>
</details>
</dd>
<dt id="Algebra.Matriu.clona"><code class="name flex">
<span>def <span class="ident">clona</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorma una còpia de la matriu</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clona(self):
    &#34;&#34;&#34;
    Retorma una còpia de la matriu
    &#34;&#34;&#34;
    return Matriu(self.matriu[:,:])</code></pre>
</details>
</dd>
<dt id="Algebra.Matriu.det"><code class="name flex">
<span>def <span class="ident">det</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el determiant de la matriu</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def det(self):
    &#34;&#34;&#34;
    Retorna el determiant de la matriu
    &#34;&#34;&#34;
    return self.matriu.det()</code></pre>
</details>
</dd>
<dt id="Algebra.Matriu.determinant"><code class="name flex">
<span>def <span class="ident">determinant</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el determiant de la matriu</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def determinant(self):
    &#34;&#34;&#34;
    Retorna el determiant de la matriu
    &#34;&#34;&#34;
    return self.matriu.det()</code></pre>
</details>
</dd>
<dt id="Algebra.Matriu.diagonalitza"><code class="name flex">
<span>def <span class="ident">diagonalitza</span></span>(<span>self, ortogonals=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Calcula els valors propis i els vectors propis de la matriu i els
guarda a les variables self.vaps i self.veps. Actualitza el camp
self.diagonalitzable</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def diagonalitza(self,ortogonals=False):
    &#34;&#34;&#34;
       Calcula els valors propis i els vectors propis de la matriu i els
       guarda a les variables self.vaps i self.veps. Actualitza el camp
       self.diagonalitzable
    &#34;&#34;&#34;
    if self.files != self.columnes:
        return
    e = self.matriu.eigenvects()
    self.vaps, self.veps = vaps_veps(e,ortogonals=ortogonals)
    self.diagonalitzable = False
    if len(self.vaps) == self.files:
        self.diagonalitzable = True</code></pre>
</details>
</dd>
<dt id="Algebra.Matriu.es_diagonal"><code class="name flex">
<span>def <span class="ident">es_diagonal</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna True si és una matriu diagonal</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def es_diagonal(self):
    &#34;&#34;&#34;
    Retorna True si és una matriu diagonal
    &#34;&#34;&#34;
    for i in range(self.files):
        for j in range(self.columnes):
            if i != j and self.matriu[i,j] != 0:
                return False
    return True</code></pre>
</details>
</dd>
<dt id="Algebra.Matriu.es_simetrica"><code class="name flex">
<span>def <span class="ident">es_simetrica</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna True si és simètrica</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def es_simetrica(self):
    &#34;&#34;&#34;
    Retorna True si és simètrica
    &#34;&#34;&#34;
    return self == self.transposada()</code></pre>
</details>
</dd>
<dt id="Algebra.Matriu.factor_comu"><code class="name flex">
<span>def <span class="ident">factor_comu</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna quin factor comú podem treure de la matriu</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def factor_comu(self):
    &#34;&#34;&#34;
    Retorna quin factor comú podem treure de la matriu
    &#34;&#34;&#34;
    d = []
    for i in range(self.files):
        for j in range(self.columnes):
            k = self[i,j]
        if (isinstance(k,int) or isinstance(k,Integer)):
            d.append(k)
        else:
            return 1
    return (mcd_llista(d))</code></pre>
</details>
</dd>
<dt id="Algebra.Matriu.inserta_columna"><code class="name flex">
<span>def <span class="ident">inserta_columna</span></span>(<span>self, pos, columna)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna una nova matriu amb la columna "columna" insertada a la posició "pos"</p>
<h2 id="parametrers">Paràmetrers</h2>
<p>columna: nova columna de la matriu
pos: posició que ha d'ocupar la nova columna</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inserta_columna(self,pos,columna):
    &#34;&#34;&#34;
    Retorna una nova matriu amb la columna &#34;columna&#34; insertada a la posició &#34;pos&#34;
    Paràmetrers:
        columna: nova columna de la matriu
        pos: posició que ha d&#39;ocupar la nova columna
    &#34;&#34;&#34;
    if not isinstance(columna,Vector):
        return None
    if columna.dimensio != self.files:
        return None
    if pos &gt; self.columnes:
        pos = self.columnes
    columnes = self.vectors_columna()
    columnes.insert(pos,columna)
    return Matriu.from_vectors_columna(columnes)</code></pre>
</details>
</dd>
<dt id="Algebra.Matriu.inserta_fila"><code class="name flex">
<span>def <span class="ident">inserta_fila</span></span>(<span>self, pos, fila)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna una nova matriu amb la fila "fila" insertada a la posició "pos"</p>
<h2 id="parametrers">Paràmetrers</h2>
<p>fila: nova fila de la matriu
pos: posició que ha d'ocupar la nova fila</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inserta_fila(self,pos,fila):
    &#34;&#34;&#34;
    Retorna una nova matriu amb la fila &#34;fila&#34; insertada a la posició &#34;pos&#34;
    Paràmetrers:
        fila: nova fila de la matriu
        pos: posició que ha d&#39;ocupar la nova fila
    &#34;&#34;&#34;
    if not isinstance(fila,Vector):
        return None
    if fila.dimensio != self.columnes:
        return None
    if pos &gt; self.files:
        pos = self.files
    files = self.vectors_fila()
    files.insert(pos,fila)
    return Matriu.from_vectors_fila(files)</code></pre>
</details>
</dd>
<dt id="Algebra.Matriu.intercanvia_columnes"><code class="name flex">
<span>def <span class="ident">intercanvia_columnes</span></span>(<span>self, i, j)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna una matriu amb les columnes i i j permutades</p>
<h2 id="parametres">Paràmetres</h2>
<p>i, j: índexs de les columnes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def intercanvia_columnes(self,i,j):
    &#34;&#34;&#34;
    Retorna una matriu amb les columnes i i j permutades
    Paràmetres:
        i, j: índexs de les columnes
    &#34;&#34;&#34;
    if i &gt;= self.columnes or j &gt;= self.columnes:
        return None
    if i == j:
        return Matriu(self.matriu)
    c = self.vectors_columna()
    k = c[i]
    c[i] = c[j]
    c[j] = k
    return Matriu.from_vectors_columna(c)</code></pre>
</details>
</dd>
<dt id="Algebra.Matriu.inversa"><code class="name flex">
<span>def <span class="ident">inversa</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna una nova matriu que és la inversa de l'actual</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inversa(self):
    &#34;&#34;&#34;
    Retorna una nova matriu que és la inversa de l&#39;actual
    &#34;&#34;&#34;
    return Matriu(self.matriu**(-1))</code></pre>
</details>
</dd>
<dt id="Algebra.Matriu.latex"><code class="name flex">
<span>def <span class="ident">latex</span></span>(<span>self, format=None, tipus='p')</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la representació en LaTeX de la matriu</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def latex(self,format=None,tipus=&#39;p&#39;):
    &#34;&#34;&#34;
    Retorna la representació en LaTeX de la matriu
    &#34;&#34;&#34;
    if format is None:
        format = self.format
    return matriu_latex(self.matriu,format,tipus)</code></pre>
</details>
</dd>
<dt id="Algebra.Matriu.max_diagonal"><code class="name flex">
<span>def <span class="ident">max_diagonal</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el màxim en valor absolut dels coeficients de la diagonal
Si la matriu no és quadrada retorna None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def max_diagonal(self):
    &#34;&#34;&#34;
    Retorna el màxim en valor absolut dels coeficients de la diagonal
    Si la matriu no és quadrada retorna None
    &#34;&#34;&#34;
    if self.files == 0 or self.columnes == 0:
        return 0
    max = 0
    m = min(self.files,self.columnes)
    for i in range(m):
        k = abs(self.matriu[i,i])
        if k &gt; max:
            max = k
    return max</code></pre>
</details>
</dd>
<dt id="Algebra.Matriu.nnegatius"><code class="name flex">
<span>def <span class="ident">nnegatius</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el nombre de coeficients negatius de la matriu</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nnegatius(self):
    &#34;&#34;&#34;
    Retorna el nombre de coeficients negatius de la matriu
    &#34;&#34;&#34;
    return nnegatius(self.matriu)</code></pre>
</details>
</dd>
<dt id="Algebra.Matriu.norma_maxim"><code class="name flex">
<span>def <span class="ident">norma_maxim</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la norma del màxim de la matriu</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def norma_maxim(self):
    &#34;&#34;&#34;
    Retorna la norma del màxim de la matriu
    &#34;&#34;&#34;
    return norma_maxim(self.matriu)</code></pre>
</details>
</dd>
<dt id="Algebra.Matriu.nucli"><code class="name flex">
<span>def <span class="ident">nucli</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna una llista de vectors que formen una base del nucli de la matriu</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nucli(self):
    &#34;&#34;&#34;
    Retorna una llista de vectors que formen una base del nucli de la matriu
    &#34;&#34;&#34;
    n = self.matriu.nullspace()
    vecs = []
    for i in range(len(n)):
        m = Matriu(n[i])
        vecs += m.vectors_columna()
    for v in vecs:
        v.simplificar()
    return vecs</code></pre>
</details>
</dd>
<dt id="Algebra.Matriu.nzeros"><code class="name flex">
<span>def <span class="ident">nzeros</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el nombre de zeros de la matriu</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nzeros(self):
    &#34;&#34;&#34;
    Retorna el nombre de zeros de la matriu
    &#34;&#34;&#34;
    return nzeros(self.matriu)</code></pre>
</details>
</dd>
<dt id="Algebra.Matriu.polinomi_caracteristic"><code class="name flex">
<span>def <span class="ident">polinomi_caracteristic</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el polinomi característic de la matriu</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def polinomi_caracteristic(self):
    &#34;&#34;&#34;
    Retorna el polinomi característic de la matriu
    &#34;&#34;&#34;
    lamda = symbols(&#39;lamda&#39;)
    p = (-1)**(self.files) * self.matriu.charpoly(lamda)
    return latex(p.as_expr())</code></pre>
</details>
</dd>
<dt id="Algebra.Matriu.rang"><code class="name flex">
<span>def <span class="ident">rang</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el rang de la matriu</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rang(self):
    &#34;&#34;&#34;
    Retorna el rang de la matriu
    &#34;&#34;&#34;
    return self.matriu.rank()</code></pre>
</details>
</dd>
<dt id="Algebra.Matriu.rank"><code class="name flex">
<span>def <span class="ident">rank</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el rang de la matriu</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rank(self):
    &#34;&#34;&#34;
    Retorna el rang de la matriu
    &#34;&#34;&#34;
    return self.matriu.rank()</code></pre>
</details>
</dd>
<dt id="Algebra.Matriu.reordena_aleatoriament_columnes"><code class="name flex">
<span>def <span class="ident">reordena_aleatoriament_columnes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna una nova matriu amb les columnes reordenades aleatòriament</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reordena_aleatoriament_columnes(self):
    &#34;&#34;&#34;
    Retorna una nova matriu amb les columnes reordenades aleatòriament
    &#34;&#34;&#34;
    c = self.vectors_columna()
    p = list(range(self.columnes))
    random.shuffle(p)
    d = [c[i] for i in p]
    return Matriu.from_vectors_columna(d)</code></pre>
</details>
</dd>
<dt id="Algebra.Matriu.reordena_aleatoriament_files"><code class="name flex">
<span>def <span class="ident">reordena_aleatoriament_files</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna una nova matriu amb les files reordenades aleatòriament</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reordena_aleatoriament_files(self):
    &#34;&#34;&#34;
    Retorna una nova matriu amb les files reordenades aleatòriament
    &#34;&#34;&#34;
    c = self.vectors_fila()
    p = list(range(self.files))
    random.shuffle(p)
    d = [c[i] for i in p]
    return Matriu.from_vectors_fila(d)</code></pre>
</details>
</dd>
<dt id="Algebra.Matriu.set_format"><code class="name flex">
<span>def <span class="ident">set_format</span></span>(<span>self, format)</span>
</code></dt>
<dd>
<div class="desc"><p>Estableix el format LaTeX amb que s'escriurà la matriu</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_format(self,format):
    &#34;&#34;&#34;
    Estableix el format LaTeX amb que s&#39;escriurà la matriu
    &#34;&#34;&#34;
    self.format = format</code></pre>
</details>
</dd>
<dt id="Algebra.Matriu.set_vaps"><code class="name flex">
<span>def <span class="ident">set_vaps</span></span>(<span>self, vaps)</span>
</code></dt>
<dd>
<div class="desc"><p>Assigna un llista de valors propis a la variable self.vaps</p>
<h2 id="parametres">Paràmetres</h2>
<p>vaps: llista de nombres</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_vaps(self,vaps):
    &#34;&#34;&#34;
    Assigna un llista de valors propis a la variable self.vaps
    Paràmetres:
        vaps: llista de nombres
    &#34;&#34;&#34;
    self.vaps = vaps</code></pre>
</details>
</dd>
<dt id="Algebra.Matriu.set_veps"><code class="name flex">
<span>def <span class="ident">set_veps</span></span>(<span>self, veps)</span>
</code></dt>
<dd>
<div class="desc"><p>Assigna un llista de vectors propis simplificats a la variable self.veps</p>
<h2 id="parametres">Paràmetres</h2>
<p>vaps: llista de vectors</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_veps(self,veps):
    &#34;&#34;&#34;
    Assigna un llista de vectors propis simplificats a la variable self.veps
    Paràmetres:
        vaps: llista de vectors
    &#34;&#34;&#34;
    for v in veps:
        v.simplificar()
    self.veps = veps</code></pre>
</details>
</dd>
<dt id="Algebra.Matriu.simplificar"><code class="name flex">
<span>def <span class="ident">simplificar</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Simplifica la matriu, és a dir, converteix les seves entrades en una
llista d'enters amb mcd igual a 1.
Només té sentit si totes les components del vector són nombres enters
o racionals</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simplificar(self):
    &#34;&#34;&#34;
    Simplifica la matriu, és a dir, converteix les seves entrades en una
    llista d&#39;enters amb mcd igual a 1.
    Només té sentit si totes les components del vector són nombres enters
    o racionals
    &#34;&#34;&#34;
    d = []
    for i in range(self.columnes):
        for j in range(self.files):
            if isinstance(self.matriu[i,j],Rational):
                d.append(self.matriu[i,j].q)
            elif isinstance(self.matriu[i,j],int):
                pass
            elif isinstance(self.matriu[i,j],Integer):
                pass
            else:
                return
    mcm = mcm_llista(d)
    m = mcm * self.matriu
    d = []
    for i in range(self.columnes):
        for j in range(self.files):
            d.append(m[i,j])
    mcd = mcd_llista(d)
    for i in range(self.columnes):
        for j in range(self.files):
            self.matriu[i,j] = m[i,j] // mcd
    if self.matriu[0,0] &lt; 0:
        self.matriu = - self.matriu</code></pre>
</details>
</dd>
<dt id="Algebra.Matriu.sistema_propi"><code class="name flex">
<span>def <span class="ident">sistema_propi</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el sistema d'equacions en format latex corresponent al
càlcul dels valors propis de la matriu</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sistema_propi(self):
    &#34;&#34;&#34;
    Retorna el sistema d&#39;equacions en format latex corresponent al
    càlcul dels valors propis de la matriu
    &#34;&#34;&#34;
    if self.columnes &lt;= 4:
        x, y, z, t = symbols(&#39;x y z t&#39;)
        unknowns = [x,y,z,t]
    else:
        x1, x2, x3, x4, x5, x6, x7, x8 = symbols(&#39;x1 x2 x3 x4 x5 x6 x7 x8&#39;)
        unknowns = [x1,x2,x3,x4,x5,x6,x7,x8]
    unknowns = unknowns[0:self.columnes]
    A = self * Vector(unknowns)
    eqs = [f&#34;{latex(A[i])} &amp;= \\lambda {unknowns[i]}&#34; for i in range(A.dimensio)]
    eqs = &#34; \\\\ &#34;.join(eqs)
    return f&#34;\\left.\\aligned {eqs} \\endaligned\\;\\right\\}}&#34;</code></pre>
</details>
</dd>
<dt id="Algebra.Matriu.submatriu"><code class="name flex">
<span>def <span class="ident">submatriu</span></span>(<span>self, files, columnes)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la submatriu determinada per les files "files" i les
columnes "columnes".</p>
<h2 id="parametrers">Paràmetrers</h2>
<p>files: llista de files
columnes: llista de columnes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def submatriu(self,files,columnes):
    &#34;&#34;&#34;
    Retorna la submatriu determinada per les files &#34;files&#34; i les
    columnes &#34;columnes&#34;.
    Paràmetrers:
        files: llista de files
        columnes: llista de columnes
    &#34;&#34;&#34;
    if not (isinstance(files,list) or isinstance(files,tuple)):
        return None
    if not (isinstance(columnes,list) or isinstance(columnes,tuple)):
        return None
    if max(columnes) &gt;= self.columnes or min(columnes) &lt; 0:
        return None
    if max(files) &gt;= self.files or min(files) &lt; 0:
        return None
    m = self.matriu[files,columnes]
    return Matriu(m)</code></pre>
</details>
</dd>
<dt id="Algebra.Matriu.subs"><code class="name flex">
<span>def <span class="ident">subs</span></span>(<span>self, l)</span>
</code></dt>
<dd>
<div class="desc"><p>Aplica una llista de substitucions</p>
<h2 id="parametres">Paràmetres</h2>
<p>l: llista de substitucions</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subs(self,l):
    &#34;&#34;&#34;
    Aplica una llista de substitucions
    Paràmetres:
        l: llista de substitucions
    &#34;&#34;&#34;
    for i in range(self.columnes):
        for j in range(self.files):
            for d in l:
                self[i,j] = self[i,j].subs(d)</code></pre>
</details>
</dd>
<dt id="Algebra.Matriu.transposada"><code class="name flex">
<span>def <span class="ident">transposada</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la transposada de la matriu</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transposada(self):
    &#34;&#34;&#34;
    Retorna la transposada de la matriu
    &#34;&#34;&#34;
    return Matriu(self.matriu.T)</code></pre>
</details>
</dd>
<dt id="Algebra.Matriu.vectors_columna"><code class="name flex">
<span>def <span class="ident">vectors_columna</span></span>(<span>self, simplificar=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna una llista amb els vectors columna de la matriu</p>
<h2 id="parametres">Paràmetres</h2>
<p>simplificar: si és True retornarà els vectors simplificats</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vectors_columna(self,simplificar=False):
    &#34;&#34;&#34;
    Retorna una llista amb els vectors columna de la matriu
    Paràmetres:
        simplificar: si és True retornarà els vectors simplificats
    &#34;&#34;&#34;
    vecs = []
    m = self.matriu
    for i in range(self.columnes):
        v = [m[j,i] for j in range(self.files)]
        u = Vector(v)
        if simplificar:
            u.simplificar()
        vecs.append(u)
    return vecs</code></pre>
</details>
</dd>
<dt id="Algebra.Matriu.vectors_fila"><code class="name flex">
<span>def <span class="ident">vectors_fila</span></span>(<span>self, simplificar=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna una llista amb els vectors fila de la matriu</p>
<h2 id="parametres">Paràmetres</h2>
<p>simplificar: si és True retornarà els vectors simplificats</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vectors_fila(self,simplificar=False):
    &#34;&#34;&#34;
    Retorna una llista amb els vectors fila de la matriu
    Paràmetres:
        simplificar: si és True retornarà els vectors simplificats
    &#34;&#34;&#34;
    vecs = []
    m = self.matriu
    for i in range(self.files):
        v = [m[i,j] for j in range(self.columnes)]
        u = Vector(v)
        if simplificar:
            u.simplificar()
        vecs.append(u)
    return vecs</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Algebra.Parabola"><code class="flex name class">
<span>class <span class="ident">Parabola</span></span>
<span>(</span><span>vertex, focus)</span>
</code></dt>
<dd>
<div class="desc"><p>Classe per treballar amb paràboles</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Parabola(Conica):
    &#34;&#34;&#34;
    Classe per treballar amb paràboles
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,vertex,focus):
        &#34;&#34;&#34;
        Constructor.
        Retorna una paràbola
        Paràmetres:
            vertex: vèrtex
            focus: focus de la paràbola
        &#34;&#34;&#34;
        if not isinstance(vertex,Punt):
            return None
        if not isinstance(focus,Punt):
            return None
        if vertex.dimensio != 2:
            return None
        if focus.dimensio != 2:
            return None
        if vertex == focus:
            return None
        return super(Conica,cls).__new__(cls)
    #
    #
    #
    def __init__(self,vertex,focus):
        eix = focus - vertex
        p = 2 * eix.length()
        s = SubespaiVectorial([eix])
        base = s.amplia_base_suplementari(unitaria=True)
        v1, v2 = base.vecs
        if v1[0] &lt; 0:
            v1 = -v1
        if v2[1] &lt; 0:
            v2 = -v2
        if eix * v2 &lt; 0:
            p = -p
        base.vecs = [v1,v2]
        m = Matriu(Matrix(3,3,[1,0,0,0,0,-p,0,-p,0]))
        r = ReferenciaAfi(vertex,base)
        Conica.__init__(self,m,r)
    #
    #
    #
    @classmethod
    def aleatoria(cls,canonica=False):
        &#34;&#34;&#34;
        Retorna una paràbola aleatòria
        &#34;&#34;&#34;
        trobat = False
        while not trobat:
            if canonica:
                base = [Vector(1,0),Vector(0,1)]
                random.shuffle(base)
                eix = base[0]
                vertex = Punt.aleatori(l=2,maxim=4,nuls=False)
                p = random.randint(-3,3)
                if p == 0:
                    p = 2
                focus = (vertex + p * eix).punt()
                trobat = True
            else:
                vertex = Punt.aleatori(l=2,maxim=5,nuls=False)
                focus = Punt.aleatori(l=2,maxim=5)
                trobat = vertex[0] != focus[0] and vertex[1] != focus[1]
        return cls(vertex,focus)
    #
    #
    #
    def parametre(self):
        &#34;&#34;&#34;
        Retorna el paràmetre de la paràbola
        &#34;&#34;&#34;
        return abs(self.matriu[2,1])
    #
    #
    #
    def vertex(self):
        &#34;&#34;&#34;
        Retorna el vèrtex de la paràbola
        &#34;&#34;&#34;
        return (self.ref.origen)
    #
    #
    #
    def maxim_origen(self):
        &#34;&#34;&#34;
        Retorna el màxim dels valors absoluts de les coordenades del vèrtex
        &#34;&#34;&#34;
        return self.ref.origen.maxim()
    #
    #
    #
    def equacio_reduida(self):
        &#34;&#34;&#34;
        Retorna l&#39;equacio reduïda de la paràbola en format LaTeX
        &#34;&#34;&#34;
        minus = &#34;&#34;
        p = self.parametre()
        eix = self.focus() - self.vertex()
        v2 = self.ref.base.vecs[1]
        if eix * v2 &lt; 0:
            minus = &#34;-&#34;
        if 2 * p == 1:
            return f&#34;y&#39; = {minus}x&#39;^2&#34;
        return f&#34;y&#39; = {minus}\\frac{{x&#39;^2}}{{{ latex(2 * p) }}}&#34;
    #
    #
    #
    def focus(self):
        &#34;&#34;&#34;
        Retorna el focus de la paràbola
        &#34;&#34;&#34;
        p2 = self.parametre() / 2
        if self.matriu[2,1] &gt; 0:
            p2 *= -1
        return self.ref.punt_de_coordenades(Punt([0,p2]))
    #
    #
    #
    def recta_directriu(self):
        &#34;&#34;&#34;
        Retorna la recta directriu com a recta afí
        &#34;&#34;&#34;
        p2 = self.parametre() / 2
        if self.matriu[2,1] &gt; 0:
            p2 *= -1
        p = self.ref.punt_de_coordenades(Punt([0,-p2]))
        return RectaAfi(p,self.ref.base.vecs[0])
    #
    #
    #
    def to_asy(self,scaled=1.0,canonica=10,x=8,y=8):
        &#34;&#34;&#34;
        Retorna una expressió per fer servir amb el programa Asymtote
        Paràmetres:
            scaled: factor d&#39;escalat
            canonica = valors de partida dels eixos de la referència canònica
            x, y: nombres enters. El gràfic es representarà en una quadricula
            de límits (-x,x) i (-y,y)
        &#34;&#34;&#34;
        mx, Mx  = -canonica + self.vertex()[0],canonica + self.vertex()[0]
        my, My  = -canonica + self.vertex()[1],canonica + self.vertex()[1]
        d = 1
        if self.matriu[2,1] &gt; 0:
            d = -1
        str = f&#34;Canonica({mx},{Mx},{my},{My},scaled={scaled});&#34;
        clip = f&#34;path cl = ({mx},{my})--({Mx},{my})--({Mx},{My})--({mx},{My})--cycle;\n&#34;
        clip += f&#34;cl = scale({scaled}) * cl;\nclip(cl);&#34;
        return f&#34;{str}\nParabola({self.vertex()},{self.focus()},d={d},x={x},y={y},scaled={scaled});\n{clip}&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Algebra.Conica" href="#Algebra.Conica">Conica</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="Algebra.Parabola.aleatoria"><code class="name flex">
<span>def <span class="ident">aleatoria</span></span>(<span>canonica=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna una paràbola aleatòria</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def aleatoria(cls,canonica=False):
    &#34;&#34;&#34;
    Retorna una paràbola aleatòria
    &#34;&#34;&#34;
    trobat = False
    while not trobat:
        if canonica:
            base = [Vector(1,0),Vector(0,1)]
            random.shuffle(base)
            eix = base[0]
            vertex = Punt.aleatori(l=2,maxim=4,nuls=False)
            p = random.randint(-3,3)
            if p == 0:
                p = 2
            focus = (vertex + p * eix).punt()
            trobat = True
        else:
            vertex = Punt.aleatori(l=2,maxim=5,nuls=False)
            focus = Punt.aleatori(l=2,maxim=5)
            trobat = vertex[0] != focus[0] and vertex[1] != focus[1]
    return cls(vertex,focus)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Algebra.Parabola.equacio_reduida"><code class="name flex">
<span>def <span class="ident">equacio_reduida</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna l'equacio reduïda de la paràbola en format LaTeX</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def equacio_reduida(self):
    &#34;&#34;&#34;
    Retorna l&#39;equacio reduïda de la paràbola en format LaTeX
    &#34;&#34;&#34;
    minus = &#34;&#34;
    p = self.parametre()
    eix = self.focus() - self.vertex()
    v2 = self.ref.base.vecs[1]
    if eix * v2 &lt; 0:
        minus = &#34;-&#34;
    if 2 * p == 1:
        return f&#34;y&#39; = {minus}x&#39;^2&#34;
    return f&#34;y&#39; = {minus}\\frac{{x&#39;^2}}{{{ latex(2 * p) }}}&#34;</code></pre>
</details>
</dd>
<dt id="Algebra.Parabola.focus"><code class="name flex">
<span>def <span class="ident">focus</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el focus de la paràbola</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def focus(self):
    &#34;&#34;&#34;
    Retorna el focus de la paràbola
    &#34;&#34;&#34;
    p2 = self.parametre() / 2
    if self.matriu[2,1] &gt; 0:
        p2 *= -1
    return self.ref.punt_de_coordenades(Punt([0,p2]))</code></pre>
</details>
</dd>
<dt id="Algebra.Parabola.maxim_origen"><code class="name flex">
<span>def <span class="ident">maxim_origen</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el màxim dels valors absoluts de les coordenades del vèrtex</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def maxim_origen(self):
    &#34;&#34;&#34;
    Retorna el màxim dels valors absoluts de les coordenades del vèrtex
    &#34;&#34;&#34;
    return self.ref.origen.maxim()</code></pre>
</details>
</dd>
<dt id="Algebra.Parabola.parametre"><code class="name flex">
<span>def <span class="ident">parametre</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el paràmetre de la paràbola</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parametre(self):
    &#34;&#34;&#34;
    Retorna el paràmetre de la paràbola
    &#34;&#34;&#34;
    return abs(self.matriu[2,1])</code></pre>
</details>
</dd>
<dt id="Algebra.Parabola.recta_directriu"><code class="name flex">
<span>def <span class="ident">recta_directriu</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la recta directriu com a recta afí</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recta_directriu(self):
    &#34;&#34;&#34;
    Retorna la recta directriu com a recta afí
    &#34;&#34;&#34;
    p2 = self.parametre() / 2
    if self.matriu[2,1] &gt; 0:
        p2 *= -1
    p = self.ref.punt_de_coordenades(Punt([0,-p2]))
    return RectaAfi(p,self.ref.base.vecs[0])</code></pre>
</details>
</dd>
<dt id="Algebra.Parabola.to_asy"><code class="name flex">
<span>def <span class="ident">to_asy</span></span>(<span>self, scaled=1.0, canonica=10, x=8, y=8)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna una expressió per fer servir amb el programa Asymtote</p>
<h2 id="parametres">Paràmetres</h2>
<p>scaled: factor d'escalat
canonica = valors de partida dels eixos de la referència canònica
x, y: nombres enters. El gràfic es representarà en una quadricula
de límits (-x,x) i (-y,y)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_asy(self,scaled=1.0,canonica=10,x=8,y=8):
    &#34;&#34;&#34;
    Retorna una expressió per fer servir amb el programa Asymtote
    Paràmetres:
        scaled: factor d&#39;escalat
        canonica = valors de partida dels eixos de la referència canònica
        x, y: nombres enters. El gràfic es representarà en una quadricula
        de límits (-x,x) i (-y,y)
    &#34;&#34;&#34;
    mx, Mx  = -canonica + self.vertex()[0],canonica + self.vertex()[0]
    my, My  = -canonica + self.vertex()[1],canonica + self.vertex()[1]
    d = 1
    if self.matriu[2,1] &gt; 0:
        d = -1
    str = f&#34;Canonica({mx},{Mx},{my},{My},scaled={scaled});&#34;
    clip = f&#34;path cl = ({mx},{my})--({Mx},{my})--({Mx},{My})--({mx},{My})--cycle;\n&#34;
    clip += f&#34;cl = scale({scaled}) * cl;\nclip(cl);&#34;
    return f&#34;{str}\nParabola({self.vertex()},{self.focus()},d={d},x={x},y={y},scaled={scaled});\n{clip}&#34;</code></pre>
</details>
</dd>
<dt id="Algebra.Parabola.vertex"><code class="name flex">
<span>def <span class="ident">vertex</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el vèrtex de la paràbola</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertex(self):
    &#34;&#34;&#34;
    Retorna el vèrtex de la paràbola
    &#34;&#34;&#34;
    return (self.ref.origen)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Algebra.Conica" href="#Algebra.Conica">Conica</a></b></code>:
<ul class="hlist">
<li><code><a title="Algebra.Conica.eix_principal" href="#Algebra.Conica.eix_principal">eix_principal</a></code></li>
<li><code><a title="Algebra.Conica.eix_secundari" href="#Algebra.Conica.eix_secundari">eix_secundari</a></code></li>
<li><code><a title="Algebra.Conica.ellipse" href="#Algebra.Conica.ellipse">ellipse</a></code></li>
<li><code><a title="Algebra.Conica.equacio" href="#Algebra.Conica.equacio">equacio</a></code></li>
<li><code><a title="Algebra.Conica.from_equacio" href="#Algebra.Conica.from_equacio">from_equacio</a></code></li>
<li><code><a title="Algebra.Conica.hiperbola" href="#Algebra.Conica.hiperbola">hiperbola</a></code></li>
<li><code><a title="Algebra.Conica.parabola" href="#Algebra.Conica.parabola">parabola</a></code></li>
<li><code><a title="Algebra.Conica.referencia_principal" href="#Algebra.Conica.referencia_principal">referencia_principal</a></code></li>
<li><code><a title="Algebra.Conica.tipus" href="#Algebra.Conica.tipus">tipus</a></code></li>
<li><code><a title="Algebra.Conica.vectors" href="#Algebra.Conica.vectors">vectors</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Algebra.ParaboloideElliptic"><code class="flex name class">
<span>class <span class="ident">ParaboloideElliptic</span></span>
<span>(</span><span>a2, b2, vertex, eix1, eix2)</span>
</code></dt>
<dd>
<div class="desc"><p>Classe per treballar amb paraboloides el·líptics</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParaboloideElliptic(Quadrica):
    &#34;&#34;&#34;
    Classe per treballar amb paraboloides el·líptics
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,a2,b2,vertex,eix1,eix2):
        &#34;&#34;&#34;
        Constructor.
        Retorna el paraboloide el·líptic amb vèrtex &#34;vertex&#34; i semieixos l*a2
        i l*b2, on l és la longitud de eix3
        Paràmetres:
           a2, b2: nombres enters positius
           eix1: direcció de l&#39;eix principal (de les x&#39;)
           eix2: en pricipi és la direcció de l&#39;eix de les y&#39;, però si no és
                 perpendicular a eix1, es calcula el perpendicular que està
                 en el mateix pla vectorial que &lt;eix1,eix2&gt; aplicant el
                 mètode de Gram-Schmidt
        &#34;&#34;&#34;
        if not isinstance(vertex,Punt):
            return None
        if not isinstance(eix1,Vector):
            return None
        if not isinstance(eix2,Vector):
            return None
        if vertex.dimensio != 3:
            return None
        if eix1.dimensio != 3:
            return None
        if eix2.dimensio != 3:
            return None
        if eix1.length() == 0:
            return None
        if eix2.length() == 0:
            return None
        m = Matriu.from_vectors_columna([eix1,eix2])
        if m.rank() != 2:
            return None
        if a2 &lt;= 0:
            return None
        if b2 &lt;= 0:
            return None
        a2 = sympify(a2)
        b2 = sympify(b2)
        if not a2.is_integer or not b2.is_integer:
            return None
        return super(Quadrica,cls).__new__(cls)
    #
    #
    #
    def __init__(self,a2,b2,vertex,eix1,eix2):
        s = SubespaiVectorial([eix1,eix2])
        base = s.amplia_base(unitaria=True)
        r = ReferenciaAfi(vertex,base)
        q = base.quadrats_longituds()
        t = a2 * b2
        a2 = t // a2
        b2 = t // b2
        t *= sqrt(q[2])
        m = Matriu(Matrix([[a2,0,0,0],[0,b2,0,0],[0,0,0,-t/2],[0,0,-t/2,0]]))
        Quadrica.__init__(self,m,r)
    #
    #
    #
    @classmethod
    def aleatoria(cls,canonica=False):
        &#34;&#34;&#34;
        Retorna un paraboloide el·líptic de manera aleatòria
        &#34;&#34;&#34;
        if canonica:
            v = [Vector(1,0,0),Vector(0,1,0),Vector(0,0,1)]
            random.shuffle(v)
            eix1, eix2, _ = v
        else:
            trobat = False
            while not trobat:
                eix1 = Vector.aleatori(l=3,maxim=3)
                eix2 = Vector.aleatori(l=3,maxim=3)
                if eix1.nzeros() &gt; 1 or eix2.nzeros() &gt; 1:
                    continue
                trobat = Matriu.from_vectors_columna([eix1,eix2]).rank() == 2
        trobat = False
        while not trobat:
            vertex = Punt.aleatori(l=3,maxim=4,nuls=False)
            trobat = vertex.length() &gt; 0
        c = [1,2,3,4,5,8,10,12,16,18,20,25,36,40,45,48,50,60]
        trobat = False
        while not trobat:
            a = random.randint(0,len(c) - 1)
            a2 = c[a]
            a = random.randint(0,len(c) - 1)
            b2 = c[a]
            trobat = a2 != b2
        a2, b2 = sorted([a2,b2])[::-1]
        return cls(a2,b2,vertex,eix1,eix2)
    #
    #
    #
    def vertex(self):
        &#34;&#34;&#34;
        Retorna el vèrtex del paraboloide el·líptic
        &#34;&#34;&#34;
        return (self.ref.origen)
    #
    #
    #
    def semieixos(self):
        &#34;&#34;&#34;
        Retorna els semieixos del paraboloide el·líptic
        &#34;&#34;&#34;
        a = self.matriu[0,0]
        b = self.matriu[1,1]
        t = - 2 * self.matriu[2,3]
        return (sqrt(t/a),sqrt(t/b))
    #
    #
    #
    def semieixos_quadrats(self):
        &#34;&#34;&#34;
        Retorna els semieixos al quadrat del paraboloide el·líptic
        &#34;&#34;&#34;
        a = self.matriu[0,0]
        b = self.matriu[1,1]
        t = - 2 * self.matriu[2,3]
        return (t/a,t/b)
    #
    #
    #
    def equacio_reduida(self):
        &#34;&#34;&#34;
        Retorna l&#39;equacio reduïda del paraboloide el·líptic
        &#34;&#34;&#34;
        a2, b2 = self.semieixos_quadrats()
        if a2 == 1:
            str = &#34;z&#39; = x&#39;^2&#34;
        else:
            str = f&#34;z&#39; = \\frac{{x&#39;^2}}{{ {latex(a2)} }}&#34;
        if b2 == 1:
            str += &#34; + y&#39;^2&#34;
        else:
            str += f&#34; + \\frac{{y&#39;^2}}{{ {latex(b2)} }}&#34;
        return str</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Algebra.Quadrica" href="#Algebra.Quadrica">Quadrica</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="Algebra.ParaboloideElliptic.aleatoria"><code class="name flex">
<span>def <span class="ident">aleatoria</span></span>(<span>canonica=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna un paraboloide el·líptic de manera aleatòria</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def aleatoria(cls,canonica=False):
    &#34;&#34;&#34;
    Retorna un paraboloide el·líptic de manera aleatòria
    &#34;&#34;&#34;
    if canonica:
        v = [Vector(1,0,0),Vector(0,1,0),Vector(0,0,1)]
        random.shuffle(v)
        eix1, eix2, _ = v
    else:
        trobat = False
        while not trobat:
            eix1 = Vector.aleatori(l=3,maxim=3)
            eix2 = Vector.aleatori(l=3,maxim=3)
            if eix1.nzeros() &gt; 1 or eix2.nzeros() &gt; 1:
                continue
            trobat = Matriu.from_vectors_columna([eix1,eix2]).rank() == 2
    trobat = False
    while not trobat:
        vertex = Punt.aleatori(l=3,maxim=4,nuls=False)
        trobat = vertex.length() &gt; 0
    c = [1,2,3,4,5,8,10,12,16,18,20,25,36,40,45,48,50,60]
    trobat = False
    while not trobat:
        a = random.randint(0,len(c) - 1)
        a2 = c[a]
        a = random.randint(0,len(c) - 1)
        b2 = c[a]
        trobat = a2 != b2
    a2, b2 = sorted([a2,b2])[::-1]
    return cls(a2,b2,vertex,eix1,eix2)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Algebra.ParaboloideElliptic.equacio_reduida"><code class="name flex">
<span>def <span class="ident">equacio_reduida</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna l'equacio reduïda del paraboloide el·líptic</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def equacio_reduida(self):
    &#34;&#34;&#34;
    Retorna l&#39;equacio reduïda del paraboloide el·líptic
    &#34;&#34;&#34;
    a2, b2 = self.semieixos_quadrats()
    if a2 == 1:
        str = &#34;z&#39; = x&#39;^2&#34;
    else:
        str = f&#34;z&#39; = \\frac{{x&#39;^2}}{{ {latex(a2)} }}&#34;
    if b2 == 1:
        str += &#34; + y&#39;^2&#34;
    else:
        str += f&#34; + \\frac{{y&#39;^2}}{{ {latex(b2)} }}&#34;
    return str</code></pre>
</details>
</dd>
<dt id="Algebra.ParaboloideElliptic.semieixos"><code class="name flex">
<span>def <span class="ident">semieixos</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna els semieixos del paraboloide el·líptic</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def semieixos(self):
    &#34;&#34;&#34;
    Retorna els semieixos del paraboloide el·líptic
    &#34;&#34;&#34;
    a = self.matriu[0,0]
    b = self.matriu[1,1]
    t = - 2 * self.matriu[2,3]
    return (sqrt(t/a),sqrt(t/b))</code></pre>
</details>
</dd>
<dt id="Algebra.ParaboloideElliptic.semieixos_quadrats"><code class="name flex">
<span>def <span class="ident">semieixos_quadrats</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna els semieixos al quadrat del paraboloide el·líptic</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def semieixos_quadrats(self):
    &#34;&#34;&#34;
    Retorna els semieixos al quadrat del paraboloide el·líptic
    &#34;&#34;&#34;
    a = self.matriu[0,0]
    b = self.matriu[1,1]
    t = - 2 * self.matriu[2,3]
    return (t/a,t/b)</code></pre>
</details>
</dd>
<dt id="Algebra.ParaboloideElliptic.vertex"><code class="name flex">
<span>def <span class="ident">vertex</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el vèrtex del paraboloide el·líptic</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertex(self):
    &#34;&#34;&#34;
    Retorna el vèrtex del paraboloide el·líptic
    &#34;&#34;&#34;
    return (self.ref.origen)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Algebra.Quadrica" href="#Algebra.Quadrica">Quadrica</a></b></code>:
<ul class="hlist">
<li><code><a title="Algebra.Quadrica.cilindreelliptic" href="#Algebra.Quadrica.cilindreelliptic">cilindreelliptic</a></code></li>
<li><code><a title="Algebra.Quadrica.cilindrehiperbolic" href="#Algebra.Quadrica.cilindrehiperbolic">cilindrehiperbolic</a></code></li>
<li><code><a title="Algebra.Quadrica.cilindreparabolic" href="#Algebra.Quadrica.cilindreparabolic">cilindreparabolic</a></code></li>
<li><code><a title="Algebra.Quadrica.con" href="#Algebra.Quadrica.con">con</a></code></li>
<li><code><a title="Algebra.Quadrica.ellipsoide" href="#Algebra.Quadrica.ellipsoide">ellipsoide</a></code></li>
<li><code><a title="Algebra.Quadrica.equacio" href="#Algebra.Quadrica.equacio">equacio</a></code></li>
<li><code><a title="Algebra.Quadrica.from_equacio" href="#Algebra.Quadrica.from_equacio">from_equacio</a></code></li>
<li><code><a title="Algebra.Quadrica.hiperboloideduesfulles" href="#Algebra.Quadrica.hiperboloideduesfulles">hiperboloideduesfulles</a></code></li>
<li><code><a title="Algebra.Quadrica.hiperboloideunafulla" href="#Algebra.Quadrica.hiperboloideunafulla">hiperboloideunafulla</a></code></li>
<li><code><a title="Algebra.Quadrica.paraboloideelliptic" href="#Algebra.Quadrica.paraboloideelliptic">paraboloideelliptic</a></code></li>
<li><code><a title="Algebra.Quadrica.paraboloidehiperbolic" href="#Algebra.Quadrica.paraboloidehiperbolic">paraboloidehiperbolic</a></code></li>
<li><code><a title="Algebra.Quadrica.referencia_principal" href="#Algebra.Quadrica.referencia_principal">referencia_principal</a></code></li>
<li><code><a title="Algebra.Quadrica.tipus" href="#Algebra.Quadrica.tipus">tipus</a></code></li>
<li><code><a title="Algebra.Quadrica.vectors" href="#Algebra.Quadrica.vectors">vectors</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Algebra.ParaboloideHiperbolic"><code class="flex name class">
<span>class <span class="ident">ParaboloideHiperbolic</span></span>
<span>(</span><span>a2, b2, vertex, eix1, eix2)</span>
</code></dt>
<dd>
<div class="desc"><p>Classe per treballar amb paraboloides hiperbòlics</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParaboloideHiperbolic(Quadrica):
    &#34;&#34;&#34;
    Classe per treballar amb paraboloides hiperbòlics
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,a2,b2,vertex,eix1,eix2):
        &#34;&#34;&#34;
        Constructor.
        Retorna el paraboloide hiperbòlic amb vèrtex &#34;vertex&#34; i semieixos l*a2
        i l*b2, on l és la longitud de eix3
        Paràmetres:
           a2, b2: nombres enters positius
           eix1: direcció de l&#39;eix principal (de les x&#39;)
           eix2: en pricipi és la direcció de l&#39;eix de les y&#39;, però si no és
                 perpendicular a eix1, es calcula el perpendicular que està
                 en el mateix pla vectorial que &lt;eix1,eix2&gt; aplicant el
                 mètode de Gram-Schmidt
        &#34;&#34;&#34;
        if not isinstance(vertex,Punt):
            return None
        if not isinstance(eix1,Vector):
            return None
        if not isinstance(eix2,Vector):
            return None
        if vertex.dimensio != 3:
            return None
        if eix1.dimensio != 3:
            return None
        if eix2.dimensio != 3:
            return None
        if eix1.length() == 0:
            return None
        if eix2.length() == 0:
            return None
        m = Matriu.from_vectors_columna([eix1,eix2])
        if m.rank() != 2:
            return None
        if a2 &lt;= 0:
            return None
        if b2 &lt;= 0:
            return None
        a2 = sympify(a2)
        b2 = sympify(b2)
        if not a2.is_integer or not b2.is_integer:
            return None
        return super(Quadrica,cls).__new__(cls)
    #
    #
    #
    def __init__(self,a2,b2,vertex,eix1,eix2):
        s = SubespaiVectorial([eix1,eix2])
        base = s.amplia_base(unitaria=True)
        r = ReferenciaAfi(vertex,base)
        g = mcd_llista([a2,b2])
        t = a2 * b2 // g
        a2 = a2 // g
        b2 = b2 // g
        q = base.quadrats_longituds()
        if random.randint(0,1):
            t /= sqrt(q[2])
        else:
            t *= sqrt(q[2])
        m = Matriu(Matrix([[b2,0,0,0],[0,-a2,0,0],[0,0,0,-t/2],[0,0,-t/2,0]]))
        Quadrica.__init__(self,m,r)
    #
    #
    #
    @classmethod
    def aleatoria(cls,canonica=False):
        &#34;&#34;&#34;
        Retorna un paraboloide hiperbòlic de manera aleatòria
        &#34;&#34;&#34;
        if canonica:
            v = [Vector(1,0,0),Vector(0,1,0),Vector(0,0,1)]
            random.shuffle(v)
            eix1, eix2, _ = v
        else:
            trobat = False
            while not trobat:
                eix1 = Vector.aleatori(l=3,maxim=3)
                eix2 = Vector.aleatori(l=3,maxim=3)
                if eix1.nzeros() &gt; 1 or eix2.nzeros() &gt; 1:
                    continue
                trobat = Matriu.from_vectors_columna([eix1,eix2]).rank() == 2
        trobat = False
        while not trobat:
            vertex = Punt.aleatori(l=3,maxim=4,nuls=False)
            trobat = vertex.length() &gt; 0
        c = [1,2,3,4,5,8,10,12,16]
        trobat = False
        while not trobat:
            a = random.randint(0,len(c) - 1)
            a2 = c[a]
            a = random.randint(0,len(c) - 1)
            b2 = c[a]
            trobat = a2 != b2
        return cls(a2,b2,vertex,eix1,eix2)
    #
    #
    #
    def vertex(self):
        &#34;&#34;&#34;
        Retorna el vèrtex del paraboloide hiperbòlic
        &#34;&#34;&#34;
        return (self.ref.origen)
    #
    #
    #
    def semieixos(self):
        &#34;&#34;&#34;
        Retorna els semieixos del paraboloide hiperbòlic
        &#34;&#34;&#34;
        a = self.matriu[0,0]
        b = - self.matriu[1,1]
        t = - 2 * self.matriu[2,3]
        return (sqrt(t,a),sqrt(t,b))
    #
    #
    #
    def semieixos_quadrats(self):
        &#34;&#34;&#34;
        Retorna els semieixos al quadrat del paraboloide hiperbòlic
        &#34;&#34;&#34;
        a = self.matriu[0,0]
        b = - self.matriu[1,1]
        t = - 2 * self.matriu[2,3]
        return (t/a,t/b)
    #
    #
    #
    def equacio_reduida(self):
        &#34;&#34;&#34;
        Retorna l&#39;equacio reduïda del paraboloide hiperbòlic
        &#34;&#34;&#34;
        a2, b2 = self.semieixos_quadrats()
        if a2 == 1:
            str = &#34;z&#39; = x&#39;^2&#34;
        else:
            str = f&#34;z&#39; = \\frac{{x&#39;^2}}{{ {latex(a2)} }}&#34;
        if b2 == 1:
            str += &#34; - y&#39;^2&#34;
        else:
            str += f&#34; - \\frac{{y&#39;^2}}{{ {latex(b2)} }}&#34;
        return str</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Algebra.Quadrica" href="#Algebra.Quadrica">Quadrica</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="Algebra.ParaboloideHiperbolic.aleatoria"><code class="name flex">
<span>def <span class="ident">aleatoria</span></span>(<span>canonica=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna un paraboloide hiperbòlic de manera aleatòria</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def aleatoria(cls,canonica=False):
    &#34;&#34;&#34;
    Retorna un paraboloide hiperbòlic de manera aleatòria
    &#34;&#34;&#34;
    if canonica:
        v = [Vector(1,0,0),Vector(0,1,0),Vector(0,0,1)]
        random.shuffle(v)
        eix1, eix2, _ = v
    else:
        trobat = False
        while not trobat:
            eix1 = Vector.aleatori(l=3,maxim=3)
            eix2 = Vector.aleatori(l=3,maxim=3)
            if eix1.nzeros() &gt; 1 or eix2.nzeros() &gt; 1:
                continue
            trobat = Matriu.from_vectors_columna([eix1,eix2]).rank() == 2
    trobat = False
    while not trobat:
        vertex = Punt.aleatori(l=3,maxim=4,nuls=False)
        trobat = vertex.length() &gt; 0
    c = [1,2,3,4,5,8,10,12,16]
    trobat = False
    while not trobat:
        a = random.randint(0,len(c) - 1)
        a2 = c[a]
        a = random.randint(0,len(c) - 1)
        b2 = c[a]
        trobat = a2 != b2
    return cls(a2,b2,vertex,eix1,eix2)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Algebra.ParaboloideHiperbolic.equacio_reduida"><code class="name flex">
<span>def <span class="ident">equacio_reduida</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna l'equacio reduïda del paraboloide hiperbòlic</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def equacio_reduida(self):
    &#34;&#34;&#34;
    Retorna l&#39;equacio reduïda del paraboloide hiperbòlic
    &#34;&#34;&#34;
    a2, b2 = self.semieixos_quadrats()
    if a2 == 1:
        str = &#34;z&#39; = x&#39;^2&#34;
    else:
        str = f&#34;z&#39; = \\frac{{x&#39;^2}}{{ {latex(a2)} }}&#34;
    if b2 == 1:
        str += &#34; - y&#39;^2&#34;
    else:
        str += f&#34; - \\frac{{y&#39;^2}}{{ {latex(b2)} }}&#34;
    return str</code></pre>
</details>
</dd>
<dt id="Algebra.ParaboloideHiperbolic.semieixos"><code class="name flex">
<span>def <span class="ident">semieixos</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna els semieixos del paraboloide hiperbòlic</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def semieixos(self):
    &#34;&#34;&#34;
    Retorna els semieixos del paraboloide hiperbòlic
    &#34;&#34;&#34;
    a = self.matriu[0,0]
    b = - self.matriu[1,1]
    t = - 2 * self.matriu[2,3]
    return (sqrt(t,a),sqrt(t,b))</code></pre>
</details>
</dd>
<dt id="Algebra.ParaboloideHiperbolic.semieixos_quadrats"><code class="name flex">
<span>def <span class="ident">semieixos_quadrats</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna els semieixos al quadrat del paraboloide hiperbòlic</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def semieixos_quadrats(self):
    &#34;&#34;&#34;
    Retorna els semieixos al quadrat del paraboloide hiperbòlic
    &#34;&#34;&#34;
    a = self.matriu[0,0]
    b = - self.matriu[1,1]
    t = - 2 * self.matriu[2,3]
    return (t/a,t/b)</code></pre>
</details>
</dd>
<dt id="Algebra.ParaboloideHiperbolic.vertex"><code class="name flex">
<span>def <span class="ident">vertex</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el vèrtex del paraboloide hiperbòlic</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertex(self):
    &#34;&#34;&#34;
    Retorna el vèrtex del paraboloide hiperbòlic
    &#34;&#34;&#34;
    return (self.ref.origen)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Algebra.Quadrica" href="#Algebra.Quadrica">Quadrica</a></b></code>:
<ul class="hlist">
<li><code><a title="Algebra.Quadrica.cilindreelliptic" href="#Algebra.Quadrica.cilindreelliptic">cilindreelliptic</a></code></li>
<li><code><a title="Algebra.Quadrica.cilindrehiperbolic" href="#Algebra.Quadrica.cilindrehiperbolic">cilindrehiperbolic</a></code></li>
<li><code><a title="Algebra.Quadrica.cilindreparabolic" href="#Algebra.Quadrica.cilindreparabolic">cilindreparabolic</a></code></li>
<li><code><a title="Algebra.Quadrica.con" href="#Algebra.Quadrica.con">con</a></code></li>
<li><code><a title="Algebra.Quadrica.ellipsoide" href="#Algebra.Quadrica.ellipsoide">ellipsoide</a></code></li>
<li><code><a title="Algebra.Quadrica.equacio" href="#Algebra.Quadrica.equacio">equacio</a></code></li>
<li><code><a title="Algebra.Quadrica.from_equacio" href="#Algebra.Quadrica.from_equacio">from_equacio</a></code></li>
<li><code><a title="Algebra.Quadrica.hiperboloideduesfulles" href="#Algebra.Quadrica.hiperboloideduesfulles">hiperboloideduesfulles</a></code></li>
<li><code><a title="Algebra.Quadrica.hiperboloideunafulla" href="#Algebra.Quadrica.hiperboloideunafulla">hiperboloideunafulla</a></code></li>
<li><code><a title="Algebra.Quadrica.paraboloideelliptic" href="#Algebra.Quadrica.paraboloideelliptic">paraboloideelliptic</a></code></li>
<li><code><a title="Algebra.Quadrica.paraboloidehiperbolic" href="#Algebra.Quadrica.paraboloidehiperbolic">paraboloidehiperbolic</a></code></li>
<li><code><a title="Algebra.Quadrica.referencia_principal" href="#Algebra.Quadrica.referencia_principal">referencia_principal</a></code></li>
<li><code><a title="Algebra.Quadrica.tipus" href="#Algebra.Quadrica.tipus">tipus</a></code></li>
<li><code><a title="Algebra.Quadrica.vectors" href="#Algebra.Quadrica.vectors">vectors</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Algebra.PlaAfi"><code class="flex name class">
<span>class <span class="ident">PlaAfi</span></span>
<span>(</span><span>p, u1, u2, ref=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Classe per treballar amb plans afins.</p>
<h2 id="atributs">Atributs</h2>
<p>u1, u2: vectors directors del pla
p: punt de pas</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PlaAfi(object):
    &#34;&#34;&#34;
    Classe per treballar amb plans afins.
    Atributs:
        u1, u2: vectors directors del pla
        p: punt de pas
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,p,u1,u2,ref=None):
        &#34;&#34;&#34;
        Constructor.
        Paràmetres:
            p: punt de pas
            u1, u2: generadors del pla
            ref: referència en que estan expressats u1, u2 i p
        &#34;&#34;&#34;
        if not isinstance(u1,Vector):
            return None
        if not isinstance(u2,Vector):
            return None
        if not isinstance(p,Punt):
            return None
        if u1.dimensio != 3 or u2.dimensio != 3:
            return None
        if p.dimensio != 3:
            return None
        if ref is not None:
            if not isinstance(ref,ReferenciaAfi):
                return None
            if ref.dimensio != 3:
                return None
        m = Matriu.from_vectors_columna([u1,u2])
        if m.rank() != 2:
            return None
        return super(PlaAfi,cls).__new__(cls)
    #
    #
    #
    def __init__(self,p,u1,u2,ref=None):
        if ref is None:
            self.u1 = u1
            self.u2 = u2
            self.p = p
        else:
            self.u1 = ref.base.vector_de_components(u1)
            self.u2 = ref.base.vector_de_components(u2)
            self.p = ref.punt_de_coordenades(p)
    #
    #
    #
    @classmethod
    def aleatori(cls):
        m = Matriu.amb_rang(f=2,c=3,r=2,maxim=4,mzeros=0)
        v = m.vectors_fila()
        p = Punt.aleatori(l=3,maxim=3,nuls=False)
        return cls(p,v[0],v[1])
    #
    #
    #
    @classmethod
    def amb_associat(cls,w,p):
        &#34;&#34;&#34;
        Genera el pla afí que té vector perpendicular &#34;w&#34; i passa pel punt p
        Paràmetres:
            w: vector associat
            p: punt de pas
        &#34;&#34;&#34;
        if not isinstance(w,Vector):
            return None
        if not isinstance(p,Punt):
            return None
        a = Matriu.from_vectors_fila([w])
        l = a.nucli()
        return cls(p,l[0],l[1])
    #
    #
    #
    def punt_de_coordenades_enteres(self,p=None,u=None,v=None):
        &#34;&#34;&#34;
        Retorna, si és possible, un punt de coordenades enteres del pla afí
        que passa pel punt p i té vectors directors u i v
        &#34;&#34;&#34;
        if p is None:
            p = self.p
        if u is None:
            u = self.u1
        if v is None:
            v = self.u2
        if p.tots_enters():
            return p
        t, _ = p.factor_comu()
        if isinstance(t,int) or isinstance(t,Integer):
            return p
        for i in range(1,t.q):
            for j in range(1,t.q):
                r = (p + Rational(i,t.q) * u + Rational(j,t.q) * v).punt()
                if r.tots_enters():
                    return r
                r = (p + Rational(i,t.q) * u - Rational(j,t.q) * v).punt()
                if r.tots_enters():
                    return r
                r = (p - Rational(i,t.q) * u + Rational(j,t.q) * v).punt()
                if r.tots_enters():
                    return r
                r = (p - Rational(i,t.q) * u - Rational(j,t.q) * v).punt()
                if r.tots_enters():
                    return r
        return p
    #
    #
    #
    @classmethod
    def from_equacio_implicita(cls,eq):
        &#34;&#34;&#34;
        Retorna el pla afí que té equació implícita eq
        Paràmetres:
            eq: EquacioLineal
        &#34;&#34;&#34;
        if not isinstance(eq,EquacioLineal):
            return None
        s = eq.to_sistema_equacions()
        s.resol()
        t1, t2 = symbols(&#39;t1 t2&#39;)
        p1 = Punt([v.subs(t1,1).subs(t2,1) for v in s.parametrica])
        p2 = Punt([v.subs(t1,1).subs(t2,0) for v in s.parametrica])
        p3 = Punt([v.subs(t1,0).subs(t2,1) for v in s.parametrica])
        u = p2-p1
        v = p3-p1
        u.simplificar()
        v.simplificar()
        return cls(p1,u,v)
    #
    #
    #
    def __repr__(self):
        &#34;&#34;&#34;
        Retorna l&#39;equació vectorial del pla en LaTeX
        &#34;&#34;&#34;
        q = self.punt_de_coordenades_enteres()
        return f&#34;(x,y,z)={q}+t_1{self.u1}+t_2{self.u2}&#34;
    #
    #
    #
    def equacio_implicita(self,ref=None,prime=0):
        &#34;&#34;&#34;
        Retorna l&#39;expressió de l&#39;equació implícita del pla en la referència &#34;ref&#34;
        Paràmetres:
            ref: referència afí
            prime: nombre de primes que s&#39;escriuran a les incògnites
        &#34;&#34;&#34;
        if ref is None:
            w = self.u1.cross(self.u2)
            return EquacioLineal.coeficients(w,w.dot(self.p),False)
        if not isinstance(ref,ReferenciaAfi):
            return None
        c = self.p.coordenades_en_referencia(ref)
        v1 = self.u1.components_en_base(ref.base)
        v2 = self.u2.components_en_base(ref.base)
        w = v1.cross(v2)
        w.simplificar()
        return EquacioLineal.coeficients(w,w.dot(c),False,prime)
    #
    #
    #
    def base_ortogonal(self):
        &#34;&#34;&#34;
        Retorna una base orogonal (vectors directors perpendiculars) del pla
        &#34;&#34;&#34;
        v1 = self.u1
        u2 = self.u2
        v2 = v1.dot(v1) * u2 - v1.dot(u2) * v1
        v2.simplificar()
        return [v1,v2]
    #
    #
    #
    def associat(self,base=None):
        &#34;&#34;&#34;
        Retorna un vector perpendicular al pla expressat en la base &#34;base&#34;
        Paràmetres:
            base: base de l&#39;espai vectorial. Si és None, serà la canònica
        &#34;&#34;&#34;
        w = self.u1.cross(self.u2,simplificar=True)
        if base is None:
            return w
        return w.components_en_base(base)
    #
    #
    #
    def interseccio(self,other):
        &#34;&#34;&#34;
        Retorna la intersecció del pla amb una altre pla o una recta.
        El resultat pot ser None, una recta o un pla.
        Paràmetes:
          other. PlaAfi o RectaAfi
        &#34;&#34;&#34;
        if isinstance(other,PlaAfi):
            m = Matriu.from_vectors_columna([self.associat(),other.associat()])
            if m.rang() == 1:
                if other.conte(self.p):
                    return self
                return None
            e1 = self.equacio_implicita()
            e2 = other.equacio_implicita()
            s = SistemaEquacions.from_equacions([e1,e2],3)
            return RectaAfi.from_equacions_implicites(s)
        if isinstance(other,RectaAfi):
            return other.interseccio(self)
        return None
    #
    #
    #
    def distancia(self,other):
        &#34;&#34;&#34;
        Retorna la distància entre el pla actual i un punt, una recta o un altre pla
        Paràmetres:
            other: un punt (classe Punt), una recta (classe RectaAfi) o
            un pla (class PlaAfi)
        &#34;&#34;&#34;
        if isinstance(other,Punt):
            v = self.p - other
            w = self.u1.cross(self.u2,simplificar=True)
            return abs(v.dot(w))/w.length()
        if isinstance(other,PlaAfi):
            w1 = self.associat()
            w2 = other.associat()
            w = w1.cross(w2)
            if w.length() == 0:
                return self.distancia(other.p)
            return 0
        if isinstance(other,RectaAfi):
            return other.distancia(self)
        return None
    #
    #
    #
    def projeccio_ortogonal(self,punt):
        &#34;&#34;&#34;
        Retorna la projecció ortogonal del punt &#34;punt&#34; sobre el pla
        Paràmetres:
          punt: Punt
        &#34;&#34;&#34;
        P = PlaVectorial(self.u1,self.u2)
        if not isinstance(punt,Punt):
            return None
        if punt.dimensio != 3:
            return None
        return (self.p + P.projeccio_ortogonal(punt - self.p)).punt()
    #
    #
    #
    def simetric(self,punt):
        &#34;&#34;&#34;
        Retorna el simètric del punt &#34;punt&#34; respecte al pla
        Paràmetres:
          punt: Punt
        &#34;&#34;&#34;
        return 2*self.projeccio_ortogonal(punt) - punt
    #
    #
    #
    def conte(self,punt):
        &#34;&#34;&#34;
        Retorna si el punt &#34;punt&#34; pertany al pla
        Paràmetres:
          punt: Punt
        &#34;&#34;&#34;
        if not isinstance(punt,Punt):
            return None
        if punt.dimensio != self.p.dimensio:
            return None
        m = Matriu.from_vectors_columna([self.u1,self.u2,self.p - punt])
        return m.rang() == 2</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="Algebra.PlaAfi.aleatori"><code class="name flex">
<span>def <span class="ident">aleatori</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def aleatori(cls):
    m = Matriu.amb_rang(f=2,c=3,r=2,maxim=4,mzeros=0)
    v = m.vectors_fila()
    p = Punt.aleatori(l=3,maxim=3,nuls=False)
    return cls(p,v[0],v[1])</code></pre>
</details>
</dd>
<dt id="Algebra.PlaAfi.amb_associat"><code class="name flex">
<span>def <span class="ident">amb_associat</span></span>(<span>w, p)</span>
</code></dt>
<dd>
<div class="desc"><p>Genera el pla afí que té vector perpendicular "w" i passa pel punt p</p>
<h2 id="parametres">Paràmetres</h2>
<p>w: vector associat
p: punt de pas</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def amb_associat(cls,w,p):
    &#34;&#34;&#34;
    Genera el pla afí que té vector perpendicular &#34;w&#34; i passa pel punt p
    Paràmetres:
        w: vector associat
        p: punt de pas
    &#34;&#34;&#34;
    if not isinstance(w,Vector):
        return None
    if not isinstance(p,Punt):
        return None
    a = Matriu.from_vectors_fila([w])
    l = a.nucli()
    return cls(p,l[0],l[1])</code></pre>
</details>
</dd>
<dt id="Algebra.PlaAfi.from_equacio_implicita"><code class="name flex">
<span>def <span class="ident">from_equacio_implicita</span></span>(<span>eq)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el pla afí que té equació implícita eq</p>
<h2 id="parametres">Paràmetres</h2>
<p>eq: EquacioLineal</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_equacio_implicita(cls,eq):
    &#34;&#34;&#34;
    Retorna el pla afí que té equació implícita eq
    Paràmetres:
        eq: EquacioLineal
    &#34;&#34;&#34;
    if not isinstance(eq,EquacioLineal):
        return None
    s = eq.to_sistema_equacions()
    s.resol()
    t1, t2 = symbols(&#39;t1 t2&#39;)
    p1 = Punt([v.subs(t1,1).subs(t2,1) for v in s.parametrica])
    p2 = Punt([v.subs(t1,1).subs(t2,0) for v in s.parametrica])
    p3 = Punt([v.subs(t1,0).subs(t2,1) for v in s.parametrica])
    u = p2-p1
    v = p3-p1
    u.simplificar()
    v.simplificar()
    return cls(p1,u,v)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Algebra.PlaAfi.associat"><code class="name flex">
<span>def <span class="ident">associat</span></span>(<span>self, base=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna un vector perpendicular al pla expressat en la base "base"</p>
<h2 id="parametres">Paràmetres</h2>
<p>base: base de l'espai vectorial. Si és None, serà la canònica</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def associat(self,base=None):
    &#34;&#34;&#34;
    Retorna un vector perpendicular al pla expressat en la base &#34;base&#34;
    Paràmetres:
        base: base de l&#39;espai vectorial. Si és None, serà la canònica
    &#34;&#34;&#34;
    w = self.u1.cross(self.u2,simplificar=True)
    if base is None:
        return w
    return w.components_en_base(base)</code></pre>
</details>
</dd>
<dt id="Algebra.PlaAfi.base_ortogonal"><code class="name flex">
<span>def <span class="ident">base_ortogonal</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna una base orogonal (vectors directors perpendiculars) del pla</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def base_ortogonal(self):
    &#34;&#34;&#34;
    Retorna una base orogonal (vectors directors perpendiculars) del pla
    &#34;&#34;&#34;
    v1 = self.u1
    u2 = self.u2
    v2 = v1.dot(v1) * u2 - v1.dot(u2) * v1
    v2.simplificar()
    return [v1,v2]</code></pre>
</details>
</dd>
<dt id="Algebra.PlaAfi.conte"><code class="name flex">
<span>def <span class="ident">conte</span></span>(<span>self, punt)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna si el punt "punt" pertany al pla</p>
<h2 id="parametres">Paràmetres</h2>
<p>punt: Punt</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conte(self,punt):
    &#34;&#34;&#34;
    Retorna si el punt &#34;punt&#34; pertany al pla
    Paràmetres:
      punt: Punt
    &#34;&#34;&#34;
    if not isinstance(punt,Punt):
        return None
    if punt.dimensio != self.p.dimensio:
        return None
    m = Matriu.from_vectors_columna([self.u1,self.u2,self.p - punt])
    return m.rang() == 2</code></pre>
</details>
</dd>
<dt id="Algebra.PlaAfi.distancia"><code class="name flex">
<span>def <span class="ident">distancia</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la distància entre el pla actual i un punt, una recta o un altre pla</p>
<h2 id="parametres">Paràmetres</h2>
<p>other: un punt (classe Punt), una recta (classe RectaAfi) o
un pla (class PlaAfi)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distancia(self,other):
    &#34;&#34;&#34;
    Retorna la distància entre el pla actual i un punt, una recta o un altre pla
    Paràmetres:
        other: un punt (classe Punt), una recta (classe RectaAfi) o
        un pla (class PlaAfi)
    &#34;&#34;&#34;
    if isinstance(other,Punt):
        v = self.p - other
        w = self.u1.cross(self.u2,simplificar=True)
        return abs(v.dot(w))/w.length()
    if isinstance(other,PlaAfi):
        w1 = self.associat()
        w2 = other.associat()
        w = w1.cross(w2)
        if w.length() == 0:
            return self.distancia(other.p)
        return 0
    if isinstance(other,RectaAfi):
        return other.distancia(self)
    return None</code></pre>
</details>
</dd>
<dt id="Algebra.PlaAfi.equacio_implicita"><code class="name flex">
<span>def <span class="ident">equacio_implicita</span></span>(<span>self, ref=None, prime=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna l'expressió de l'equació implícita del pla en la referència "ref"</p>
<h2 id="parametres">Paràmetres</h2>
<p>ref: referència afí
prime: nombre de primes que s'escriuran a les incògnites</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def equacio_implicita(self,ref=None,prime=0):
    &#34;&#34;&#34;
    Retorna l&#39;expressió de l&#39;equació implícita del pla en la referència &#34;ref&#34;
    Paràmetres:
        ref: referència afí
        prime: nombre de primes que s&#39;escriuran a les incògnites
    &#34;&#34;&#34;
    if ref is None:
        w = self.u1.cross(self.u2)
        return EquacioLineal.coeficients(w,w.dot(self.p),False)
    if not isinstance(ref,ReferenciaAfi):
        return None
    c = self.p.coordenades_en_referencia(ref)
    v1 = self.u1.components_en_base(ref.base)
    v2 = self.u2.components_en_base(ref.base)
    w = v1.cross(v2)
    w.simplificar()
    return EquacioLineal.coeficients(w,w.dot(c),False,prime)</code></pre>
</details>
</dd>
<dt id="Algebra.PlaAfi.interseccio"><code class="name flex">
<span>def <span class="ident">interseccio</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la intersecció del pla amb una altre pla o una recta.
El resultat pot ser None, una recta o un pla.</p>
<h2 id="parametes">Paràmetes</h2>
<p>other. PlaAfi o RectaAfi</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interseccio(self,other):
    &#34;&#34;&#34;
    Retorna la intersecció del pla amb una altre pla o una recta.
    El resultat pot ser None, una recta o un pla.
    Paràmetes:
      other. PlaAfi o RectaAfi
    &#34;&#34;&#34;
    if isinstance(other,PlaAfi):
        m = Matriu.from_vectors_columna([self.associat(),other.associat()])
        if m.rang() == 1:
            if other.conte(self.p):
                return self
            return None
        e1 = self.equacio_implicita()
        e2 = other.equacio_implicita()
        s = SistemaEquacions.from_equacions([e1,e2],3)
        return RectaAfi.from_equacions_implicites(s)
    if isinstance(other,RectaAfi):
        return other.interseccio(self)
    return None</code></pre>
</details>
</dd>
<dt id="Algebra.PlaAfi.projeccio_ortogonal"><code class="name flex">
<span>def <span class="ident">projeccio_ortogonal</span></span>(<span>self, punt)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la projecció ortogonal del punt "punt" sobre el pla</p>
<h2 id="parametres">Paràmetres</h2>
<p>punt: Punt</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def projeccio_ortogonal(self,punt):
    &#34;&#34;&#34;
    Retorna la projecció ortogonal del punt &#34;punt&#34; sobre el pla
    Paràmetres:
      punt: Punt
    &#34;&#34;&#34;
    P = PlaVectorial(self.u1,self.u2)
    if not isinstance(punt,Punt):
        return None
    if punt.dimensio != 3:
        return None
    return (self.p + P.projeccio_ortogonal(punt - self.p)).punt()</code></pre>
</details>
</dd>
<dt id="Algebra.PlaAfi.punt_de_coordenades_enteres"><code class="name flex">
<span>def <span class="ident">punt_de_coordenades_enteres</span></span>(<span>self, p=None, u=None, v=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna, si és possible, un punt de coordenades enteres del pla afí
que passa pel punt p i té vectors directors u i v</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def punt_de_coordenades_enteres(self,p=None,u=None,v=None):
    &#34;&#34;&#34;
    Retorna, si és possible, un punt de coordenades enteres del pla afí
    que passa pel punt p i té vectors directors u i v
    &#34;&#34;&#34;
    if p is None:
        p = self.p
    if u is None:
        u = self.u1
    if v is None:
        v = self.u2
    if p.tots_enters():
        return p
    t, _ = p.factor_comu()
    if isinstance(t,int) or isinstance(t,Integer):
        return p
    for i in range(1,t.q):
        for j in range(1,t.q):
            r = (p + Rational(i,t.q) * u + Rational(j,t.q) * v).punt()
            if r.tots_enters():
                return r
            r = (p + Rational(i,t.q) * u - Rational(j,t.q) * v).punt()
            if r.tots_enters():
                return r
            r = (p - Rational(i,t.q) * u + Rational(j,t.q) * v).punt()
            if r.tots_enters():
                return r
            r = (p - Rational(i,t.q) * u - Rational(j,t.q) * v).punt()
            if r.tots_enters():
                return r
    return p</code></pre>
</details>
</dd>
<dt id="Algebra.PlaAfi.simetric"><code class="name flex">
<span>def <span class="ident">simetric</span></span>(<span>self, punt)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el simètric del punt "punt" respecte al pla</p>
<h2 id="parametres">Paràmetres</h2>
<p>punt: Punt</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simetric(self,punt):
    &#34;&#34;&#34;
    Retorna el simètric del punt &#34;punt&#34; respecte al pla
    Paràmetres:
      punt: Punt
    &#34;&#34;&#34;
    return 2*self.projeccio_ortogonal(punt) - punt</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Algebra.PlaVectorial"><code class="flex name class">
<span>class <span class="ident">PlaVectorial</span></span>
<span>(</span><span>u1, u2)</span>
</code></dt>
<dd>
<div class="desc"><p>Classe per treballar amb plans vectorials</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PlaVectorial(object):
    &#34;&#34;&#34;
    Classe per treballar amb plans vectorials
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,u1,u2):
        &#34;&#34;&#34;
        Constructor.
        Paràmetres:
            u1, u2: generadors del pla
        &#34;&#34;&#34;
        if not isinstance(u1,Vector):
            return None
        if not isinstance(u2,Vector):
            return None
        if u1.dimensio != 3 or u2.dimensio != 3:
            return None
        m = Matriu.from_vectors_columna([u1,u2])
        if m.rank() != 2:
            return None
        return super(PlaVectorial,cls).__new__(cls)
    #
    #
    #
    def __init__(self,u1,u2):
        self.u1 = u1
        self.u2 = u2
    #
    #
    #
    def __repr__(self):
        &#34;&#34;&#34;
        Retorna l&#39;expressió en LaTeX dels dos vectors generadors
        &#34;&#34;&#34;
        return f&#34;{self.u1}, {self.u2}&#34;
    #
    #
    #
    def equacio_implicita(self,base=None,prime=0):
        &#34;&#34;&#34;
        Retorna l&#39;equació implícita del pla en la base &#34;base&#34; en format LaTeX.
        Normalment, si la base no és la canònica es posa prime &gt; 0 perquè el resultat
        sigui de l&#39;estil 2x&#39;-3y&#39;+4z&#39;= 0
        Paràmetres:
            base: una base (classe Base). Si és None, serà la canònica
            prime: nombre de primes que s&#39;escriuran a les incògnites
        &#34;&#34;&#34;
        if base is None:
            w = self.u1.cross(self.u2)
            return EquacioLineal.coeficients(w,0,False)
        if not isinstance(base,Base):
            return None
        v1 = self.u1.components_en_base(base)
        v2 = self.u2.components_en_base(base)
        w = v1.cross(v2)
        return EquacioLineal.coeficients(w,0,False,prime)
    #
    #
    #
    @classmethod
    def from_matriu(cls,m):
        &#34;&#34;&#34;
        Crea el pla vectorial generat per les columnes de la matriu &#34;m&#34;
        Paràmetres:
            m: matriu. Ha de tenir 3 files, dues columnes i rang 2
        &#34;&#34;&#34;
        if not isinstance(m,Matriu):
            return None
        if m.files != 3 or m.columnes != 2 or m.rank() != 2:
            return None
        v = m.vectors_columna()
        return cls(v[0],v[1])
    #
    #
    #
    @classmethod
    def amb_associat(cls,w):
        &#34;&#34;&#34;
        Genera el pla vectorial que té vector perpendicular &#34;w&#34;
        Paràmetres:
            v: vector no nul de dimensió 3
        &#34;&#34;&#34;
        if not isinstance(w,Vector):
            return None
        if w.dimensio != 3:
            return None
        if w.length() == 0:
            return None
        a = Matriu.from_vectors_fila([w])
        l = a.nucli()
        return cls(l[0],l[1])
    #
    #
    #
    def base_ortogonal(self):
        &#34;&#34;&#34;
        Retorna una base ortogonal del pla vectorial
        &#34;&#34;&#34;
        v1 = self.u1
        u2 = self.u2
        v2 = v1.dot(v1) * u2 - v1.dot(u2) * v1
        v2.simplificar()
        return Base([v1,v2])
    #
    #
    #
    def projeccio_ortogonal(self,u):
        &#34;&#34;&#34;
        Retorna la projecció ortogonal del vector u sobre el pla.
        Paràmetres:
          u: Vector
        &#34;&#34;&#34;
        if not isinstance(u,Vector):
            return None
        if u.dimensio != 3:
            return None
        b = self.base_ortogonal()
        v1, v2 = b.vecs
        t1 = Rational(u.dot(v1),v1.dot(v1))
        t2 = Rational(u.dot(v2),v2.dot(v2))
        return t1 * v1 + t2 * v2
    #
    #
    #
    def simetric(self,u):
        &#34;&#34;&#34;
        Retorna el simètric del vector u respecte al pla.
        Paràmetres:
          u: Vector
        &#34;&#34;&#34;
        if not isinstance(u,Vector):
            return None
        if u.dimensio != 3:
            return None
        return 2*self.projeccio_ortogonal(u) - u
    #
    #
    #
    def conte(self,u):
        &#34;&#34;&#34;
        Retorna si el vector u pertany al pla.
        Paràmetres:
          u: Vector
        &#34;&#34;&#34;
        if not isinstance(u,Vector):
            return None
        if u.dimensio != 3:
            return None
        m = Matriu.from_vectors_columna([self.u1,self.u2,u])
        return m.det() == 0
    #
    #
    #
    def es_associat(self,u):
        &#34;&#34;&#34;
        Retorna si el vector és perpendicular al pla.
        Paràmetres:
          u: Vector
        &#34;&#34;&#34;
        if not isinstance(u,Vector):
            return None
        if u.dimensio != 3:
            return None
        if u.length() == 0:
            return False
        w = self.u1.cross(self.u2)
        m = Matriu.from_vectors_columna([w,u])
        return m.rang() == 1
    #
    #
    #
    def ortogonal(self):
        &#34;&#34;&#34;
        Retorna el suplementari ortogonal
        &#34;&#34;&#34;
        a = Matriu.from_vectors_fila([self.u1,self.u2])
        return RectaVectorial(a.nucli()[0])
    #
    #
    #
    def associat(self,base=None):
        &#34;&#34;&#34;
        Retorna les components del vector associat en la base &#34;base&#34;
        Paràmetres:
            base: element de la clase Base
        &#34;&#34;&#34;
        w = self.u1.cross(self.u2)
        w.simplificar()
        if base is None:
            return w
        if not isinstance(base,Base):
            return None
        w = base.components_del_vector(w)
        w.simplificar()
        return w</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="Algebra.PlaVectorial.amb_associat"><code class="name flex">
<span>def <span class="ident">amb_associat</span></span>(<span>w)</span>
</code></dt>
<dd>
<div class="desc"><p>Genera el pla vectorial que té vector perpendicular "w"</p>
<h2 id="parametres">Paràmetres</h2>
<p>v: vector no nul de dimensió 3</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def amb_associat(cls,w):
    &#34;&#34;&#34;
    Genera el pla vectorial que té vector perpendicular &#34;w&#34;
    Paràmetres:
        v: vector no nul de dimensió 3
    &#34;&#34;&#34;
    if not isinstance(w,Vector):
        return None
    if w.dimensio != 3:
        return None
    if w.length() == 0:
        return None
    a = Matriu.from_vectors_fila([w])
    l = a.nucli()
    return cls(l[0],l[1])</code></pre>
</details>
</dd>
<dt id="Algebra.PlaVectorial.from_matriu"><code class="name flex">
<span>def <span class="ident">from_matriu</span></span>(<span>m)</span>
</code></dt>
<dd>
<div class="desc"><p>Crea el pla vectorial generat per les columnes de la matriu "m"</p>
<h2 id="parametres">Paràmetres</h2>
<p>m: matriu. Ha de tenir 3 files, dues columnes i rang 2</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_matriu(cls,m):
    &#34;&#34;&#34;
    Crea el pla vectorial generat per les columnes de la matriu &#34;m&#34;
    Paràmetres:
        m: matriu. Ha de tenir 3 files, dues columnes i rang 2
    &#34;&#34;&#34;
    if not isinstance(m,Matriu):
        return None
    if m.files != 3 or m.columnes != 2 or m.rank() != 2:
        return None
    v = m.vectors_columna()
    return cls(v[0],v[1])</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Algebra.PlaVectorial.associat"><code class="name flex">
<span>def <span class="ident">associat</span></span>(<span>self, base=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna les components del vector associat en la base "base"</p>
<h2 id="parametres">Paràmetres</h2>
<p>base: element de la clase Base</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def associat(self,base=None):
    &#34;&#34;&#34;
    Retorna les components del vector associat en la base &#34;base&#34;
    Paràmetres:
        base: element de la clase Base
    &#34;&#34;&#34;
    w = self.u1.cross(self.u2)
    w.simplificar()
    if base is None:
        return w
    if not isinstance(base,Base):
        return None
    w = base.components_del_vector(w)
    w.simplificar()
    return w</code></pre>
</details>
</dd>
<dt id="Algebra.PlaVectorial.base_ortogonal"><code class="name flex">
<span>def <span class="ident">base_ortogonal</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna una base ortogonal del pla vectorial</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def base_ortogonal(self):
    &#34;&#34;&#34;
    Retorna una base ortogonal del pla vectorial
    &#34;&#34;&#34;
    v1 = self.u1
    u2 = self.u2
    v2 = v1.dot(v1) * u2 - v1.dot(u2) * v1
    v2.simplificar()
    return Base([v1,v2])</code></pre>
</details>
</dd>
<dt id="Algebra.PlaVectorial.conte"><code class="name flex">
<span>def <span class="ident">conte</span></span>(<span>self, u)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna si el vector u pertany al pla.</p>
<h2 id="parametres">Paràmetres</h2>
<p>u: Vector</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conte(self,u):
    &#34;&#34;&#34;
    Retorna si el vector u pertany al pla.
    Paràmetres:
      u: Vector
    &#34;&#34;&#34;
    if not isinstance(u,Vector):
        return None
    if u.dimensio != 3:
        return None
    m = Matriu.from_vectors_columna([self.u1,self.u2,u])
    return m.det() == 0</code></pre>
</details>
</dd>
<dt id="Algebra.PlaVectorial.equacio_implicita"><code class="name flex">
<span>def <span class="ident">equacio_implicita</span></span>(<span>self, base=None, prime=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna l'equació implícita del pla en la base "base" en format LaTeX.
Normalment, si la base no és la canònica es posa prime &gt; 0 perquè el resultat
sigui de l'estil 2x'-3y'+4z'= 0</p>
<h2 id="parametres">Paràmetres</h2>
<p>base: una base (classe Base). Si és None, serà la canònica
prime: nombre de primes que s'escriuran a les incògnites</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def equacio_implicita(self,base=None,prime=0):
    &#34;&#34;&#34;
    Retorna l&#39;equació implícita del pla en la base &#34;base&#34; en format LaTeX.
    Normalment, si la base no és la canònica es posa prime &gt; 0 perquè el resultat
    sigui de l&#39;estil 2x&#39;-3y&#39;+4z&#39;= 0
    Paràmetres:
        base: una base (classe Base). Si és None, serà la canònica
        prime: nombre de primes que s&#39;escriuran a les incògnites
    &#34;&#34;&#34;
    if base is None:
        w = self.u1.cross(self.u2)
        return EquacioLineal.coeficients(w,0,False)
    if not isinstance(base,Base):
        return None
    v1 = self.u1.components_en_base(base)
    v2 = self.u2.components_en_base(base)
    w = v1.cross(v2)
    return EquacioLineal.coeficients(w,0,False,prime)</code></pre>
</details>
</dd>
<dt id="Algebra.PlaVectorial.es_associat"><code class="name flex">
<span>def <span class="ident">es_associat</span></span>(<span>self, u)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna si el vector és perpendicular al pla.</p>
<h2 id="parametres">Paràmetres</h2>
<p>u: Vector</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def es_associat(self,u):
    &#34;&#34;&#34;
    Retorna si el vector és perpendicular al pla.
    Paràmetres:
      u: Vector
    &#34;&#34;&#34;
    if not isinstance(u,Vector):
        return None
    if u.dimensio != 3:
        return None
    if u.length() == 0:
        return False
    w = self.u1.cross(self.u2)
    m = Matriu.from_vectors_columna([w,u])
    return m.rang() == 1</code></pre>
</details>
</dd>
<dt id="Algebra.PlaVectorial.ortogonal"><code class="name flex">
<span>def <span class="ident">ortogonal</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el suplementari ortogonal</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ortogonal(self):
    &#34;&#34;&#34;
    Retorna el suplementari ortogonal
    &#34;&#34;&#34;
    a = Matriu.from_vectors_fila([self.u1,self.u2])
    return RectaVectorial(a.nucli()[0])</code></pre>
</details>
</dd>
<dt id="Algebra.PlaVectorial.projeccio_ortogonal"><code class="name flex">
<span>def <span class="ident">projeccio_ortogonal</span></span>(<span>self, u)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la projecció ortogonal del vector u sobre el pla.</p>
<h2 id="parametres">Paràmetres</h2>
<p>u: Vector</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def projeccio_ortogonal(self,u):
    &#34;&#34;&#34;
    Retorna la projecció ortogonal del vector u sobre el pla.
    Paràmetres:
      u: Vector
    &#34;&#34;&#34;
    if not isinstance(u,Vector):
        return None
    if u.dimensio != 3:
        return None
    b = self.base_ortogonal()
    v1, v2 = b.vecs
    t1 = Rational(u.dot(v1),v1.dot(v1))
    t2 = Rational(u.dot(v2),v2.dot(v2))
    return t1 * v1 + t2 * v2</code></pre>
</details>
</dd>
<dt id="Algebra.PlaVectorial.simetric"><code class="name flex">
<span>def <span class="ident">simetric</span></span>(<span>self, u)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el simètric del vector u respecte al pla.</p>
<h2 id="parametres">Paràmetres</h2>
<p>u: Vector</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simetric(self,u):
    &#34;&#34;&#34;
    Retorna el simètric del vector u respecte al pla.
    Paràmetres:
      u: Vector
    &#34;&#34;&#34;
    if not isinstance(u,Vector):
        return None
    if u.dimensio != 3:
        return None
    return 2*self.projeccio_ortogonal(u) - u</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Algebra.Punt"><code class="flex name class">
<span>class <span class="ident">Punt</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><p>Classe per treballar amb punts.
Internament un punt és el mateix que un vector</p>
<p>Constructor.</p>
<h2 id="parametres">Paràmetres</h2>
<p>c: Una única llista de nombres o una llista de paràmetres
que han de ser nombres</p>
<h2 id="exemples">Exemples</h2>
<p>u = Vector([2,3,1,2])
v = Vector(3,1,-2)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Punt(Vector):
    &#34;&#34;&#34;
    Classe per treballar amb punts.
    Internament un punt és el mateix que un vector
    &#34;&#34;&#34;
    def __new__(cls,*args):
        &#34;&#34;&#34;
        Constructor.
        Paràmetres:
           c: Llista de nombres
        &#34;&#34;&#34;
        if len(args) == 0:
            return None
        if len(args) == 1:
            if isinstance(args[0],list) or isinstance(args[0],tuple):
                return super(Vector,cls).__new__(cls)
        else:
            for k in args:
                if isinstance(k,list) or isinstance(k,tuple):
                    return None
            return super(Vector,cls).__new__(cls)
        return None
    #
    #
    #
    def __init__(self,*args):
        Vector.__init__(self,*args)
    #
    #
    #
    def coordenades_en_referencia(self,ref):
        &#34;&#34;&#34;
        Retorna les coordenades del punt en la referència &#34;ref&#34;
        Paràmetres:
            ref: referència de la classe ReferenciaAfi
        &#34;&#34;&#34;
        if not isinstance(ref,ReferenciaAfi):
            return None
        if self.dimensio != ref.dimensio:
            return None
        op = self - ref.origen
        return Punt(op.components_en_base(ref.base).components)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Algebra.Vector" href="#Algebra.Vector">Vector</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="Algebra.Punt.coordenades_en_referencia"><code class="name flex">
<span>def <span class="ident">coordenades_en_referencia</span></span>(<span>self, ref)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna les coordenades del punt en la referència "ref"</p>
<h2 id="parametres">Paràmetres</h2>
<p>ref: referència de la classe ReferenciaAfi</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coordenades_en_referencia(self,ref):
    &#34;&#34;&#34;
    Retorna les coordenades del punt en la referència &#34;ref&#34;
    Paràmetres:
        ref: referència de la classe ReferenciaAfi
    &#34;&#34;&#34;
    if not isinstance(ref,ReferenciaAfi):
        return None
    if self.dimensio != ref.dimensio:
        return None
    op = self - ref.origen
    return Punt(op.components_en_base(ref.base).components)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Algebra.Vector" href="#Algebra.Vector">Vector</a></b></code>:
<ul class="hlist">
<li><code><a title="Algebra.Vector.aleatori" href="#Algebra.Vector.aleatori">aleatori</a></code></li>
<li><code><a title="Algebra.Vector.as_quaternio" href="#Algebra.Vector.as_quaternio">as_quaternio</a></code></li>
<li><code><a title="Algebra.Vector.clona" href="#Algebra.Vector.clona">clona</a></code></li>
<li><code><a title="Algebra.Vector.components_en_base" href="#Algebra.Vector.components_en_base">components_en_base</a></code></li>
<li><code><a title="Algebra.Vector.cross" href="#Algebra.Vector.cross">cross</a></code></li>
<li><code><a title="Algebra.Vector.diff" href="#Algebra.Vector.diff">diff</a></code></li>
<li><code><a title="Algebra.Vector.dot" href="#Algebra.Vector.dot">dot</a></code></li>
<li><code><a title="Algebra.Vector.es_proporcional" href="#Algebra.Vector.es_proporcional">es_proporcional</a></code></li>
<li><code><a title="Algebra.Vector.factor_comu" href="#Algebra.Vector.factor_comu">factor_comu</a></code></li>
<li><code><a title="Algebra.Vector.latex" href="#Algebra.Vector.latex">latex</a></code></li>
<li><code><a title="Algebra.Vector.length" href="#Algebra.Vector.length">length</a></code></li>
<li><code><a title="Algebra.Vector.maxim" href="#Algebra.Vector.maxim">maxim</a></code></li>
<li><code><a title="Algebra.Vector.normalitzar" href="#Algebra.Vector.normalitzar">normalitzar</a></code></li>
<li><code><a title="Algebra.Vector.normalitzat" href="#Algebra.Vector.normalitzat">normalitzat</a></code></li>
<li><code><a title="Algebra.Vector.nul" href="#Algebra.Vector.nul">nul</a></code></li>
<li><code><a title="Algebra.Vector.nzeros" href="#Algebra.Vector.nzeros">nzeros</a></code></li>
<li><code><a title="Algebra.Vector.perpendicular" href="#Algebra.Vector.perpendicular">perpendicular</a></code></li>
<li><code><a title="Algebra.Vector.punt" href="#Algebra.Vector.punt">punt</a></code></li>
<li><code><a title="Algebra.Vector.radsimplificar" href="#Algebra.Vector.radsimplificar">radsimplificar</a></code></li>
<li><code><a title="Algebra.Vector.reordena_aleatoriament" href="#Algebra.Vector.reordena_aleatoriament">reordena_aleatoriament</a></code></li>
<li><code><a title="Algebra.Vector.set_big" href="#Algebra.Vector.set_big">set_big</a></code></li>
<li><code><a title="Algebra.Vector.simplificar" href="#Algebra.Vector.simplificar">simplificar</a></code></li>
<li><code><a title="Algebra.Vector.subs" href="#Algebra.Vector.subs">subs</a></code></li>
<li><code><a title="Algebra.Vector.tots_enters" href="#Algebra.Vector.tots_enters">tots_enters</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Algebra.Quadrica"><code class="flex name class">
<span>class <span class="ident">Quadrica</span></span>
<span>(</span><span>matriu, ref=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Classe per treballar amb quàdriques. L'objectiu no és classificar quàdriques,
sinó generar-les a partir dels elements característics o de manera
aleatòria.</p>
<h2 id="atributs">Atributs</h2>
<p>ref: Referència afí
matriu: matriu projectiva de la quàdrica en la referència "ref"
canonica: matriu projectiva de la quàdrica en la referència canònica</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Quadrica(object):
    &#34;&#34;&#34;
    Classe per treballar amb quàdriques. L&#39;objectiu no és classificar quàdriques,
    sinó generar-les a partir dels elements característics o de manera
    aleatòria.
    Atributs:
        ref: Referència afí
        matriu: matriu projectiva de la quàdrica en la referència &#34;ref&#34;
        canonica: matriu projectiva de la quàdrica en la referència canònica
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,matriu,ref=None):
        &#34;&#34;&#34;
        Retorna una nova quàdrica
        Paràmetres:
            matriu: matriu projectiva de la quàdrica en la referència &#34;ref&#34;
            Ha de ser 4x4
            ref: referència afí. Si és None, serà la referència canònica
        &#34;&#34;&#34;
        if not isinstance(matriu,Matriu):
            return None
        if matriu.files != matriu.columnes:
            return None
        if matriu.files != 4:
            return None
        if not matriu.es_simetrica():
            return None
        if ref is not None:
            if ref.dimensio != 3:
                return None
            if not ref.base.es_unitaria():
                return None
            if not ref.base.es_ortogonal():
                return None
        return super(Quadrica,cls).__new__(cls)
    #
    #
    #
    def __init__(self,matriu,ref=None):
        self.ref = ref
        self.matriu = matriu
        if ref is None:
            self.canonica = matriu
        else:
            a = ref.base.matriu()
            a = a.inserta_columna(3,ref.origen)
            a = a.inserta_fila(3,Vector([0,0,0,1]))
            b = a.inversa()
            self.canonica = b.transposada() * self.matriu * b
        self.canonica.simplificar()
    #
    #
    #
    def __repr__(self):
        &#34;&#34;&#34;
        Retorna l&#39;equació en latex de l&#39;equació de la quàdrica en la referència
        canònica en LaTeX
        &#34;&#34;&#34;
        x, y, z = symbols(&#39;x y z&#39;)
        m = Matriu.matriu_columna(Vector([x,y,z,1]))
        r = m.transposada() * self.canonica * m
        r.simplificar()
        return mylatex(r[0,0].expand()) + &#34; = 0&#34;
    #
    #
    #
    def equacio(self):
        &#34;&#34;&#34;
        Retorna l&#39;equació en latex de l&#39;equació de la quàdrica
        &#34;&#34;&#34;
        x, y, z = symbols(&#39;x y z&#39;)
        m = Matriu.matriu_columna(Vector([x,y,z,1]))
        r = m.transposada() * self.canonica * m
        r.simplificar()
        return r[0,0].expand()
    #
    #
    #
    @classmethod
    def ellipsoide(cls,maxim=30,diagonal=15,canonica=False):
        &#34;&#34;&#34;
        Retorna un el·lipsoide de manera aleatòria
        Paràmetres:
            maxim: valor màxim de la matriu projectiva de la quàdrica
            diagonal: valor màxim de la diagonal de la matriu projectiva de la quàdrica
            canonica: si és True, els eixos principals seran paral·lels
                      als de la referència canònica
        &#34;&#34;&#34;
        trobat = False
        while not trobat:
            e = Ellipsoide.aleatoria(canonica=canonica)
            if canonica:
                trobat = True
            else:
                trobat = e.canonica.norma_maxim() &lt;= maxim and e.canonica.nzeros() &lt; 3 and e.canonica.max_diagonal() &lt; diagonal
        return e
    #
    #
    #
    @classmethod
    def hiperboloideunafulla(cls,maxim=30,diagonal=15,canonica=False):
        &#34;&#34;&#34;
        Retorna un hiperboloide d&#39;una fulla de manera aleatòria
        Paràmetres:
            maxim: valor màxim de la matriu projectiva de la quàdrica
            diagonal: valor màxim de la diagonal de la matriu projectiva de la quàdrica
            canonica: si és True, els eixos principals seran paral·lels
                      als de la referència canònica
        &#34;&#34;&#34;
        trobat = False
        while not trobat:
            h = HiperboloideUnaFulla.aleatoria(canonica=canonica)
            if canonica:
                trobat = True
            else:
                trobat = h.canonica.norma_maxim() &lt;= maxim and h.canonica.nzeros() &lt; 3 and h.canonica.max_diagonal() &lt; diagonal
        return h
    #
    #
    #
    @classmethod
    def hiperboloideduesfulles(cls,maxim=30,diagonal=15,canonica=False):
        &#34;&#34;&#34;
        Retorna un hiperboloide de dues fulles de manera aleatòria
        Paràmetres:
            maxim: valor màxim de la matriu projectiva de la quàdrica
            diagonal: valor màxim de la diagonal de la matriu projectiva de la quàdrica
            canonica: si és True, els eixos principals seran paral·lels
                      als de la referència canònica
        &#34;&#34;&#34;
        trobat = False
        while not trobat:
            h = HiperboloideDuesFulles.aleatoria(canonica=canonica)
            if canonica:
                trobat = True
            else:
                trobat = h.canonica.norma_maxim() &lt;= maxim and h.canonica.nzeros() &lt; 3 and h.canonica.max_diagonal() &lt; diagonal
        return h
    #
    #
    #
    @classmethod
    def con(cls,maxim=30,diagonal=15,canonica=False):
        &#34;&#34;&#34;
        Retorna un con de manera aleatòria
        Paràmetres:
            maxim: valor màxim de la matriu projectiva de la quàdrica
            diagonal: valor màxim de la diagonal de la matriu projectiva de la quàdrica
            canonica: si és True, els eixos principals seran paral·lels
                      als de la referència canònica
        &#34;&#34;&#34;
        trobat = False
        while not trobat:
            c = Con.aleatoria(canonica=canonica)
            if canonica:
                trobat = True
            else:
                trobat = c.canonica.norma_maxim() &lt;= maxim and c.canonica.nzeros() &lt; 3 and c.canonica.max_diagonal() &lt; diagonal
        return c
    #
    #
    #
    @classmethod
    def cilindreelliptic(cls,maxim=30,diagonal=15,canonica=False):
        &#34;&#34;&#34;
        Retorna un cilindre el·líptic de manera aleatòria
        Paràmetres:
            maxim: valor màxim de la matriu projectiva de la quàdrica
            diagonal: valor màxim de la diagonal de la matriu projectiva de la quàdrica
            canonica: si és True, els eixos principals seran paral·lels
                      als de la referència canònica
          &#34;&#34;&#34;
        trobat = False
        while not trobat:
            c = CilindreElliptic.aleatoria(canonica=canonica)
            if canonica:
                trobat = True
            else:
                trobat = c.canonica.norma_maxim() &lt;= maxim and c.canonica.nzeros() &lt; 3 and c.canonica.max_diagonal() &lt; diagonal
        return c
    #
    #
    #
    @classmethod
    def cilindrehiperbolic(cls,maxim=30,diagonal=15,canonica=False):
        &#34;&#34;&#34;
        Retorna un cilindre hiperbòlic de manera aleatòria
        Paràmetres:
            maxim: valor màxim de la matriu projectiva de la quàdrica
            diagonal: valor màxim de la diagonal de la matriu projectiva de la quàdrica
            canonica: si és True, els eixos principals seran paral·lels
                      als de la referència canònica
        &#34;&#34;&#34;
        trobat = False
        while not trobat:
            c = CilindreHiperbolic.aleatoria(canonica=canonica)
            if canonica:
                trobat = True
            else:
                trobat = c.canonica.norma_maxim() &lt;= maxim and c.canonica.nzeros() &lt; 3 and c.canonica.max_diagonal() &lt; diagonal
        return c
    #
    #
    #
    @classmethod
    def paraboloideelliptic(cls,maxim=30,diagonal=15,canonica=False):
        &#34;&#34;&#34;
        Retorna un paraboloide el·líptic de manera aleatòria
        Paràmetres:
            maxim: valor màxim de la matriu projectiva de la quàdrica
            diagonal: valor màxim de la diagonal de la matriu projectiva de la quàdrica
            canonica: si és True, els eixos principals seran paral·lels
                      als de la referència canònica
        &#34;&#34;&#34;
        trobat = False
        while not trobat:
            p = ParaboloideElliptic.aleatoria(canonica=canonica)
            if canonica:
                trobat = True
            else:
                trobat = p.canonica.norma_maxim() &lt;= maxim and p.canonica.nzeros() &lt; 3 and p.canonica.max_diagonal() &lt; diagonal
        return p
    #
    #
    #
    @classmethod
    def paraboloidehiperbolic(cls,maxim=30,diagonal=15,canonica=False):
        &#34;&#34;&#34;
        Retorna un paraboloide hiperbòlic de manera aleatòria
        Paràmetres:
            maxim: valor màxim de la matriu projectiva de la quàdrica
            diagonal: valor màxim de la diagonal de la matriu projectiva de la quàdrica
            canonica: si és True, els eixos principals seran paral·lels
                      als de la referència canònica
        &#34;&#34;&#34;
        trobat = False
        while not trobat:
            p = ParaboloideHiperbolic.aleatoria(canonica=canonica)
            if canonica:
                trobat = True
            else:
                trobat = p.canonica.norma_maxim() &lt;= maxim and p.canonica.nzeros() &lt; 3 and p.canonica.max_diagonal() &lt; diagonal
        return p
    #
    #
    #
    @classmethod
    def cilindreparabolic(cls,maxim=30,diagonal=15,canonica=False):
        &#34;&#34;&#34;
        Retorna un cilindre parabòlic de manera aleatòria
        Paràmetres:
            maxim: valor màxim de la matriu projectiva de la quàdrica
            diagonal: valor màxim de la diagonal de la matriu projectiva de la quàdrica
            canonica: si és True, els eixos principals seran paral·lels
                      als de la referència canònica
        &#34;&#34;&#34;
        trobat = False
        while not trobat:
            c = CilindreParabolic.aleatoria(canonica=canonica)
            if canonica:
                trobat = True
            else:
                trobat = c.canonica.norma_maxim() &lt;= maxim and c.canonica.nzeros() &lt; 3 and c.canonica.max_diagonal() &lt; diagonal
        return c
    #
    #
    #
    @classmethod
    def aleatoria(cls,maxim=30,diagonal=15,canonica=False):
        &#34;&#34;&#34;
        Retorna una quàdrica de manera aleatòria
        Paràmetres:
            maxim: valor màxim de la matriu projectiva de la quàdrica
            diagonal: valor màxim de la diagonal de la matriu projectiva de la quàdrica
        &#34;&#34;&#34;
        r = random.randint(0,9)
        if r == 0:
            return Quadrica.ellipsoide(maxim,diagonal,canonica)
        if r == 1:
            return Quadrica.hiperboloideunafulla(maxim,diagonal,canonica)
        if r == 2:
            return Quadrica.hiperboloideduesfulles(maxim,diagonal,canonica)
        if r == 3:
            return Quadrica.con(maxim,diagonal,canonica)
        if r == 4:
            return Quadrica.cilindreelliptic(maxim,diagonal,canonica)
        if r == 5:
            return Quadrica.cilindrehiperbolic(maxim,diagonal,canonica)
        if r == 6:
            return Quadrica.paraboloideelliptic(maxim,diagonal,canonica)
        if r == 7:
            return Quadrica.paraboloidehiperbolic(maxim,diagonal,canonica)
        return Quadrica.cilindreparabolic(maxim,diagonal,canonica)
    #
    #
    #
    def tipus(self):
        &#34;&#34;&#34;
        Retorna el tipus de quàdrica
        &#34;&#34;&#34;
        if isinstance(self,Ellipsoide):
            return &#34;El·lipsoide&#34;
        if isinstance(self,HiperboloideUnaFulla):
            return &#34;Hiperboloide d&#39;una fulla&#34;
        if isinstance(self,HiperboloideDuesFulles):
            return &#34;Hiperboloide de dues fulles&#34;
        if isinstance(self,Con):
            return &#34;Con real&#34;
        if isinstance(self,CilindreElliptic):
            return &#34;Cilindre el·líptic&#34;
        if isinstance(self,CilindreHiperbolic):
            return &#34;Cilindre hiperbòlic&#34;
        if isinstance(self,ParaboloideElliptic):
            return &#34;Paraboloide el·líptic&#34;
        if isinstance(self,ParaboloideHiperbolic):
            return &#34;Paraboloide hiperbòlic&#34;
        if isinstance(self,CilindreParabolic):
            return &#34;Cilindre parabòlic&#34;
        return &#34;&#34;
    #
    #
    #
    def referencia_principal(self):
        &#34;&#34;&#34;
        Retorna la referencia principal
        &#34;&#34;&#34;
        return self.ref
    #
    #
    #
    def vectors(self,unitaris=False):
        &#34;&#34;&#34;
        Retorna els vectors de la base de la referència principal
        Paràmetres:
            unitaris: si és True, els retorna unitaris
        &#34;&#34;&#34;
        return self.ref.vectors(unitaris)
    #
    #
    #
    @classmethod
    def from_equacio(cls,eq):
        &#34;&#34;&#34;
        Retorna i classifica la quadrica a partir de la seva equació.
        Només per als nou tipus de quàdriques definides en aquesta llibreria
        &#34;&#34;&#34;
        x, y, z = symbols(&#39;x y z&#39;)
        unknowns = [x,y,z]
        #
        # Termes quadràtics
        #
        a = diff(eq,x,2) / 2
        b = diff(eq,x,y) / 2
        d = diff(eq,x,z) / 2
        c = diff(eq,y,2) / 2
        e = diff(eq,y,z) / 2
        f = diff(eq,z,2) / 2
        #
        # Termes lineals
        #
        l1 = (diff(eq,x).subs({x:1,y:0,z:0}) - 2 * a) / 2
        l2 = (diff(eq,y).subs({x:0,y:1,z:0}) - 2 * c) / 2
        l3 = (diff(eq,z).subs({x:0,y:0,z:1}) - 2 * f) / 2
        #
        # Terme independent
        #
        ti = eq.subs({x:0,y:0,z:0})
        #
        # Matrius
        #
        Q = Matrix([[a,b,d],[b,c,e],[d,e,f]])
        L = Matrix(3,1,[l1,l2,l3])
        l = Vector(l1,l2,l3)
        #
        # Preparatius
        #
        vs = Q.eigenvects()
        vaps, veps = vaps_veps_amb_signe(vs,1)
        positius = list(zip(vaps,veps))
        vaps, veps = vaps_veps_amb_signe(vs,-1)
        negatius = list(zip(vaps,veps))
        positius.sort(key=lambda item: abs(item[0]))
        negatius.sort(key=lambda item: abs(item[0]))
        s = list(linsolve((Q,-L),*unknowns))
        #
        # Classificació
        #
        if len(positius) == 3 or len(negatius) == 3:
            #
            # Ellipsoide
            #
            s = Punt(list(s[0]))
            tip = eq.subs({x:s[0],y:s[1],z:s[2]})
            if tip == 0:
                return None
            if len(positius) == 3 and tip &gt; 0:
                return None
            if len(negatius) == 3 and tip &lt; 0:
                return None
            v = positius
            if len(v) == 0:
                v = negatius
            a2 = -tip / v[0][0]
            b2 = -tip / v[1][0]
            c2 = -tip / v[2][0]
            return Ellipsoide(a2,b2,c2,s,v[0][1],v[1][1])
        if len(positius) + len(negatius) == 3:
            #
            # Rang 3
            #
            s = Punt(list(s[0]))
            tip = eq.subs({x:s[0],y:s[1],z:s[2]})
            v1 = positius
            v2 = negatius
            signe = 1
            if len(v2) == 2:
                v1, v2 = v2, v1
                signe = -1
            a2 = signe * v1[0][0]
            b2 = signe * v1[1][0]
            c2 = signe * v2[0][0]
            tip *= signe
            if tip == 0:
                #
                # Con
                #
                if a2.is_integer and b2.is_integer and c2.is_integer:
                    g = mcm_llista([a2,b2,c2])
                else:
                    g = a2 * b2 * c2
                a2 = g / a2
                b2 = g / b2
                c2 = g / c2
                return Con(a2,b2,-c2,s,v1[0][1],v1[1][1])
            elif tip &gt; 0:
                #
                # Hiperboloide de dues fulles
                #
                a2 = tip / a2
                b2 = tip / b2
                c2 = tip / c2
                return HiperboloideDuesFulles(a2,b2,-c2,s,v1[0][1],v1[1][1])
            elif tip &lt; 0:
                #
                # Hiperboloide d&#39;una fulla
                #
                a2 = - tip / a2
                b2 = - tip / b2
                c2 = - tip / c2
                return HiperboloideUnaFulla(a2,b2,-c2,s,v1[0][1],v1[1][1])
        if len(positius) + len(negatius) == 2:
            #
            # Rang 2
            #
            if len(s) &gt; 0:
                s = Punt(list(s[0].subs({x:0,y:0,z:0})))
                tip = eq.subs({x:s[0],y:s[1],z:s[2]})
                if len(positius) == 2 or len(negatius) == 2:
                    #
                    # Clindre e·líptic
                    #
                    if tip == 0:
                        return None
                    if len(positius) == 2 and tip &gt; 0:
                        return None
                    if len(negatius) == 2 and tip &lt; 0:
                        return None
                    v = positius
                    if len(v) == 0:
                        v = negatius
                    a2 = -tip / v[0][0]
                    b2 = -tip / v[1][0]
                    return CilindreElliptic(a2,b2,s,v[0][1],v[1][1])
                if len(positius) == 1:
                    #
                    # Clindre hiperbòlic
                    #
                    if tip == 0:
                        return None
                    v1 = positius
                    v2 = negatius
                    a2 = -tip / positius[0][0]
                    b2 = -tip / negatius[0][0]
                    if a2 &lt; 0:
                        a2, b2 = b2, a2
                        v1, v2 = v2, v1
                    return CilindreHiperbolic(a2,-b2,s,v1[0][1],v2[0][1])
            if len(positius) == 2 or len(negatius) == 2:
                #
                # Paraboloide el·líptic
                #
                v = positius
                if len(v) == 0:
                    v = negatius
                v1, v2 = v[0][1],v[1][1]
                v1.simplificar()
                v2.simplificar()
                v3 = v1.cross(v2,simplificar=True)
                ep = v3.dot(l)/v3.length()
                t1, t2 = v[0][0],v[1][0]
                es1 = t1 * v1.dot(Vector(x,y,z)) + v1.dot(l)
                es2 = t2 * v2.dot(Vector(x,y,z)) + v2.dot(l)
                vertex = Punt(solve([es1,es2,eq],x,y,z)[0])
                a2 =  -2 * ep / t1
                b2 =  -2 * ep / t2
                if a2 &lt; 0:
                    a2, b2 = -a2,-b2
                    v2 = -v2
                a2 /= v3.length()
                b2 /= v3.length()
                return ParaboloideElliptic(a2,b2,vertex,v1,v2)
            if len(positius) == 1:
                #
                # Paraboloide hiperbòlic
                #
                v1 = positius
                v2 = negatius
                vec1, vec2 = v1[0][1],v2[0][1]
                vec1.simplificar()
                vec2.simplificar()
                vec3 = vec1.cross(vec2,simplificar=True)
                ep = vec3.dot(l)/vec3.length()
                t1, t2 = v1[0][0],v2[0][0]
                es1 = t1 * vec1.dot(Vector(x,y,z)) + vec1.dot(l)
                es2 = t2 * vec2.dot(Vector(x,y,z)) + vec2.dot(l)
                vertex = Punt(solve([es1,es2,eq],x,y,z)[0])
                a2 =  -2 * ep / t1
                b2 =  -2 * ep / t2
                if a2 &lt; 0:
                    a2, b2 = b2, a2
                    vec1, vec2 = vec2, vec1
                    vec3 *= -1
                a2 /= vec3.length()
                b2 /= vec3.length()
                return ParaboloideHiperbolic(a2,-b2,vertex,vec1,vec2)
        if len(positius) + len(negatius) == 1:
            #
            # Cilindre parabòlic
            #
            if len(s) &gt; 0:
                return None
            v = positius
            if len(v) == 0:
                v = negatius
            t1 = v[0][0]
            v1 = v[0][1]
            v2 = v1.cross(l,simplificar=True)
            v3 = v1.cross(v2,simplificar=True)
            es = t1 * v1.dot(Vector(x,y,z)) + v1.dot(l)
            vertex = solve([es,eq],x,y,z)[0]
            k = 0
            while True:
                v = Punt([item.subs({x:k,y:k,z:k}) for item in vertex])
                f = v.factor_comu()
                if f[0].q == 1:
                    break
                v = Punt([item.subs({x:-k,y:-k,z:-k}) for item in vertex])
                f = v.factor_comu()
                if f[0].q == 1:
                    break
                k += 1
            ep = v3.dot(l)/v3.length()
            a2 =  -2 * ep / t1
            return CilindreParabolic(a2/2,v,v1,v2)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="Algebra.CilindreElliptic" href="#Algebra.CilindreElliptic">CilindreElliptic</a></li>
<li><a title="Algebra.CilindreHiperbolic" href="#Algebra.CilindreHiperbolic">CilindreHiperbolic</a></li>
<li><a title="Algebra.CilindreParabolic" href="#Algebra.CilindreParabolic">CilindreParabolic</a></li>
<li><a title="Algebra.Con" href="#Algebra.Con">Con</a></li>
<li><a title="Algebra.Ellipsoide" href="#Algebra.Ellipsoide">Ellipsoide</a></li>
<li><a title="Algebra.HiperboloideDuesFulles" href="#Algebra.HiperboloideDuesFulles">HiperboloideDuesFulles</a></li>
<li><a title="Algebra.HiperboloideUnaFulla" href="#Algebra.HiperboloideUnaFulla">HiperboloideUnaFulla</a></li>
<li><a title="Algebra.ParaboloideElliptic" href="#Algebra.ParaboloideElliptic">ParaboloideElliptic</a></li>
<li><a title="Algebra.ParaboloideHiperbolic" href="#Algebra.ParaboloideHiperbolic">ParaboloideHiperbolic</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="Algebra.Quadrica.aleatoria"><code class="name flex">
<span>def <span class="ident">aleatoria</span></span>(<span>maxim=30, diagonal=15, canonica=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna una quàdrica de manera aleatòria</p>
<h2 id="parametres">Paràmetres</h2>
<p>maxim: valor màxim de la matriu projectiva de la quàdrica
diagonal: valor màxim de la diagonal de la matriu projectiva de la quàdrica</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def aleatoria(cls,maxim=30,diagonal=15,canonica=False):
    &#34;&#34;&#34;
    Retorna una quàdrica de manera aleatòria
    Paràmetres:
        maxim: valor màxim de la matriu projectiva de la quàdrica
        diagonal: valor màxim de la diagonal de la matriu projectiva de la quàdrica
    &#34;&#34;&#34;
    r = random.randint(0,9)
    if r == 0:
        return Quadrica.ellipsoide(maxim,diagonal,canonica)
    if r == 1:
        return Quadrica.hiperboloideunafulla(maxim,diagonal,canonica)
    if r == 2:
        return Quadrica.hiperboloideduesfulles(maxim,diagonal,canonica)
    if r == 3:
        return Quadrica.con(maxim,diagonal,canonica)
    if r == 4:
        return Quadrica.cilindreelliptic(maxim,diagonal,canonica)
    if r == 5:
        return Quadrica.cilindrehiperbolic(maxim,diagonal,canonica)
    if r == 6:
        return Quadrica.paraboloideelliptic(maxim,diagonal,canonica)
    if r == 7:
        return Quadrica.paraboloidehiperbolic(maxim,diagonal,canonica)
    return Quadrica.cilindreparabolic(maxim,diagonal,canonica)</code></pre>
</details>
</dd>
<dt id="Algebra.Quadrica.cilindreelliptic"><code class="name flex">
<span>def <span class="ident">cilindreelliptic</span></span>(<span>maxim=30, diagonal=15, canonica=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna un cilindre el·líptic de manera aleatòria</p>
<h2 id="parametres">Paràmetres</h2>
<p>maxim: valor màxim de la matriu projectiva de la quàdrica
diagonal: valor màxim de la diagonal de la matriu projectiva de la quàdrica
canonica: si és True, els eixos principals seran paral·lels
als de la referència canònica</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def cilindreelliptic(cls,maxim=30,diagonal=15,canonica=False):
    &#34;&#34;&#34;
    Retorna un cilindre el·líptic de manera aleatòria
    Paràmetres:
        maxim: valor màxim de la matriu projectiva de la quàdrica
        diagonal: valor màxim de la diagonal de la matriu projectiva de la quàdrica
        canonica: si és True, els eixos principals seran paral·lels
                  als de la referència canònica
      &#34;&#34;&#34;
    trobat = False
    while not trobat:
        c = CilindreElliptic.aleatoria(canonica=canonica)
        if canonica:
            trobat = True
        else:
            trobat = c.canonica.norma_maxim() &lt;= maxim and c.canonica.nzeros() &lt; 3 and c.canonica.max_diagonal() &lt; diagonal
    return c</code></pre>
</details>
</dd>
<dt id="Algebra.Quadrica.cilindrehiperbolic"><code class="name flex">
<span>def <span class="ident">cilindrehiperbolic</span></span>(<span>maxim=30, diagonal=15, canonica=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna un cilindre hiperbòlic de manera aleatòria</p>
<h2 id="parametres">Paràmetres</h2>
<p>maxim: valor màxim de la matriu projectiva de la quàdrica
diagonal: valor màxim de la diagonal de la matriu projectiva de la quàdrica
canonica: si és True, els eixos principals seran paral·lels
als de la referència canònica</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def cilindrehiperbolic(cls,maxim=30,diagonal=15,canonica=False):
    &#34;&#34;&#34;
    Retorna un cilindre hiperbòlic de manera aleatòria
    Paràmetres:
        maxim: valor màxim de la matriu projectiva de la quàdrica
        diagonal: valor màxim de la diagonal de la matriu projectiva de la quàdrica
        canonica: si és True, els eixos principals seran paral·lels
                  als de la referència canònica
    &#34;&#34;&#34;
    trobat = False
    while not trobat:
        c = CilindreHiperbolic.aleatoria(canonica=canonica)
        if canonica:
            trobat = True
        else:
            trobat = c.canonica.norma_maxim() &lt;= maxim and c.canonica.nzeros() &lt; 3 and c.canonica.max_diagonal() &lt; diagonal
    return c</code></pre>
</details>
</dd>
<dt id="Algebra.Quadrica.cilindreparabolic"><code class="name flex">
<span>def <span class="ident">cilindreparabolic</span></span>(<span>maxim=30, diagonal=15, canonica=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna un cilindre parabòlic de manera aleatòria</p>
<h2 id="parametres">Paràmetres</h2>
<p>maxim: valor màxim de la matriu projectiva de la quàdrica
diagonal: valor màxim de la diagonal de la matriu projectiva de la quàdrica
canonica: si és True, els eixos principals seran paral·lels
als de la referència canònica</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def cilindreparabolic(cls,maxim=30,diagonal=15,canonica=False):
    &#34;&#34;&#34;
    Retorna un cilindre parabòlic de manera aleatòria
    Paràmetres:
        maxim: valor màxim de la matriu projectiva de la quàdrica
        diagonal: valor màxim de la diagonal de la matriu projectiva de la quàdrica
        canonica: si és True, els eixos principals seran paral·lels
                  als de la referència canònica
    &#34;&#34;&#34;
    trobat = False
    while not trobat:
        c = CilindreParabolic.aleatoria(canonica=canonica)
        if canonica:
            trobat = True
        else:
            trobat = c.canonica.norma_maxim() &lt;= maxim and c.canonica.nzeros() &lt; 3 and c.canonica.max_diagonal() &lt; diagonal
    return c</code></pre>
</details>
</dd>
<dt id="Algebra.Quadrica.con"><code class="name flex">
<span>def <span class="ident">con</span></span>(<span>maxim=30, diagonal=15, canonica=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna un con de manera aleatòria</p>
<h2 id="parametres">Paràmetres</h2>
<p>maxim: valor màxim de la matriu projectiva de la quàdrica
diagonal: valor màxim de la diagonal de la matriu projectiva de la quàdrica
canonica: si és True, els eixos principals seran paral·lels
als de la referència canònica</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def con(cls,maxim=30,diagonal=15,canonica=False):
    &#34;&#34;&#34;
    Retorna un con de manera aleatòria
    Paràmetres:
        maxim: valor màxim de la matriu projectiva de la quàdrica
        diagonal: valor màxim de la diagonal de la matriu projectiva de la quàdrica
        canonica: si és True, els eixos principals seran paral·lels
                  als de la referència canònica
    &#34;&#34;&#34;
    trobat = False
    while not trobat:
        c = Con.aleatoria(canonica=canonica)
        if canonica:
            trobat = True
        else:
            trobat = c.canonica.norma_maxim() &lt;= maxim and c.canonica.nzeros() &lt; 3 and c.canonica.max_diagonal() &lt; diagonal
    return c</code></pre>
</details>
</dd>
<dt id="Algebra.Quadrica.ellipsoide"><code class="name flex">
<span>def <span class="ident">ellipsoide</span></span>(<span>maxim=30, diagonal=15, canonica=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna un el·lipsoide de manera aleatòria</p>
<h2 id="parametres">Paràmetres</h2>
<p>maxim: valor màxim de la matriu projectiva de la quàdrica
diagonal: valor màxim de la diagonal de la matriu projectiva de la quàdrica
canonica: si és True, els eixos principals seran paral·lels
als de la referència canònica</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def ellipsoide(cls,maxim=30,diagonal=15,canonica=False):
    &#34;&#34;&#34;
    Retorna un el·lipsoide de manera aleatòria
    Paràmetres:
        maxim: valor màxim de la matriu projectiva de la quàdrica
        diagonal: valor màxim de la diagonal de la matriu projectiva de la quàdrica
        canonica: si és True, els eixos principals seran paral·lels
                  als de la referència canònica
    &#34;&#34;&#34;
    trobat = False
    while not trobat:
        e = Ellipsoide.aleatoria(canonica=canonica)
        if canonica:
            trobat = True
        else:
            trobat = e.canonica.norma_maxim() &lt;= maxim and e.canonica.nzeros() &lt; 3 and e.canonica.max_diagonal() &lt; diagonal
    return e</code></pre>
</details>
</dd>
<dt id="Algebra.Quadrica.from_equacio"><code class="name flex">
<span>def <span class="ident">from_equacio</span></span>(<span>eq)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna i classifica la quadrica a partir de la seva equació.
Només per als nou tipus de quàdriques definides en aquesta llibreria</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_equacio(cls,eq):
    &#34;&#34;&#34;
    Retorna i classifica la quadrica a partir de la seva equació.
    Només per als nou tipus de quàdriques definides en aquesta llibreria
    &#34;&#34;&#34;
    x, y, z = symbols(&#39;x y z&#39;)
    unknowns = [x,y,z]
    #
    # Termes quadràtics
    #
    a = diff(eq,x,2) / 2
    b = diff(eq,x,y) / 2
    d = diff(eq,x,z) / 2
    c = diff(eq,y,2) / 2
    e = diff(eq,y,z) / 2
    f = diff(eq,z,2) / 2
    #
    # Termes lineals
    #
    l1 = (diff(eq,x).subs({x:1,y:0,z:0}) - 2 * a) / 2
    l2 = (diff(eq,y).subs({x:0,y:1,z:0}) - 2 * c) / 2
    l3 = (diff(eq,z).subs({x:0,y:0,z:1}) - 2 * f) / 2
    #
    # Terme independent
    #
    ti = eq.subs({x:0,y:0,z:0})
    #
    # Matrius
    #
    Q = Matrix([[a,b,d],[b,c,e],[d,e,f]])
    L = Matrix(3,1,[l1,l2,l3])
    l = Vector(l1,l2,l3)
    #
    # Preparatius
    #
    vs = Q.eigenvects()
    vaps, veps = vaps_veps_amb_signe(vs,1)
    positius = list(zip(vaps,veps))
    vaps, veps = vaps_veps_amb_signe(vs,-1)
    negatius = list(zip(vaps,veps))
    positius.sort(key=lambda item: abs(item[0]))
    negatius.sort(key=lambda item: abs(item[0]))
    s = list(linsolve((Q,-L),*unknowns))
    #
    # Classificació
    #
    if len(positius) == 3 or len(negatius) == 3:
        #
        # Ellipsoide
        #
        s = Punt(list(s[0]))
        tip = eq.subs({x:s[0],y:s[1],z:s[2]})
        if tip == 0:
            return None
        if len(positius) == 3 and tip &gt; 0:
            return None
        if len(negatius) == 3 and tip &lt; 0:
            return None
        v = positius
        if len(v) == 0:
            v = negatius
        a2 = -tip / v[0][0]
        b2 = -tip / v[1][0]
        c2 = -tip / v[2][0]
        return Ellipsoide(a2,b2,c2,s,v[0][1],v[1][1])
    if len(positius) + len(negatius) == 3:
        #
        # Rang 3
        #
        s = Punt(list(s[0]))
        tip = eq.subs({x:s[0],y:s[1],z:s[2]})
        v1 = positius
        v2 = negatius
        signe = 1
        if len(v2) == 2:
            v1, v2 = v2, v1
            signe = -1
        a2 = signe * v1[0][0]
        b2 = signe * v1[1][0]
        c2 = signe * v2[0][0]
        tip *= signe
        if tip == 0:
            #
            # Con
            #
            if a2.is_integer and b2.is_integer and c2.is_integer:
                g = mcm_llista([a2,b2,c2])
            else:
                g = a2 * b2 * c2
            a2 = g / a2
            b2 = g / b2
            c2 = g / c2
            return Con(a2,b2,-c2,s,v1[0][1],v1[1][1])
        elif tip &gt; 0:
            #
            # Hiperboloide de dues fulles
            #
            a2 = tip / a2
            b2 = tip / b2
            c2 = tip / c2
            return HiperboloideDuesFulles(a2,b2,-c2,s,v1[0][1],v1[1][1])
        elif tip &lt; 0:
            #
            # Hiperboloide d&#39;una fulla
            #
            a2 = - tip / a2
            b2 = - tip / b2
            c2 = - tip / c2
            return HiperboloideUnaFulla(a2,b2,-c2,s,v1[0][1],v1[1][1])
    if len(positius) + len(negatius) == 2:
        #
        # Rang 2
        #
        if len(s) &gt; 0:
            s = Punt(list(s[0].subs({x:0,y:0,z:0})))
            tip = eq.subs({x:s[0],y:s[1],z:s[2]})
            if len(positius) == 2 or len(negatius) == 2:
                #
                # Clindre e·líptic
                #
                if tip == 0:
                    return None
                if len(positius) == 2 and tip &gt; 0:
                    return None
                if len(negatius) == 2 and tip &lt; 0:
                    return None
                v = positius
                if len(v) == 0:
                    v = negatius
                a2 = -tip / v[0][0]
                b2 = -tip / v[1][0]
                return CilindreElliptic(a2,b2,s,v[0][1],v[1][1])
            if len(positius) == 1:
                #
                # Clindre hiperbòlic
                #
                if tip == 0:
                    return None
                v1 = positius
                v2 = negatius
                a2 = -tip / positius[0][0]
                b2 = -tip / negatius[0][0]
                if a2 &lt; 0:
                    a2, b2 = b2, a2
                    v1, v2 = v2, v1
                return CilindreHiperbolic(a2,-b2,s,v1[0][1],v2[0][1])
        if len(positius) == 2 or len(negatius) == 2:
            #
            # Paraboloide el·líptic
            #
            v = positius
            if len(v) == 0:
                v = negatius
            v1, v2 = v[0][1],v[1][1]
            v1.simplificar()
            v2.simplificar()
            v3 = v1.cross(v2,simplificar=True)
            ep = v3.dot(l)/v3.length()
            t1, t2 = v[0][0],v[1][0]
            es1 = t1 * v1.dot(Vector(x,y,z)) + v1.dot(l)
            es2 = t2 * v2.dot(Vector(x,y,z)) + v2.dot(l)
            vertex = Punt(solve([es1,es2,eq],x,y,z)[0])
            a2 =  -2 * ep / t1
            b2 =  -2 * ep / t2
            if a2 &lt; 0:
                a2, b2 = -a2,-b2
                v2 = -v2
            a2 /= v3.length()
            b2 /= v3.length()
            return ParaboloideElliptic(a2,b2,vertex,v1,v2)
        if len(positius) == 1:
            #
            # Paraboloide hiperbòlic
            #
            v1 = positius
            v2 = negatius
            vec1, vec2 = v1[0][1],v2[0][1]
            vec1.simplificar()
            vec2.simplificar()
            vec3 = vec1.cross(vec2,simplificar=True)
            ep = vec3.dot(l)/vec3.length()
            t1, t2 = v1[0][0],v2[0][0]
            es1 = t1 * vec1.dot(Vector(x,y,z)) + vec1.dot(l)
            es2 = t2 * vec2.dot(Vector(x,y,z)) + vec2.dot(l)
            vertex = Punt(solve([es1,es2,eq],x,y,z)[0])
            a2 =  -2 * ep / t1
            b2 =  -2 * ep / t2
            if a2 &lt; 0:
                a2, b2 = b2, a2
                vec1, vec2 = vec2, vec1
                vec3 *= -1
            a2 /= vec3.length()
            b2 /= vec3.length()
            return ParaboloideHiperbolic(a2,-b2,vertex,vec1,vec2)
    if len(positius) + len(negatius) == 1:
        #
        # Cilindre parabòlic
        #
        if len(s) &gt; 0:
            return None
        v = positius
        if len(v) == 0:
            v = negatius
        t1 = v[0][0]
        v1 = v[0][1]
        v2 = v1.cross(l,simplificar=True)
        v3 = v1.cross(v2,simplificar=True)
        es = t1 * v1.dot(Vector(x,y,z)) + v1.dot(l)
        vertex = solve([es,eq],x,y,z)[0]
        k = 0
        while True:
            v = Punt([item.subs({x:k,y:k,z:k}) for item in vertex])
            f = v.factor_comu()
            if f[0].q == 1:
                break
            v = Punt([item.subs({x:-k,y:-k,z:-k}) for item in vertex])
            f = v.factor_comu()
            if f[0].q == 1:
                break
            k += 1
        ep = v3.dot(l)/v3.length()
        a2 =  -2 * ep / t1
        return CilindreParabolic(a2/2,v,v1,v2)</code></pre>
</details>
</dd>
<dt id="Algebra.Quadrica.hiperboloideduesfulles"><code class="name flex">
<span>def <span class="ident">hiperboloideduesfulles</span></span>(<span>maxim=30, diagonal=15, canonica=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna un hiperboloide de dues fulles de manera aleatòria</p>
<h2 id="parametres">Paràmetres</h2>
<p>maxim: valor màxim de la matriu projectiva de la quàdrica
diagonal: valor màxim de la diagonal de la matriu projectiva de la quàdrica
canonica: si és True, els eixos principals seran paral·lels
als de la referència canònica</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def hiperboloideduesfulles(cls,maxim=30,diagonal=15,canonica=False):
    &#34;&#34;&#34;
    Retorna un hiperboloide de dues fulles de manera aleatòria
    Paràmetres:
        maxim: valor màxim de la matriu projectiva de la quàdrica
        diagonal: valor màxim de la diagonal de la matriu projectiva de la quàdrica
        canonica: si és True, els eixos principals seran paral·lels
                  als de la referència canònica
    &#34;&#34;&#34;
    trobat = False
    while not trobat:
        h = HiperboloideDuesFulles.aleatoria(canonica=canonica)
        if canonica:
            trobat = True
        else:
            trobat = h.canonica.norma_maxim() &lt;= maxim and h.canonica.nzeros() &lt; 3 and h.canonica.max_diagonal() &lt; diagonal
    return h</code></pre>
</details>
</dd>
<dt id="Algebra.Quadrica.hiperboloideunafulla"><code class="name flex">
<span>def <span class="ident">hiperboloideunafulla</span></span>(<span>maxim=30, diagonal=15, canonica=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna un hiperboloide d'una fulla de manera aleatòria</p>
<h2 id="parametres">Paràmetres</h2>
<p>maxim: valor màxim de la matriu projectiva de la quàdrica
diagonal: valor màxim de la diagonal de la matriu projectiva de la quàdrica
canonica: si és True, els eixos principals seran paral·lels
als de la referència canònica</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def hiperboloideunafulla(cls,maxim=30,diagonal=15,canonica=False):
    &#34;&#34;&#34;
    Retorna un hiperboloide d&#39;una fulla de manera aleatòria
    Paràmetres:
        maxim: valor màxim de la matriu projectiva de la quàdrica
        diagonal: valor màxim de la diagonal de la matriu projectiva de la quàdrica
        canonica: si és True, els eixos principals seran paral·lels
                  als de la referència canònica
    &#34;&#34;&#34;
    trobat = False
    while not trobat:
        h = HiperboloideUnaFulla.aleatoria(canonica=canonica)
        if canonica:
            trobat = True
        else:
            trobat = h.canonica.norma_maxim() &lt;= maxim and h.canonica.nzeros() &lt; 3 and h.canonica.max_diagonal() &lt; diagonal
    return h</code></pre>
</details>
</dd>
<dt id="Algebra.Quadrica.paraboloideelliptic"><code class="name flex">
<span>def <span class="ident">paraboloideelliptic</span></span>(<span>maxim=30, diagonal=15, canonica=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna un paraboloide el·líptic de manera aleatòria</p>
<h2 id="parametres">Paràmetres</h2>
<p>maxim: valor màxim de la matriu projectiva de la quàdrica
diagonal: valor màxim de la diagonal de la matriu projectiva de la quàdrica
canonica: si és True, els eixos principals seran paral·lels
als de la referència canònica</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def paraboloideelliptic(cls,maxim=30,diagonal=15,canonica=False):
    &#34;&#34;&#34;
    Retorna un paraboloide el·líptic de manera aleatòria
    Paràmetres:
        maxim: valor màxim de la matriu projectiva de la quàdrica
        diagonal: valor màxim de la diagonal de la matriu projectiva de la quàdrica
        canonica: si és True, els eixos principals seran paral·lels
                  als de la referència canònica
    &#34;&#34;&#34;
    trobat = False
    while not trobat:
        p = ParaboloideElliptic.aleatoria(canonica=canonica)
        if canonica:
            trobat = True
        else:
            trobat = p.canonica.norma_maxim() &lt;= maxim and p.canonica.nzeros() &lt; 3 and p.canonica.max_diagonal() &lt; diagonal
    return p</code></pre>
</details>
</dd>
<dt id="Algebra.Quadrica.paraboloidehiperbolic"><code class="name flex">
<span>def <span class="ident">paraboloidehiperbolic</span></span>(<span>maxim=30, diagonal=15, canonica=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna un paraboloide hiperbòlic de manera aleatòria</p>
<h2 id="parametres">Paràmetres</h2>
<p>maxim: valor màxim de la matriu projectiva de la quàdrica
diagonal: valor màxim de la diagonal de la matriu projectiva de la quàdrica
canonica: si és True, els eixos principals seran paral·lels
als de la referència canònica</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def paraboloidehiperbolic(cls,maxim=30,diagonal=15,canonica=False):
    &#34;&#34;&#34;
    Retorna un paraboloide hiperbòlic de manera aleatòria
    Paràmetres:
        maxim: valor màxim de la matriu projectiva de la quàdrica
        diagonal: valor màxim de la diagonal de la matriu projectiva de la quàdrica
        canonica: si és True, els eixos principals seran paral·lels
                  als de la referència canònica
    &#34;&#34;&#34;
    trobat = False
    while not trobat:
        p = ParaboloideHiperbolic.aleatoria(canonica=canonica)
        if canonica:
            trobat = True
        else:
            trobat = p.canonica.norma_maxim() &lt;= maxim and p.canonica.nzeros() &lt; 3 and p.canonica.max_diagonal() &lt; diagonal
    return p</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Algebra.Quadrica.equacio"><code class="name flex">
<span>def <span class="ident">equacio</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna l'equació en latex de l'equació de la quàdrica</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def equacio(self):
    &#34;&#34;&#34;
    Retorna l&#39;equació en latex de l&#39;equació de la quàdrica
    &#34;&#34;&#34;
    x, y, z = symbols(&#39;x y z&#39;)
    m = Matriu.matriu_columna(Vector([x,y,z,1]))
    r = m.transposada() * self.canonica * m
    r.simplificar()
    return r[0,0].expand()</code></pre>
</details>
</dd>
<dt id="Algebra.Quadrica.referencia_principal"><code class="name flex">
<span>def <span class="ident">referencia_principal</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la referencia principal</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def referencia_principal(self):
    &#34;&#34;&#34;
    Retorna la referencia principal
    &#34;&#34;&#34;
    return self.ref</code></pre>
</details>
</dd>
<dt id="Algebra.Quadrica.tipus"><code class="name flex">
<span>def <span class="ident">tipus</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el tipus de quàdrica</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tipus(self):
    &#34;&#34;&#34;
    Retorna el tipus de quàdrica
    &#34;&#34;&#34;
    if isinstance(self,Ellipsoide):
        return &#34;El·lipsoide&#34;
    if isinstance(self,HiperboloideUnaFulla):
        return &#34;Hiperboloide d&#39;una fulla&#34;
    if isinstance(self,HiperboloideDuesFulles):
        return &#34;Hiperboloide de dues fulles&#34;
    if isinstance(self,Con):
        return &#34;Con real&#34;
    if isinstance(self,CilindreElliptic):
        return &#34;Cilindre el·líptic&#34;
    if isinstance(self,CilindreHiperbolic):
        return &#34;Cilindre hiperbòlic&#34;
    if isinstance(self,ParaboloideElliptic):
        return &#34;Paraboloide el·líptic&#34;
    if isinstance(self,ParaboloideHiperbolic):
        return &#34;Paraboloide hiperbòlic&#34;
    if isinstance(self,CilindreParabolic):
        return &#34;Cilindre parabòlic&#34;
    return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="Algebra.Quadrica.vectors"><code class="name flex">
<span>def <span class="ident">vectors</span></span>(<span>self, unitaris=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna els vectors de la base de la referència principal</p>
<h2 id="parametres">Paràmetres</h2>
<p>unitaris: si és True, els retorna unitaris</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vectors(self,unitaris=False):
    &#34;&#34;&#34;
    Retorna els vectors de la base de la referència principal
    Paràmetres:
        unitaris: si és True, els retorna unitaris
    &#34;&#34;&#34;
    return self.ref.vectors(unitaris)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Algebra.Radicals"><code class="flex name class">
<span>class <span class="ident">Radicals</span></span>
</code></dt>
<dd>
<div class="desc"><p>Classe per treure factor comú en expressions on hi apareixen arrels quadrades</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Radicals(object):
    &#34;&#34;&#34;
    Classe per treure factor comú en expressions on hi apareixen arrels quadrades
    &#34;&#34;&#34;
    def __init__(self):
        self.quadrats = []
        self.enters = []
        self.fraccions = []
    #
    #
    #
    def busca_quadrats(self,el):
        &#34;&#34;&#34;
        Afegeix els termes que apareixen dins d&#39;arrels quadrades a la llista
        self.quadrats
        Paràmetres:
            el: expressió del sympy
        &#34;&#34;&#34;
        if isinstance(el,Pow) and el.args[1] == Rational(1,2):
            if el.args[0] not in self.quadrats:
                self.quadrats.append(el.args[0])
        elif isinstance(el,int) or isinstance(el,Integer):
            if el not in self.enters:
                self.enters.append(el)
        else:
            for k in el.args:
                self.busca_quadrats(k)
    #
    #
    #
    def busca_fraccions(self,el):
        &#34;&#34;&#34;
        Afegeix els termes que apareixen als denominadors a la llista
        self.fraccions
        Paràmetres:
            el: expressió del sympy
        &#34;&#34;&#34;
        if isinstance(el,Pow):
            return
        if isinstance(el,int) or isinstance(el,Integer):
            return
        if isinstance(el,Rational):
            if el.q not in self.fraccions:
                self.fraccions.append(el.q)
        for k in el.args:
            self.busca_fraccions(k)
    #
    #
    #
    def mcd(self):
        &#34;&#34;&#34;
        Retorna el màxim comú divisor dels elements de la llista self.quadrats
        &#34;&#34;&#34;
        if len(self.quadrats) == 0:
            a = 1
        else:
            a = mcd_llista(self.quadrats)
        if len(self.enters) == 0:
            b = 1
        else:
            b = mcd_llista(self.enters)
        return (a,b)
    #
    #
    #
    def mcm(self):
        &#34;&#34;&#34;
        Retorna el mínim comú múltiple dels elements de la llista self.faccions
        &#34;&#34;&#34;
        if len(self.fraccions) == 0:
            return 1
        return mcm_llista(self.fraccions)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="Algebra.Radicals.busca_fraccions"><code class="name flex">
<span>def <span class="ident">busca_fraccions</span></span>(<span>self, el)</span>
</code></dt>
<dd>
<div class="desc"><p>Afegeix els termes que apareixen als denominadors a la llista
self.fraccions</p>
<h2 id="parametres">Paràmetres</h2>
<p>el: expressió del sympy</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def busca_fraccions(self,el):
    &#34;&#34;&#34;
    Afegeix els termes que apareixen als denominadors a la llista
    self.fraccions
    Paràmetres:
        el: expressió del sympy
    &#34;&#34;&#34;
    if isinstance(el,Pow):
        return
    if isinstance(el,int) or isinstance(el,Integer):
        return
    if isinstance(el,Rational):
        if el.q not in self.fraccions:
            self.fraccions.append(el.q)
    for k in el.args:
        self.busca_fraccions(k)</code></pre>
</details>
</dd>
<dt id="Algebra.Radicals.busca_quadrats"><code class="name flex">
<span>def <span class="ident">busca_quadrats</span></span>(<span>self, el)</span>
</code></dt>
<dd>
<div class="desc"><p>Afegeix els termes que apareixen dins d'arrels quadrades a la llista
self.quadrats</p>
<h2 id="parametres">Paràmetres</h2>
<p>el: expressió del sympy</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def busca_quadrats(self,el):
    &#34;&#34;&#34;
    Afegeix els termes que apareixen dins d&#39;arrels quadrades a la llista
    self.quadrats
    Paràmetres:
        el: expressió del sympy
    &#34;&#34;&#34;
    if isinstance(el,Pow) and el.args[1] == Rational(1,2):
        if el.args[0] not in self.quadrats:
            self.quadrats.append(el.args[0])
    elif isinstance(el,int) or isinstance(el,Integer):
        if el not in self.enters:
            self.enters.append(el)
    else:
        for k in el.args:
            self.busca_quadrats(k)</code></pre>
</details>
</dd>
<dt id="Algebra.Radicals.mcd"><code class="name flex">
<span>def <span class="ident">mcd</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el màxim comú divisor dels elements de la llista self.quadrats</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mcd(self):
    &#34;&#34;&#34;
    Retorna el màxim comú divisor dels elements de la llista self.quadrats
    &#34;&#34;&#34;
    if len(self.quadrats) == 0:
        a = 1
    else:
        a = mcd_llista(self.quadrats)
    if len(self.enters) == 0:
        b = 1
    else:
        b = mcd_llista(self.enters)
    return (a,b)</code></pre>
</details>
</dd>
<dt id="Algebra.Radicals.mcm"><code class="name flex">
<span>def <span class="ident">mcm</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el mínim comú múltiple dels elements de la llista self.faccions</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mcm(self):
    &#34;&#34;&#34;
    Retorna el mínim comú múltiple dels elements de la llista self.faccions
    &#34;&#34;&#34;
    if len(self.fraccions) == 0:
        return 1
    return mcm_llista(self.fraccions)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Algebra.RectaAfi"><code class="flex name class">
<span>class <span class="ident">RectaAfi</span></span>
<span>(</span><span>p, u, ref=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Classe per treballar amb rectes afins, dimensió 2 o 3</p>
<h2 id="atributs">Atributs</h2>
<p>u: generador de la recta vectorial
p: punt de pas</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RectaAfi(object):
    &#34;&#34;&#34;
    Classe per treballar amb rectes afins, dimensió 2 o 3
    Atributs:
        u: generador de la recta vectorial
        p: punt de pas
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,p,u,ref=None):
        &#34;&#34;&#34;
        Constructor.
        Paràmetres:
            p: punt de pas
            u: vector director de la recta
            ref: referència en que estan expressats u i p
        &#34;&#34;&#34;
        if not isinstance(u,Vector):
            return None
        if not isinstance(p,Punt):
            return None
        if p.dimensio != u.dimensio:
            return None
        if p.dimensio not in [2,3]:
            return None
        if ref is not None:
            if not isinstance(ref,ReferenciaAfi):
                return None
            if ref.dimensio != p.dimensio:
                return None
        return super(RectaAfi,cls).__new__(cls)
    #
    #
    #
    def __init__(self,p,u,ref=None):
        if ref is None:
            self.u = u
            self.p = p
        else:
            self.u = ref.base.vector_de_components(u)
            self.p = ref.punt_de_coordenades(p)
    #
    #
    #
    def __repr__(self):
        &#34;&#34;&#34;
        Retorna l&#39;equació vectorial de la recta en LaTeX
        &#34;&#34;&#34;
        q = self.punt_de_coordenades_enteres()
        if self.u.dimensio == 2:
            return f&#34;(x,y)={q}+t{self.u}&#34;
        else:
            return f&#34;(x,y,z)={q}+t{self.u}&#34;
    #
    #
    #
    @classmethod
    def aleatoria(cls,dim=3,maxim=None):
        &#34;&#34;&#34;
        Retorna una recta afí aleatòria
        Paràmetres:
             dim: dimensió
             maxim: màxim de les coordenades del punt i les components dels
                    vector director

        &#34;&#34;&#34;
        if maxim is None:
            v = Vector.aleatori(l=dim,maxim=3,nuls=False)
            p = Punt.aleatori(l=dim,maxim=4,nuls=False)
        else:
            v = Vector.aleatori(l=dim,maxim=maxim,nuls=False)
            p = Punt.aleatori(l=dim,maxim=maxim,nuls=False)
        return cls(p,v)
    #
    #
    #
    @classmethod
    def from_equacions_implicites(cls,s):
        &#34;&#34;&#34;
        Retorna la recta afí que té equacions implícites s
        Paràmetres:
            s: SistemaEquacions
        &#34;&#34;&#34;
        if not isinstance(s,SistemaEquacions):
            return None
        if s.A.files != 2 or s.A.columnes != 3 or s.A.rang() != 2:
            return None
        s.resol()
        t1 = symbols(&#39;t1&#39;)
        p1 = Punt([v.subs(t1,0) for v in s.parametrica])
        p2 = Punt([v.subs(t1,1) for v in s.parametrica])
        u = p2-p1
        u.simplificar()
        return cls(p1,u)
    #
    #
    #
    def punt_de_coordenades_enteres(self,p=None,u=None):
        &#34;&#34;&#34;
        Retorna, si és possible, un punt de coordenades enteres de la recta
        que passa pel punt p i té vector director u
        &#34;&#34;&#34;
        if p is None:
            p = self.p
        if u is None:
            u = self.u
        if p.tots_enters():
            return p
        t, _ = p.factor_comu()
        if isinstance(t,Rational):
            for i in range(1,t.q):
                r = (p + Rational(i,t.q) * u).punt()
                if r.tots_enters():
                    return r
                r = (p - Rational(i,t.q) * u).punt()
                if r.tots_enters():
                    return r
        return p
    #
    #
    #
    def equacio_continua(self,ref=None,prime=0):
        &#34;&#34;&#34;
        Retorna l&#39;expressió en latex de l&#39;equqció contínua de la recta afí
        en la referència &#34;ref&#34;.
        Paràmetres:
            ref: referència afí. Si és None, serà la canònica
            prime: nombre de primes que s&#39;escriuran a les incògnites
        &#34;&#34;&#34;
        if ref is None:
            v = Vector(self.u.components)
            q = Punt(self.p.components)
        else:
            v = self.u.components_en_base(ref.base)
            q = self.p.coordenades_en_referencia(ref)
        v.simplificar()
        q = self.punt_de_coordenades_enteres(q,v)
        x, y, z = symbols(&#39;x y z&#39;)
        incg = [x,y,z]
        eq = []
        p = &#34;&#34;
        if prime &gt; 0:
            p = prime * &#34;&#39;&#34;
        for i in range(v.dimensio):
            if v[i] == 1:
                eq.append(latex(incg[i] - q[i]))
            else:
                eq.append(f&#34;\\frac{{{latex(incg[i] - q[i])}}}{{{v[i]}}}&#34;)
        eq = &#34; = &#34;.join(eq)
        for i in incg:
            eq = eq.replace(latex(i),latex(i) + p)
        return eq
    #
    #
    #
    def equacions_implicites(self,ref=None,prime=0,aleatori=True):
        &#34;&#34;&#34;
        Retorna l&#39;equació implícita (dimensió 2) o el sistema d&#39;equacions implícites
        (dimensió 3) de la recta afí en la referència &#34;ref&#34;.
        Paràmetres:
           ref: referència en la que calculem les equacions implícites
           prime: nombre de primes que s&#39;escriran a les incògnites
           aleatori: només s&#39;aplica a dimensió 3 i genera unes equacions implícites
           amb tots els coeficients de les incògnites no nuls
        &#34;&#34;&#34;
        if ref is None:
            v = Vector(self.u.components)
            a = Matriu.matriu_fila(self.u)
            q = Punt(self.p.components)
        else:
            v = self.u.components_en_base(ref.base)
            a = Matriu.matriu_fila(v)
            q = self.p.coordenades_en_referencia(ref)
        l = a.nucli()
        if len(l) == 1:
            return EquacioLineal.coeficients(l[0],l[0].dot(q),False,prime)
        a = Matriu.from_vectors_fila(l)
        b = a * q
        if aleatori:
            trobat = False
            while not trobat:
                m = Matriu.amb_rang(f=2,c=2,r=2,maxim=3,mzeros=0)
                aux = m * a
                trobat = aux.nzeros() == 0
            a = m * a
            b = m * b
        return SistemaEquacions(a,b,prime=prime)
    #
    #
    #
    def distancia(self,other):
        &#34;&#34;&#34;
        Retorna la distància entre la recta actual i un punt, una recta o un pla
        Paràmetres:
            other: un punt (classe Punt), una recta (classe RectaAfi) o un plan
            (class PlaAfi)
        &#34;&#34;&#34;
        if isinstance(other,Punt):
            v = self.p - other
            w = self.u.cross(v)
            return w.length()/self.u.length()
        if isinstance(other,RectaAfi):
            w = self.u.cross(other.u,simplificar=True)
            if w.length() &gt; 0:
                u = self.p - other.p
                return abs(u.dot(w) / w.length())
            return self.distancia(other.p)
        if isinstance(other,PlaAfi):
            w = other.associat()
            if w.dot(self.u) == 0:
                return other.distancia(self.p)
            return 0
        return None
    #
    #
    #
    def punt(self,t):
        &#34;&#34;&#34;
        Retorna el punt de la recta amb paràmetre t
        Paràmetres:
            t: escalar
        &#34;&#34;&#34;
        q = self.p + t * self.u
        return Punt(q.components)
    #
    #
    #
    def projeccio_ortogonal(self,punt):
        &#34;&#34;&#34;
        Retorna la projecció ortogonal del punt &#34;punt&#34; sobre la recta
        Paràmetres:
          punt: Punt
        &#34;&#34;&#34;
        P = RectaVectorial(self.u)
        if not isinstance(punt,Punt):
            return None
        if punt.dimensio != self.u.dimensio:
            return None
        return (self.p + P.projeccio_ortogonal(punt - self.p)).punt()
    #
    #
    #
    def interseccio(self,other):
        &#34;&#34;&#34;
        Retorna la intersecció de la recta amb una altra recta o un pla.
        El resultat pot ser None, un punt o una recta.
        Paràmetes:
          other. PlaAfi o RectaAfi
        &#34;&#34;&#34;
        if isinstance(other,RectaAfi):
            if self.u.dimensio != other.u.dimensio:
                return None
            m = Matriu.from_vectors_columna([self.u,other.u])
            if m.rang() == 1:
                if self.conte(other.p):
                    return self
                return None
            if self.u.dimensio == 3:
                m = Matriu.from_vectors_columna([self.u,other.u,self.p - other.p])
                if m.det() != 0:
                    return None
            m = Matriu.from_vectors_columna([self.u,- other.u])
            b = other.p - self.p
            s = SistemaEquacions(m,b)
            s.resol()
            return (self.p + s.solucio[0] * self.u).punt()
        if isinstance(other,PlaAfi):
            m = Matriu.from_vectors_columna([other.u1,other.u2,-self.u])
            if m.det() != 0:
                b = self.p - other.p
                s = SistemaEquacions(m,b)
                s.resol()
                return (self.p + s.solucio[2] * self.u).punt()
            if other.conte(self.p):
                return self
        return None
    #
    #
    #
    def simetric(self,punt):
        &#34;&#34;&#34;
        Retorna el simètric del punt &#34;punt&#34; respecte a la recta
        Paràmetres:
          punt: Punt
        &#34;&#34;&#34;
        return 2*self.projeccio_ortogonal(punt) - punt
    #
    #
    #
    def conte(self,punt):
        &#34;&#34;&#34;
        Retorna si el punt &#34;punt&#34; pertany a la recta
        Paràmetres:
          punt: Punt
        &#34;&#34;&#34;
        if not isinstance(punt,Punt):
            return None
        if punt.dimensio != self.u.dimensio:
            return None
        m = Matriu.from_vectors_columna([self.u,punt - self.p])
        return m.rang() == 1</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="Algebra.RectaAfi.aleatoria"><code class="name flex">
<span>def <span class="ident">aleatoria</span></span>(<span>dim=3, maxim=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna una recta afí aleatòria</p>
<h2 id="parametres">Paràmetres</h2>
<p>dim: dimensió
maxim: màxim de les coordenades del punt i les components dels
vector director</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def aleatoria(cls,dim=3,maxim=None):
    &#34;&#34;&#34;
    Retorna una recta afí aleatòria
    Paràmetres:
         dim: dimensió
         maxim: màxim de les coordenades del punt i les components dels
                vector director

    &#34;&#34;&#34;
    if maxim is None:
        v = Vector.aleatori(l=dim,maxim=3,nuls=False)
        p = Punt.aleatori(l=dim,maxim=4,nuls=False)
    else:
        v = Vector.aleatori(l=dim,maxim=maxim,nuls=False)
        p = Punt.aleatori(l=dim,maxim=maxim,nuls=False)
    return cls(p,v)</code></pre>
</details>
</dd>
<dt id="Algebra.RectaAfi.from_equacions_implicites"><code class="name flex">
<span>def <span class="ident">from_equacions_implicites</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la recta afí que té equacions implícites s</p>
<h2 id="parametres">Paràmetres</h2>
<p>s: SistemaEquacions</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_equacions_implicites(cls,s):
    &#34;&#34;&#34;
    Retorna la recta afí que té equacions implícites s
    Paràmetres:
        s: SistemaEquacions
    &#34;&#34;&#34;
    if not isinstance(s,SistemaEquacions):
        return None
    if s.A.files != 2 or s.A.columnes != 3 or s.A.rang() != 2:
        return None
    s.resol()
    t1 = symbols(&#39;t1&#39;)
    p1 = Punt([v.subs(t1,0) for v in s.parametrica])
    p2 = Punt([v.subs(t1,1) for v in s.parametrica])
    u = p2-p1
    u.simplificar()
    return cls(p1,u)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Algebra.RectaAfi.conte"><code class="name flex">
<span>def <span class="ident">conte</span></span>(<span>self, punt)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna si el punt "punt" pertany a la recta</p>
<h2 id="parametres">Paràmetres</h2>
<p>punt: Punt</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conte(self,punt):
    &#34;&#34;&#34;
    Retorna si el punt &#34;punt&#34; pertany a la recta
    Paràmetres:
      punt: Punt
    &#34;&#34;&#34;
    if not isinstance(punt,Punt):
        return None
    if punt.dimensio != self.u.dimensio:
        return None
    m = Matriu.from_vectors_columna([self.u,punt - self.p])
    return m.rang() == 1</code></pre>
</details>
</dd>
<dt id="Algebra.RectaAfi.distancia"><code class="name flex">
<span>def <span class="ident">distancia</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la distància entre la recta actual i un punt, una recta o un pla</p>
<h2 id="parametres">Paràmetres</h2>
<p>other: un punt (classe Punt), una recta (classe RectaAfi) o un plan
(class PlaAfi)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distancia(self,other):
    &#34;&#34;&#34;
    Retorna la distància entre la recta actual i un punt, una recta o un pla
    Paràmetres:
        other: un punt (classe Punt), una recta (classe RectaAfi) o un plan
        (class PlaAfi)
    &#34;&#34;&#34;
    if isinstance(other,Punt):
        v = self.p - other
        w = self.u.cross(v)
        return w.length()/self.u.length()
    if isinstance(other,RectaAfi):
        w = self.u.cross(other.u,simplificar=True)
        if w.length() &gt; 0:
            u = self.p - other.p
            return abs(u.dot(w) / w.length())
        return self.distancia(other.p)
    if isinstance(other,PlaAfi):
        w = other.associat()
        if w.dot(self.u) == 0:
            return other.distancia(self.p)
        return 0
    return None</code></pre>
</details>
</dd>
<dt id="Algebra.RectaAfi.equacio_continua"><code class="name flex">
<span>def <span class="ident">equacio_continua</span></span>(<span>self, ref=None, prime=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna l'expressió en latex de l'equqció contínua de la recta afí
en la referència "ref".</p>
<h2 id="parametres">Paràmetres</h2>
<p>ref: referència afí. Si és None, serà la canònica
prime: nombre de primes que s'escriuran a les incògnites</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def equacio_continua(self,ref=None,prime=0):
    &#34;&#34;&#34;
    Retorna l&#39;expressió en latex de l&#39;equqció contínua de la recta afí
    en la referència &#34;ref&#34;.
    Paràmetres:
        ref: referència afí. Si és None, serà la canònica
        prime: nombre de primes que s&#39;escriuran a les incògnites
    &#34;&#34;&#34;
    if ref is None:
        v = Vector(self.u.components)
        q = Punt(self.p.components)
    else:
        v = self.u.components_en_base(ref.base)
        q = self.p.coordenades_en_referencia(ref)
    v.simplificar()
    q = self.punt_de_coordenades_enteres(q,v)
    x, y, z = symbols(&#39;x y z&#39;)
    incg = [x,y,z]
    eq = []
    p = &#34;&#34;
    if prime &gt; 0:
        p = prime * &#34;&#39;&#34;
    for i in range(v.dimensio):
        if v[i] == 1:
            eq.append(latex(incg[i] - q[i]))
        else:
            eq.append(f&#34;\\frac{{{latex(incg[i] - q[i])}}}{{{v[i]}}}&#34;)
    eq = &#34; = &#34;.join(eq)
    for i in incg:
        eq = eq.replace(latex(i),latex(i) + p)
    return eq</code></pre>
</details>
</dd>
<dt id="Algebra.RectaAfi.equacions_implicites"><code class="name flex">
<span>def <span class="ident">equacions_implicites</span></span>(<span>self, ref=None, prime=0, aleatori=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna l'equació implícita (dimensió 2) o el sistema d'equacions implícites
(dimensió 3) de la recta afí en la referència "ref".</p>
<h2 id="parametres">Paràmetres</h2>
<p>ref: referència en la que calculem les equacions implícites
prime: nombre de primes que s'escriran a les incògnites
aleatori: només s'aplica a dimensió 3 i genera unes equacions implícites
amb tots els coeficients de les incògnites no nuls</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def equacions_implicites(self,ref=None,prime=0,aleatori=True):
    &#34;&#34;&#34;
    Retorna l&#39;equació implícita (dimensió 2) o el sistema d&#39;equacions implícites
    (dimensió 3) de la recta afí en la referència &#34;ref&#34;.
    Paràmetres:
       ref: referència en la que calculem les equacions implícites
       prime: nombre de primes que s&#39;escriran a les incògnites
       aleatori: només s&#39;aplica a dimensió 3 i genera unes equacions implícites
       amb tots els coeficients de les incògnites no nuls
    &#34;&#34;&#34;
    if ref is None:
        v = Vector(self.u.components)
        a = Matriu.matriu_fila(self.u)
        q = Punt(self.p.components)
    else:
        v = self.u.components_en_base(ref.base)
        a = Matriu.matriu_fila(v)
        q = self.p.coordenades_en_referencia(ref)
    l = a.nucli()
    if len(l) == 1:
        return EquacioLineal.coeficients(l[0],l[0].dot(q),False,prime)
    a = Matriu.from_vectors_fila(l)
    b = a * q
    if aleatori:
        trobat = False
        while not trobat:
            m = Matriu.amb_rang(f=2,c=2,r=2,maxim=3,mzeros=0)
            aux = m * a
            trobat = aux.nzeros() == 0
        a = m * a
        b = m * b
    return SistemaEquacions(a,b,prime=prime)</code></pre>
</details>
</dd>
<dt id="Algebra.RectaAfi.interseccio"><code class="name flex">
<span>def <span class="ident">interseccio</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la intersecció de la recta amb una altra recta o un pla.
El resultat pot ser None, un punt o una recta.</p>
<h2 id="parametes">Paràmetes</h2>
<p>other. PlaAfi o RectaAfi</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interseccio(self,other):
    &#34;&#34;&#34;
    Retorna la intersecció de la recta amb una altra recta o un pla.
    El resultat pot ser None, un punt o una recta.
    Paràmetes:
      other. PlaAfi o RectaAfi
    &#34;&#34;&#34;
    if isinstance(other,RectaAfi):
        if self.u.dimensio != other.u.dimensio:
            return None
        m = Matriu.from_vectors_columna([self.u,other.u])
        if m.rang() == 1:
            if self.conte(other.p):
                return self
            return None
        if self.u.dimensio == 3:
            m = Matriu.from_vectors_columna([self.u,other.u,self.p - other.p])
            if m.det() != 0:
                return None
        m = Matriu.from_vectors_columna([self.u,- other.u])
        b = other.p - self.p
        s = SistemaEquacions(m,b)
        s.resol()
        return (self.p + s.solucio[0] * self.u).punt()
    if isinstance(other,PlaAfi):
        m = Matriu.from_vectors_columna([other.u1,other.u2,-self.u])
        if m.det() != 0:
            b = self.p - other.p
            s = SistemaEquacions(m,b)
            s.resol()
            return (self.p + s.solucio[2] * self.u).punt()
        if other.conte(self.p):
            return self
    return None</code></pre>
</details>
</dd>
<dt id="Algebra.RectaAfi.projeccio_ortogonal"><code class="name flex">
<span>def <span class="ident">projeccio_ortogonal</span></span>(<span>self, punt)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la projecció ortogonal del punt "punt" sobre la recta</p>
<h2 id="parametres">Paràmetres</h2>
<p>punt: Punt</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def projeccio_ortogonal(self,punt):
    &#34;&#34;&#34;
    Retorna la projecció ortogonal del punt &#34;punt&#34; sobre la recta
    Paràmetres:
      punt: Punt
    &#34;&#34;&#34;
    P = RectaVectorial(self.u)
    if not isinstance(punt,Punt):
        return None
    if punt.dimensio != self.u.dimensio:
        return None
    return (self.p + P.projeccio_ortogonal(punt - self.p)).punt()</code></pre>
</details>
</dd>
<dt id="Algebra.RectaAfi.punt"><code class="name flex">
<span>def <span class="ident">punt</span></span>(<span>self, t)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el punt de la recta amb paràmetre t</p>
<h2 id="parametres">Paràmetres</h2>
<p>t: escalar</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def punt(self,t):
    &#34;&#34;&#34;
    Retorna el punt de la recta amb paràmetre t
    Paràmetres:
        t: escalar
    &#34;&#34;&#34;
    q = self.p + t * self.u
    return Punt(q.components)</code></pre>
</details>
</dd>
<dt id="Algebra.RectaAfi.punt_de_coordenades_enteres"><code class="name flex">
<span>def <span class="ident">punt_de_coordenades_enteres</span></span>(<span>self, p=None, u=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna, si és possible, un punt de coordenades enteres de la recta
que passa pel punt p i té vector director u</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def punt_de_coordenades_enteres(self,p=None,u=None):
    &#34;&#34;&#34;
    Retorna, si és possible, un punt de coordenades enteres de la recta
    que passa pel punt p i té vector director u
    &#34;&#34;&#34;
    if p is None:
        p = self.p
    if u is None:
        u = self.u
    if p.tots_enters():
        return p
    t, _ = p.factor_comu()
    if isinstance(t,Rational):
        for i in range(1,t.q):
            r = (p + Rational(i,t.q) * u).punt()
            if r.tots_enters():
                return r
            r = (p - Rational(i,t.q) * u).punt()
            if r.tots_enters():
                return r
    return p</code></pre>
</details>
</dd>
<dt id="Algebra.RectaAfi.simetric"><code class="name flex">
<span>def <span class="ident">simetric</span></span>(<span>self, punt)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el simètric del punt "punt" respecte a la recta</p>
<h2 id="parametres">Paràmetres</h2>
<p>punt: Punt</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simetric(self,punt):
    &#34;&#34;&#34;
    Retorna el simètric del punt &#34;punt&#34; respecte a la recta
    Paràmetres:
      punt: Punt
    &#34;&#34;&#34;
    return 2*self.projeccio_ortogonal(punt) - punt</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Algebra.RectaRegressio"><code class="flex name class">
<span>class <span class="ident">RectaRegressio</span></span>
<span>(</span><span>punts)</span>
</code></dt>
<dd>
<div class="desc"><p>Classe per treballar amb rectes de regressió</p>
<h2 id="atributs">Atributs</h2>
<p>punts: llista de punts
A: matriu dels coeficients de les incògnites
B: vector de termes independents
solucio: solució del sistema d'equacions A^tAX = A^tB</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RectaRegressio(object):
    &#34;&#34;&#34;
    Classe per treballar amb rectes de regressió
    Atributs:
        punts: llista de punts
        A: matriu dels coeficients de les incògnites
        B: vector de termes independents
        solucio: solució del sistema d&#39;equacions A^tAX = A^tB
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,punts):
        &#34;&#34;&#34;
        Retorna un objecte RectaRegressio definit a partir d&#39;una llista de punts
        Paràmetres:
            punts: llista de punts de dimensió 2
        &#34;&#34;&#34;
        if not isinstance(punts,list) and not isinstance(punts,tuple):
            return None
        if len(punts) &lt;= 2:
            return None
        for k in punts:
            if not isinstance(k,Punt):
                return None
            if k.dimensio != 2:
                return None
        return super(RectaRegressio,cls).__new__(cls)
    #
    #
    #
    def __init__(self,punts):
        self.punts = punts
        a = Vector([k[0] for k in self.punts])
        b = Vector(len(self.punts) * [1])
        A = Matriu.from_vectors_columna([a,b])
        B = Vector([k[1] for k in self.punts])
        s = SistemaEquacions(A.transposada() * A,A.transposada() * B)
        s.resol()
        self.A = A
        self.B = B
        self.solucio = Vector(s.solucio)
    #
    #
    #
    def equacio(self):
        &#34;&#34;&#34;
        Retorna l&#39;equació de la recta de regressió expressada en LaTeX
        &#34;&#34;&#34;
        x = symbols(&#39;x&#39;)
        n = Vector.nul(dim=2)
        if self.solucio == n:
            return &#34;y=0&#34;
        a, b = self.solucio.factor_comu()
        eq = a.p * (b[0]*x + b[1])
        if a.q == 1:
            return f&#34;y = {mylatex(eq)}&#34;
        return f&#34;y = \\frac{{ {mylatex(eq)} }}{{ {a.q} }}&#34;
    #
    #
    #
    def error_quadratic(self):
        &#34;&#34;&#34;
        Retorna d&#39;error quadràtic
        &#34;&#34;&#34;
        e = self.A * self.solucio - self.B
        return e.length()
    #
    #
    #
    @classmethod
    def aleatoria(cls,l=4,max=4):
        &#34;&#34;&#34;
        Retorna un problema aleatori amb l punts
        Paràmetres:
            l: nombre de punts
            max: valor màxim de les ys
        &#34;&#34;&#34;
        if l &gt; 13:
            return None
        p = [-k for k in range(l)] + [k for k in range(l)]
        random.shuffle(p)
        xs = p[0:l]
        xs.sort()
        ys = [random.randint(-max,max) for k in range(l)]
        punts = [Punt(xs[k],ys[k]) for k in range(l)]
        return cls(punts)
    #
    #
    #
    def llista_punts(self):
        &#34;&#34;&#34;
        Retorna la llista de punts en format LaTeX
        &#34;&#34;&#34;
        l = list(map(lambda item: f&#34;${item}$&#34;,self.punts))
        return &#34;, &#34;.join(l[0:-1]) + f&#34; i {l[-1]}&#34;
    #
    #
    #
    def taula_punts(self):
        &#34;&#34;&#34;
        Retorna una taula en format LaTeX dels punts
        &#34;&#34;&#34;
        format = &#34;c|&#34; + len(self.punts) * &#34;r&#34;
        xs = &#34; &amp; &#34;.join([f&#34;${p[0]}$&#34; for p in self.punts])
        ys = &#34; &amp; &#34;.join([f&#34;${p[1]}$&#34; for p in self.punts])
        return f&#34;\\begin{{tabular}}{{{format}}} {xs} \\\\ \\hline {ys} \\end{{tabular}}&#34;</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="Algebra.RectaRegressio.aleatoria"><code class="name flex">
<span>def <span class="ident">aleatoria</span></span>(<span>l=4, max=4)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna un problema aleatori amb l punts</p>
<h2 id="parametres">Paràmetres</h2>
<p>l: nombre de punts
max: valor màxim de les ys</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def aleatoria(cls,l=4,max=4):
    &#34;&#34;&#34;
    Retorna un problema aleatori amb l punts
    Paràmetres:
        l: nombre de punts
        max: valor màxim de les ys
    &#34;&#34;&#34;
    if l &gt; 13:
        return None
    p = [-k for k in range(l)] + [k for k in range(l)]
    random.shuffle(p)
    xs = p[0:l]
    xs.sort()
    ys = [random.randint(-max,max) for k in range(l)]
    punts = [Punt(xs[k],ys[k]) for k in range(l)]
    return cls(punts)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Algebra.RectaRegressio.equacio"><code class="name flex">
<span>def <span class="ident">equacio</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna l'equació de la recta de regressió expressada en LaTeX</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def equacio(self):
    &#34;&#34;&#34;
    Retorna l&#39;equació de la recta de regressió expressada en LaTeX
    &#34;&#34;&#34;
    x = symbols(&#39;x&#39;)
    n = Vector.nul(dim=2)
    if self.solucio == n:
        return &#34;y=0&#34;
    a, b = self.solucio.factor_comu()
    eq = a.p * (b[0]*x + b[1])
    if a.q == 1:
        return f&#34;y = {mylatex(eq)}&#34;
    return f&#34;y = \\frac{{ {mylatex(eq)} }}{{ {a.q} }}&#34;</code></pre>
</details>
</dd>
<dt id="Algebra.RectaRegressio.error_quadratic"><code class="name flex">
<span>def <span class="ident">error_quadratic</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna d'error quadràtic</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def error_quadratic(self):
    &#34;&#34;&#34;
    Retorna d&#39;error quadràtic
    &#34;&#34;&#34;
    e = self.A * self.solucio - self.B
    return e.length()</code></pre>
</details>
</dd>
<dt id="Algebra.RectaRegressio.llista_punts"><code class="name flex">
<span>def <span class="ident">llista_punts</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la llista de punts en format LaTeX</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def llista_punts(self):
    &#34;&#34;&#34;
    Retorna la llista de punts en format LaTeX
    &#34;&#34;&#34;
    l = list(map(lambda item: f&#34;${item}$&#34;,self.punts))
    return &#34;, &#34;.join(l[0:-1]) + f&#34; i {l[-1]}&#34;</code></pre>
</details>
</dd>
<dt id="Algebra.RectaRegressio.taula_punts"><code class="name flex">
<span>def <span class="ident">taula_punts</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna una taula en format LaTeX dels punts</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def taula_punts(self):
    &#34;&#34;&#34;
    Retorna una taula en format LaTeX dels punts
    &#34;&#34;&#34;
    format = &#34;c|&#34; + len(self.punts) * &#34;r&#34;
    xs = &#34; &amp; &#34;.join([f&#34;${p[0]}$&#34; for p in self.punts])
    ys = &#34; &amp; &#34;.join([f&#34;${p[1]}$&#34; for p in self.punts])
    return f&#34;\\begin{{tabular}}{{{format}}} {xs} \\\\ \\hline {ys} \\end{{tabular}}&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Algebra.RectaVectorial"><code class="flex name class">
<span>class <span class="ident">RectaVectorial</span></span>
<span>(</span><span>u)</span>
</code></dt>
<dd>
<div class="desc"><p>Classe per treballar amb rectes vectorials, dimensió 2 o 3</p>
<h2 id="atributs">Atributs</h2>
<p>u: generador de la recta vectorial</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RectaVectorial(object):
    &#34;&#34;&#34;
    Classe per treballar amb rectes vectorials, dimensió 2 o 3
    Atributs:
        u: generador de la recta vectorial
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,u):
        &#34;&#34;&#34;
        Constructor.
        Paràmetres:
            u: vector amb dimensió 2 o 3
        &#34;&#34;&#34;
        if not isinstance(u,Vector):
            return None
        if u.dimensio not in [2,3]:
            return None
        return super(RectaVectorial,cls).__new__(cls)
    #
    #
    #
    def __init__(self,u):
        self.u = u
    #
    #
    #
    def equacions_implicites(self,base=None,prime=0,aleatori=True):
        &#34;&#34;&#34;
        Retorna l&#39;equació implícita (dimensió 2) o el sistema d&#39;equacions implícites
        (dimensió 3) en la base &#34;base&#34;.
        Paràmetres:
            base: Base en la que calculem les equacions implícites
            prime: Quantes primes volem posar a les equacions
            aleatori: només s&#39;aplica a dimensió 3 i genera unes equacions implícites no trivials
        &#34;&#34;&#34;
        if base is None:
            a = Matriu.matriu_fila(self.u)
        else:
            a = Matriu.matriu_fila(self.u.components_en_base(base))
        l = a.nucli()
        if len(l) == 1:
            return EquacioLineal.coeficients(l[0],0,False,prime)
        a = Matriu.from_vectors_fila(l)
        b = Vector.nul(len(l))
        if aleatori:
            m = Matriu.amb_rang(f=2,c=2,r=2,maxim=3,mzeros=0)
            a = m * a
        return SistemaEquacions(a,b,prime=prime)
    #
    #
    #
    def equacio_continua(self,base=None,prime=0):
        &#34;&#34;&#34;
        Retorna l&#39;expressió en LaTeX de l&#39;equació contínua de la recta vectorial
        en la base &#34;base&#34;.
        Paràmetres:
            base: base del pla o de l&#39;espai vectorial (classe Base)
            prime: nombre de primes amb el que s&#39;escriuran les incògnites
        &#34;&#34;&#34;
        if base is None:
            v = Vector(self.u.components)
        else:
            v = self.u.components_en_base(base)
        v.simplificar()
        x, y, z = symbols(&#39;x y z&#39;)
        incg = [x,y,z]
        eq = []
        p = &#34;&#34;
        if prime &gt; 0:
            p = prime * &#34;&#39;&#34;
        for i in range(v.dimensio):
            if v[i] == 1:
                eq.append(latex(incg[i]) + p)
            else:
                eq.append(f&#34;\\frac{{{latex(incg[i]) + p}}}{{{v[i]}}}&#34;)
        return &#34; = &#34;.join(eq)
    #
    #
    #
    def projeccio_ortogonal(self,u):
        &#34;&#34;&#34;
        Retorna la projecció ortogonal del vector u sobre la recta.
        Paràmetres:
          u: Vector
        &#34;&#34;&#34;
        if not isinstance(u,Vector):
            return None
        if u.dimensio != self.u.dimensio:
            return None
        v = self.u
        t = u.dot(v)/v.dot(v)
        return t * v
    #
    #
    #
    def simetric(self,u):
        &#34;&#34;&#34;
        Retorna el simètric del vector u respecte a la recta.
        Paràmetres:
          u: Vector
        &#34;&#34;&#34;
        if not isinstance(u,Vector):
            return None
        if u.dimensio != self.u.dimensio:
            return None
        return 2*self.projeccio_ortogonal(u) - u
    #
    #
    #
    def ortogonal(self):
        &#34;&#34;&#34;
        Retorna el suplementari ortogonal
        &#34;&#34;&#34;
        a = Matriu.from_vectors_fila([self.u])
        n = a.nucli()
        if len(n) == 1:
            return RectaVectorial(n[0])
        return PlaVectorial(n)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="Algebra.RectaVectorial.equacio_continua"><code class="name flex">
<span>def <span class="ident">equacio_continua</span></span>(<span>self, base=None, prime=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna l'expressió en LaTeX de l'equació contínua de la recta vectorial
en la base "base".</p>
<h2 id="parametres">Paràmetres</h2>
<p>base: base del pla o de l'espai vectorial (classe Base)
prime: nombre de primes amb el que s'escriuran les incògnites</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def equacio_continua(self,base=None,prime=0):
    &#34;&#34;&#34;
    Retorna l&#39;expressió en LaTeX de l&#39;equació contínua de la recta vectorial
    en la base &#34;base&#34;.
    Paràmetres:
        base: base del pla o de l&#39;espai vectorial (classe Base)
        prime: nombre de primes amb el que s&#39;escriuran les incògnites
    &#34;&#34;&#34;
    if base is None:
        v = Vector(self.u.components)
    else:
        v = self.u.components_en_base(base)
    v.simplificar()
    x, y, z = symbols(&#39;x y z&#39;)
    incg = [x,y,z]
    eq = []
    p = &#34;&#34;
    if prime &gt; 0:
        p = prime * &#34;&#39;&#34;
    for i in range(v.dimensio):
        if v[i] == 1:
            eq.append(latex(incg[i]) + p)
        else:
            eq.append(f&#34;\\frac{{{latex(incg[i]) + p}}}{{{v[i]}}}&#34;)
    return &#34; = &#34;.join(eq)</code></pre>
</details>
</dd>
<dt id="Algebra.RectaVectorial.equacions_implicites"><code class="name flex">
<span>def <span class="ident">equacions_implicites</span></span>(<span>self, base=None, prime=0, aleatori=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna l'equació implícita (dimensió 2) o el sistema d'equacions implícites
(dimensió 3) en la base "base".</p>
<h2 id="parametres">Paràmetres</h2>
<p>base: Base en la que calculem les equacions implícites
prime: Quantes primes volem posar a les equacions
aleatori: només s'aplica a dimensió 3 i genera unes equacions implícites no trivials</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def equacions_implicites(self,base=None,prime=0,aleatori=True):
    &#34;&#34;&#34;
    Retorna l&#39;equació implícita (dimensió 2) o el sistema d&#39;equacions implícites
    (dimensió 3) en la base &#34;base&#34;.
    Paràmetres:
        base: Base en la que calculem les equacions implícites
        prime: Quantes primes volem posar a les equacions
        aleatori: només s&#39;aplica a dimensió 3 i genera unes equacions implícites no trivials
    &#34;&#34;&#34;
    if base is None:
        a = Matriu.matriu_fila(self.u)
    else:
        a = Matriu.matriu_fila(self.u.components_en_base(base))
    l = a.nucli()
    if len(l) == 1:
        return EquacioLineal.coeficients(l[0],0,False,prime)
    a = Matriu.from_vectors_fila(l)
    b = Vector.nul(len(l))
    if aleatori:
        m = Matriu.amb_rang(f=2,c=2,r=2,maxim=3,mzeros=0)
        a = m * a
    return SistemaEquacions(a,b,prime=prime)</code></pre>
</details>
</dd>
<dt id="Algebra.RectaVectorial.ortogonal"><code class="name flex">
<span>def <span class="ident">ortogonal</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el suplementari ortogonal</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ortogonal(self):
    &#34;&#34;&#34;
    Retorna el suplementari ortogonal
    &#34;&#34;&#34;
    a = Matriu.from_vectors_fila([self.u])
    n = a.nucli()
    if len(n) == 1:
        return RectaVectorial(n[0])
    return PlaVectorial(n)</code></pre>
</details>
</dd>
<dt id="Algebra.RectaVectorial.projeccio_ortogonal"><code class="name flex">
<span>def <span class="ident">projeccio_ortogonal</span></span>(<span>self, u)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la projecció ortogonal del vector u sobre la recta.</p>
<h2 id="parametres">Paràmetres</h2>
<p>u: Vector</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def projeccio_ortogonal(self,u):
    &#34;&#34;&#34;
    Retorna la projecció ortogonal del vector u sobre la recta.
    Paràmetres:
      u: Vector
    &#34;&#34;&#34;
    if not isinstance(u,Vector):
        return None
    if u.dimensio != self.u.dimensio:
        return None
    v = self.u
    t = u.dot(v)/v.dot(v)
    return t * v</code></pre>
</details>
</dd>
<dt id="Algebra.RectaVectorial.simetric"><code class="name flex">
<span>def <span class="ident">simetric</span></span>(<span>self, u)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el simètric del vector u respecte a la recta.</p>
<h2 id="parametres">Paràmetres</h2>
<p>u: Vector</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simetric(self,u):
    &#34;&#34;&#34;
    Retorna el simètric del vector u respecte a la recta.
    Paràmetres:
      u: Vector
    &#34;&#34;&#34;
    if not isinstance(u,Vector):
        return None
    if u.dimensio != self.u.dimensio:
        return None
    return 2*self.projeccio_ortogonal(u) - u</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Algebra.ReferenciaAfi"><code class="flex name class">
<span>class <span class="ident">ReferenciaAfi</span></span>
<span>(</span><span>origen, base)</span>
</code></dt>
<dd>
<div class="desc"><p>Classe per treballar amb referències afins de P^n</p>
<h2 id="atributs">Atributs</h2>
<p>origen: origen de la referència (classe Punt)
base: base de la referència (classe Base)
dimensio: dimensió de l'espai corresponent</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReferenciaAfi(object):
    &#34;&#34;&#34;
    Classe per treballar amb referències afins de P^n
    Atributs:
        origen: origen de la referència (classe Punt)
        base: base de la referència (classe Base)
        dimensio: dimensió de l&#39;espai corresponent
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,origen,base):
        &#34;&#34;&#34;
        Constructor.
        Paràmetres:
            origen: origen de la referència
            base: base de la referència
        &#34;&#34;&#34;
        if not isinstance(origen,Punt):
            return None
        if not isinstance(base,Base):
            return None
        if origen.dimensio != base.dimensio:
            return None
        return super(ReferenciaAfi,cls).__new__(cls)
    #
    #
    #
    def __init__ (self,origen,base):
        self.origen = origen
        self.base = base
        self.dimensio = origen.dimensio
    #
    #
    #
    def __repr__(self):
        &#34;&#34;&#34;
        Retorna l&#39;expressió en LaTeX de la referència
        &#34;&#34;&#34;
        return f&#34;\\left\\{{{self.origen};{self.base.vectors_latex()}\\right\\}}&#34;
    #
    #
    #
    @classmethod
    def aleatoria(cls,dimensio=3,maxim=3,mzeros=0,unitaria=False):
        &#34;&#34;&#34;
        Retorna una referència aleatòria
        Paràmetres:
            dimensio: dimensió de l&#39;espai corresponent
            maxim: Màxim nombre que hi apareix
            mzeros: Màxim nombre de zeros que apareixen a la base
            unitaria: si és True la matriu del canvi de base tindrà determinant 1 o -1
        &#34;&#34;&#34;
        origen = Punt.aleatori(l=dimensio,maxim=maxim,nuls=False)
        m = Matriu.invertible(ordre=dimensio,maxim=maxim,mzeros=mzeros,unitaria=unitaria)
        base = Base.from_matriu(m)
        return cls(origen,base)
    #
    #
    #
    @classmethod
    def canonica(cls,dimensio=3):
        &#34;&#34;&#34;
        Retorna la referència canònica
        Paràmetres:
            dimensio: dimensió de l&#39;espai corresponent
        &#34;&#34;&#34;
        origen = Punt.nul(dimensio)
        base = Base.canonica(dimensio)
        return cls(origen,base)
    #
    #
    #
    def punt_de_coordenades(self,punt):
        &#34;&#34;&#34;
        Retorna un nou punt expressat en la referència canònica del
        punt que en aquesta referencia té coordenades &#34;punt&#34;
        Paràmetres:
            punt: coordenades d&#39;un punt en la referència actual
        &#34;&#34;&#34;
        if not isinstance(punt,Punt):
            return None
        if punt.dimensio != self.dimensio:
            return None
        if not self.base.unitaria:
            c = self.base.matriu()
        else:
            unitaris = [(1 / v.length()) * v for v in self.base.vecs]
            c = Matriu.from_vectors_columna(unitaris)
        p = self.origen + c * punt
        return Punt(p.components)
    #
    #
    #
    def coordenades_del_punt(self,punt,ref=None):
        &#34;&#34;&#34;
        Retorna un nou punt expressat en aquesta referència del punt
        que en la referència &#34;ref&#34; té coordenades &#34;punt&#34;.
        Si ref és None, serà la referència canònica
        Paràmetres:
            punt: coordenades en la referència &#34;ref&#34;
            ref: ReferenciaAfi
        &#34;&#34;&#34;
        if not isinstance(punt,Punt):
            return None
        if ref is not None:
            if not isinstance(ref,ReferenciaAfi):
                return None
            if ref.dimensio != punt.dimensio:
                return None
            pc = ref.punt_de_coordenades(punt)
        else:
            pc = punt
        p = self.base.components_del_vector(pc - self.origen)
        return Punt(self.base.components_del_vector(pc - self.origen).components)
    #
    #
    #
    def canvi_coordenades(self,prime1=0,prime2=1):
        &#34;&#34;&#34;
        Restorna en format latex l&#39;expressió del canvi de coordenades de la referència
        actual a la referència canònica
        Paràmetres:
            prime1: primes que s&#39;escriuran a les coordenades en la referència canònica
            prime2: primes que s&#39;escriuran a les coordenades en la referència actual
        &#34;&#34;&#34;
        if self.dimensio &lt;= 3:
            x, y, z = symbols(&#39;x y z&#39;)
            coords = [x,y,z]
        else:
            x1, x2, x3, x4, x5, x6, x7, x8 = symbols(&#39;x1 x2 x3 x4 x5 x6 x7 x8&#39;)
            coords = [x1, x2, x3, x4, x5, x6, x7, x8]
        coords = coords[0:self.dimensio]
        p1 = &#34;&#34;
        p2 = &#34;&#34;
        if prime1 &gt; 0:
            p1 = prime1 * &#34;&#39;&#34;
        if prime2 &gt; 0:
            p2 = prime2 * &#34;&#39;&#34;
        o = &#34; \\\\ &#34;.join([latex(k) + p1 for k in coords])
        d = &#34; \\\\ &#34;.join([latex(k) + p2 for k in coords])
        m = Matriu.matriu_columna(self.origen)
        s = &#34;\\begin{pmatrix}{c} &#34; + o + &#34;\\end{pmatrix} = \n&#34;
        s += f&#34;{m} + \n&#34;
        s += f&#34;{self.base.matriu()}\n&#34;
        s += &#34;\\begin{pmatrix}{c} &#34; + d + &#34;\\end{pmatrix}&#34;
        return s
    #
    #
    #
    def canvi_de_referencia_a_la_referencia(self,R,p1,p2):
        &#34;&#34;&#34;
        Retorna en format latex l&#39;expressió del canvi de coordenades de la referència
        actual a la referència R
        Paràmetres:
            p1: primes que s&#39;escriuran a les coordenades en la referència actual
            p2: primes que s&#39;escriuran a les coordenades en la referència R
        &#34;&#34;&#34;
        if not isinstance(R,ReferenciaAfi):
            return None
        if self.dimensio != R.dimensio:
            return None
        if self.dimensio &lt;= 3:
            x, y, z = symbols(&#39;x y z&#39;)
            coords = [x,y,z]
        else:
            x1, x2, x3, x4, x5, x6, x7, x8 = symbols(&#39;x1 x2 x3 x4 x5 x6 x7 x8&#39;)
            coords = [x1, x2, x3, x4, x5, x6, x7, x8]
        coords = coords[0:self.dimensio]
        o = R.coordenades_del_punt(Punt(0,0),self)
        c = R.base.matriu()
        d = self.base.matriu()
        A = c.inversa() * d
        ps1 = &#34;&#34;
        ps2 = &#34;&#34;
        if p1 &gt; 0:
            ps1 = p1 * &#34;&#39;&#34;
        if p2 &gt; 0:
            ps2 = p2 * &#34;&#39;&#34;
        cs = &#34; \\\\ &#34;.join([latex(k) + ps1 for k in coords])
        cr = &#34; \\\\ &#34;.join([latex(k) + ps2 for k in coords])
        m = Matriu.matriu_columna(o)
        s = &#34;\\begin{pmatrix}{c} &#34; + cr + &#34;\\end{pmatrix} = \n&#34;
        s += f&#34;{m} + \n&#34;
        s += f&#34;{A}\n&#34;
        s += &#34;\\begin{pmatrix}{c} &#34; + cs + &#34;\\end{pmatrix}&#34;
        return s
    #
    #
    #
    def referencia_inversa(self):
        &#34;&#34;&#34;
        Retorna una referència que es correspon amb el canvi de coordenades de
        de la referència canònica a l&#39;actual
        &#34;&#34;&#34;
        p = Punt.nul(self.dimensio)
        q = p.coordenades_en_referencia(self)
        m = self.base.matriu().inversa()
        b = Base.from_matriu(m)
        return ReferenciaAfi(q,b)
    #
    #
    #
    def vectors(self,unitaris=False):
        &#34;&#34;&#34;
        Retorna els vectors de la base de la referència
        Paràmetres:
            unitaris: si és True els retorna dividits per la seva longitud
        &#34;&#34;&#34;
        return self.base.vectors(unitaris)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="Algebra.ReferenciaAfi.aleatoria"><code class="name flex">
<span>def <span class="ident">aleatoria</span></span>(<span>dimensio=3, maxim=3, mzeros=0, unitaria=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna una referència aleatòria</p>
<h2 id="parametres">Paràmetres</h2>
<p>dimensio: dimensió de l'espai corresponent
maxim: Màxim nombre que hi apareix
mzeros: Màxim nombre de zeros que apareixen a la base
unitaria: si és True la matriu del canvi de base tindrà determinant 1 o -1</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def aleatoria(cls,dimensio=3,maxim=3,mzeros=0,unitaria=False):
    &#34;&#34;&#34;
    Retorna una referència aleatòria
    Paràmetres:
        dimensio: dimensió de l&#39;espai corresponent
        maxim: Màxim nombre que hi apareix
        mzeros: Màxim nombre de zeros que apareixen a la base
        unitaria: si és True la matriu del canvi de base tindrà determinant 1 o -1
    &#34;&#34;&#34;
    origen = Punt.aleatori(l=dimensio,maxim=maxim,nuls=False)
    m = Matriu.invertible(ordre=dimensio,maxim=maxim,mzeros=mzeros,unitaria=unitaria)
    base = Base.from_matriu(m)
    return cls(origen,base)</code></pre>
</details>
</dd>
<dt id="Algebra.ReferenciaAfi.canonica"><code class="name flex">
<span>def <span class="ident">canonica</span></span>(<span>dimensio=3)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la referència canònica</p>
<h2 id="parametres">Paràmetres</h2>
<p>dimensio: dimensió de l'espai corresponent</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def canonica(cls,dimensio=3):
    &#34;&#34;&#34;
    Retorna la referència canònica
    Paràmetres:
        dimensio: dimensió de l&#39;espai corresponent
    &#34;&#34;&#34;
    origen = Punt.nul(dimensio)
    base = Base.canonica(dimensio)
    return cls(origen,base)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Algebra.ReferenciaAfi.canvi_coordenades"><code class="name flex">
<span>def <span class="ident">canvi_coordenades</span></span>(<span>self, prime1=0, prime2=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Restorna en format latex l'expressió del canvi de coordenades de la referència
actual a la referència canònica</p>
<h2 id="parametres">Paràmetres</h2>
<p>prime1: primes que s'escriuran a les coordenades en la referència canònica
prime2: primes que s'escriuran a les coordenades en la referència actual</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def canvi_coordenades(self,prime1=0,prime2=1):
    &#34;&#34;&#34;
    Restorna en format latex l&#39;expressió del canvi de coordenades de la referència
    actual a la referència canònica
    Paràmetres:
        prime1: primes que s&#39;escriuran a les coordenades en la referència canònica
        prime2: primes que s&#39;escriuran a les coordenades en la referència actual
    &#34;&#34;&#34;
    if self.dimensio &lt;= 3:
        x, y, z = symbols(&#39;x y z&#39;)
        coords = [x,y,z]
    else:
        x1, x2, x3, x4, x5, x6, x7, x8 = symbols(&#39;x1 x2 x3 x4 x5 x6 x7 x8&#39;)
        coords = [x1, x2, x3, x4, x5, x6, x7, x8]
    coords = coords[0:self.dimensio]
    p1 = &#34;&#34;
    p2 = &#34;&#34;
    if prime1 &gt; 0:
        p1 = prime1 * &#34;&#39;&#34;
    if prime2 &gt; 0:
        p2 = prime2 * &#34;&#39;&#34;
    o = &#34; \\\\ &#34;.join([latex(k) + p1 for k in coords])
    d = &#34; \\\\ &#34;.join([latex(k) + p2 for k in coords])
    m = Matriu.matriu_columna(self.origen)
    s = &#34;\\begin{pmatrix}{c} &#34; + o + &#34;\\end{pmatrix} = \n&#34;
    s += f&#34;{m} + \n&#34;
    s += f&#34;{self.base.matriu()}\n&#34;
    s += &#34;\\begin{pmatrix}{c} &#34; + d + &#34;\\end{pmatrix}&#34;
    return s</code></pre>
</details>
</dd>
<dt id="Algebra.ReferenciaAfi.canvi_de_referencia_a_la_referencia"><code class="name flex">
<span>def <span class="ident">canvi_de_referencia_a_la_referencia</span></span>(<span>self, R, p1, p2)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna en format latex l'expressió del canvi de coordenades de la referència
actual a la referència R</p>
<h2 id="parametres">Paràmetres</h2>
<p>p1: primes que s'escriuran a les coordenades en la referència actual
p2: primes que s'escriuran a les coordenades en la referència R</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def canvi_de_referencia_a_la_referencia(self,R,p1,p2):
    &#34;&#34;&#34;
    Retorna en format latex l&#39;expressió del canvi de coordenades de la referència
    actual a la referència R
    Paràmetres:
        p1: primes que s&#39;escriuran a les coordenades en la referència actual
        p2: primes que s&#39;escriuran a les coordenades en la referència R
    &#34;&#34;&#34;
    if not isinstance(R,ReferenciaAfi):
        return None
    if self.dimensio != R.dimensio:
        return None
    if self.dimensio &lt;= 3:
        x, y, z = symbols(&#39;x y z&#39;)
        coords = [x,y,z]
    else:
        x1, x2, x3, x4, x5, x6, x7, x8 = symbols(&#39;x1 x2 x3 x4 x5 x6 x7 x8&#39;)
        coords = [x1, x2, x3, x4, x5, x6, x7, x8]
    coords = coords[0:self.dimensio]
    o = R.coordenades_del_punt(Punt(0,0),self)
    c = R.base.matriu()
    d = self.base.matriu()
    A = c.inversa() * d
    ps1 = &#34;&#34;
    ps2 = &#34;&#34;
    if p1 &gt; 0:
        ps1 = p1 * &#34;&#39;&#34;
    if p2 &gt; 0:
        ps2 = p2 * &#34;&#39;&#34;
    cs = &#34; \\\\ &#34;.join([latex(k) + ps1 for k in coords])
    cr = &#34; \\\\ &#34;.join([latex(k) + ps2 for k in coords])
    m = Matriu.matriu_columna(o)
    s = &#34;\\begin{pmatrix}{c} &#34; + cr + &#34;\\end{pmatrix} = \n&#34;
    s += f&#34;{m} + \n&#34;
    s += f&#34;{A}\n&#34;
    s += &#34;\\begin{pmatrix}{c} &#34; + cs + &#34;\\end{pmatrix}&#34;
    return s</code></pre>
</details>
</dd>
<dt id="Algebra.ReferenciaAfi.coordenades_del_punt"><code class="name flex">
<span>def <span class="ident">coordenades_del_punt</span></span>(<span>self, punt, ref=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna un nou punt expressat en aquesta referència del punt
que en la referència "ref" té coordenades "punt".
Si ref és None, serà la referència canònica</p>
<h2 id="parametres">Paràmetres</h2>
<p>punt: coordenades en la referència "ref"
ref: ReferenciaAfi</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coordenades_del_punt(self,punt,ref=None):
    &#34;&#34;&#34;
    Retorna un nou punt expressat en aquesta referència del punt
    que en la referència &#34;ref&#34; té coordenades &#34;punt&#34;.
    Si ref és None, serà la referència canònica
    Paràmetres:
        punt: coordenades en la referència &#34;ref&#34;
        ref: ReferenciaAfi
    &#34;&#34;&#34;
    if not isinstance(punt,Punt):
        return None
    if ref is not None:
        if not isinstance(ref,ReferenciaAfi):
            return None
        if ref.dimensio != punt.dimensio:
            return None
        pc = ref.punt_de_coordenades(punt)
    else:
        pc = punt
    p = self.base.components_del_vector(pc - self.origen)
    return Punt(self.base.components_del_vector(pc - self.origen).components)</code></pre>
</details>
</dd>
<dt id="Algebra.ReferenciaAfi.punt_de_coordenades"><code class="name flex">
<span>def <span class="ident">punt_de_coordenades</span></span>(<span>self, punt)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna un nou punt expressat en la referència canònica del
punt que en aquesta referencia té coordenades "punt"</p>
<h2 id="parametres">Paràmetres</h2>
<p>punt: coordenades d'un punt en la referència actual</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def punt_de_coordenades(self,punt):
    &#34;&#34;&#34;
    Retorna un nou punt expressat en la referència canònica del
    punt que en aquesta referencia té coordenades &#34;punt&#34;
    Paràmetres:
        punt: coordenades d&#39;un punt en la referència actual
    &#34;&#34;&#34;
    if not isinstance(punt,Punt):
        return None
    if punt.dimensio != self.dimensio:
        return None
    if not self.base.unitaria:
        c = self.base.matriu()
    else:
        unitaris = [(1 / v.length()) * v for v in self.base.vecs]
        c = Matriu.from_vectors_columna(unitaris)
    p = self.origen + c * punt
    return Punt(p.components)</code></pre>
</details>
</dd>
<dt id="Algebra.ReferenciaAfi.referencia_inversa"><code class="name flex">
<span>def <span class="ident">referencia_inversa</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna una referència que es correspon amb el canvi de coordenades de
de la referència canònica a l'actual</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def referencia_inversa(self):
    &#34;&#34;&#34;
    Retorna una referència que es correspon amb el canvi de coordenades de
    de la referència canònica a l&#39;actual
    &#34;&#34;&#34;
    p = Punt.nul(self.dimensio)
    q = p.coordenades_en_referencia(self)
    m = self.base.matriu().inversa()
    b = Base.from_matriu(m)
    return ReferenciaAfi(q,b)</code></pre>
</details>
</dd>
<dt id="Algebra.ReferenciaAfi.vectors"><code class="name flex">
<span>def <span class="ident">vectors</span></span>(<span>self, unitaris=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna els vectors de la base de la referència</p>
<h2 id="parametres">Paràmetres</h2>
<p>unitaris: si és True els retorna dividits per la seva longitud</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vectors(self,unitaris=False):
    &#34;&#34;&#34;
    Retorna els vectors de la base de la referència
    Paràmetres:
        unitaris: si és True els retorna dividits per la seva longitud
    &#34;&#34;&#34;
    return self.base.vectors(unitaris)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Algebra.SistemaEquacions"><code class="flex name class">
<span>class <span class="ident">SistemaEquacions</span></span>
<span>(</span><span>a, b, unknowns=None, prime=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Classe per treballar amb sistemes d'equacions lineals</p>
<h2 id="atributs">Atributs</h2>
<p>A: matriu dels coeficients de les incógnites
B: vector de termes independents
equacions: llista de EquacioLineal
nombre: nombre d'equacions
solucio: solucio del sistema d'equacions
secundaries: incògnites secundàries a la solució
parametrica: solucio paramètrica del sistema d'equacions
parametres: paràmetres que apareixen a la solució paramètrica
unknowns: llista d'incògnites
prime: nombre de primes que escriurem a l'equació</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SistemaEquacions:
    &#34;&#34;&#34;
    Classe per treballar amb sistemes d&#39;equacions lineals
    Atributs:
      A: matriu dels coeficients de les incógnites
      B: vector de termes independents
      equacions: llista de EquacioLineal
      nombre: nombre d&#39;equacions
      solucio: solucio del sistema d&#39;equacions
      secundaries: incògnites secundàries a la solució
      parametrica: solucio paramètrica del sistema d&#39;equacions
      parametres: paràmetres que apareixen a la solució paramètrica
      unknowns: llista d&#39;incògnites
      prime: nombre de primes que escriurem a l&#39;equació
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,a,b,unknowns=None,prime=0):
        &#34;&#34;&#34;
        Constructor.
        Paràmetres:
          a: matriu dels coeficients de les incògnites
          b: Termes independents
        &#34;&#34;&#34;
        if not isinstance(a,Matriu):
            return None
        if not isinstance(b,Vector):
            return None
        if a.files != b.dimensio:
            return None
        if unknowns is not None:
            if not (isinstance(unknowns,list) or isinstance(unknowns,tuple)):
                return None
            if len(unknowns) != a.columnes:
                return None
        return super(SistemaEquacions,cls).__new__(cls)
    #
    #
    #
    def __init__(self,a,b,unknowns=None,prime=0):
        self.A = a
        self.B = b
        self.solucio = None
        self.parametrica = None
        self.parametres = []
        self.secundaries = []
        eq = []
        files = a.vectors_fila()
        for k in range(self.A.files):
            eq.append(EquacioLineal.coeficients(files[k],b[k],amp=True,prime=0))
        self.equacions = eq
        self.nombre = len(eq)
        if unknowns is not None:
            self.unknowns = unknowns
        else:
            if self.A.columnes &lt;= 4:
                x, y, z, t = symbols(&#39;x y z t&#39;)
                unknowns = [x,y,z,t]
            else:
                x1, x2, x3, x4, x5, x6, x7, x8 = symbols(&#39;x1 x2 x3 x4 x5 x6 x7 x8&#39;)
                unknowns = [x1,x2,x3,x4,x5,x6,x7,x8]
            self.unknowns = unknowns[0:self.A.columnes]
        self.prime = prime
    #
    #
    #
    @classmethod
    def from_equacions(cls,eqs,nombre,prime=0):
        &#34;&#34;&#34;
        Retorna un sistema d&#39;equacions amb equacions &#34;eqs&#34;
        Paràmetres:
            eqs: llista de EquacioLineal
            nombre: nombre d&#39;incògnites
            prime: nombre de primes que s&#39;escriuran a les incògnites
        &#34;&#34;&#34;
        if nombre &lt;= 4:
            x, y, z, t = symbols(&#39;x y z t&#39;)
            unknowns = [x,y,z,t]
        else:
            x1, x2, x3, x4, x5, x6, x7, x8 = symbols(&#39;x1 x2 x3 x4 x5 x6 x7 x8&#39;)
            unknowns = [x1,x2,x3,x4,x5,x6,x7,x8]
        unknowns = unknowns[0:nombre]
        t = []
        vecs = []
        for e in eqs:
            if isinstance(e,EquacioLineal):
                d = e.equacio.as_coefficients_dict()
            else:
                d = e.as_coefficients_dict()
            c = []
            for k in unknowns:
                c.append(d[k])
            t.append(-d[1])
            vecs.append(Vector(c))
        a = Matriu.from_vectors_fila(vecs)
        b = Vector(t)
        return cls(a,b,prime=prime)
    #
    #
    #
    def __repr__(self):
        &#34;&#34;&#34;
        Retorna l&#39;expressió en latex del sistema d&#39;equacions
        &#34;&#34;&#34;
        p = &#34;&#34;
        eqs = list(map(str,self.equacions))
        if self.prime &gt; 0:
            p = self.prime * &#34;&#39;&#34;
        if len(eqs) == 0:
            return &#34;&#34;
        if len(eqs) == 1:
            for k in self.unknowns:
                eqs[0] = eqs[0].replace(latex(k),latex(k) + p)
            return eqs[0].replace(&#39;&amp;&#39;,&#39;&#39;)
        eqs = &#34; \\\\ &#34;.join(eqs)
        for k in self.unknowns:
            eqs = eqs.replace(latex(k),latex(k) + p)
        return f&#34;\\left.\\aligned {eqs} \\endaligned\\;\\right\\}}&#34;
    #
    #
    #
    def matriu_incognites(self):
        &#34;&#34;&#34;
        Retorna la matriu dels coeficients de les incògnites expressada
        en LaTeX
        &#34;&#34;&#34;
        return f&#34;{self.A}&#34;
    #
    #
    #
    def matriu_ampliada(self):
        &#34;&#34;&#34;
        Retorna la matriu ampliada del sistema d&#39;equacions expressada
        en LaTeX
        &#34;&#34;&#34;
        c = self.A.inserta_columna(self.A.columnes,self.B)
        return matriu_latex(c.matriu,ampliada=True)
    #
    #
    #
    def resol(self,unknowns=None):
        &#34;&#34;&#34;
        Resol el sistema d&#39;equacions utilitzant la funció linsolve del sympy.
        El resultat és una llista d&#39;expressions on hi poden aparèixer les
        incògnites del sistema com a paràmetres
        &#34;&#34;&#34;
        t1, t2, t3, t4, t5, t6, t7, t8 = symbols(&#39;t1 t2 t3 t4 t5 t6 t7 t8&#39;)
        params = [t1,t2,t3,t4,t5,t6,t7,t8]
        count = 0
        subs = {}
        system = (self.A.matriu,Matrix(self.B.dimensio,1,self.B.components))
        X = Vector(self.unknowns)
        system = self.A * X - self.B
        if unknowns is not None:
            s = solve(system.components,*unknowns)
        else:
            s = solve(system.components,*self.unknowns)
        self.solucio = []
        self.parametres = []
        self.secundaries = []
        for k in self.unknowns:
            try:
                self.solucio.append(s[k])
            except:
                self.solucio.append(k)
                subs[k] = params[count]
                self.parametres.append(subs[k])
                self.secundaries.append(k)
                count += 1
        self.parametrica = []
        for k in self.solucio:
            for u, v in subs.items():
                k = k.subs(u,v)
            self.parametrica.append(k)
        return self.solucio
    #
    #
    #
    def solucio_latex(self,linia=False,unknowns=None):
        &#34;&#34;&#34;
        Retorna l&#39;expressió en LaTex de la solució del sistema d&#39;equacions
        Paràmetres:
            linia: si és True escriu la solució en una línia, en cas contrari
                   ho fa com un sistema d&#39;equacions
        &#34;&#34;&#34;
        if self.solucio is None:
            self.resol(unknowns)
        if len(self.solucio) == 0:
            return &#34;&#34;
        eqs = []
        for i in range(self.A.columnes):
            if self.solucio[i] == self.unknowns[i]:
                continue
            d = self.solucio[i].as_coefficients_dict()
            l = list(d.values())
            m = []
            for k in range(len(l)):
                if isinstance(l[k],Rational):
                    m.append(l[k].q)
                elif isinstance(l[k],int):
                    pass
                else:
                    return &#34;&#34;
            if len(m) == 0:
                factor = 1
            else:
                factor = mcm_llista(m)
            eq = 0
            for k in d.keys():
                d[k] = factor * d[k]
                eq += d[k] * k
            if factor == 1:
                eqs.append(f&#34;{self.unknowns[i]} &amp;= {mylatex(eq)}&#34;)
            else:
                eqs.append(f&#34;{self.unknowns[i]} &amp;= \\frac{{{mylatex(eq)}}}{{{factor}}}&#34;)
        if len(eqs) == 1:
            return eqs[0].replace(&#39;&#39;,&#39;&#39;)
        if not linia:
            eqs = &#34; \\\\ &#34;.join(eqs)
            return f&#34;\\left.\\aligned {eqs} \\endaligned\\;\\right\\}}&#34;
        eqs = &#34; $, $&#34;.join(eqs)
        eqs = eqs.replace(&#39;&amp;&#39;,&#39;&#39;)
        return f&#34;$ {eqs} $&#34;</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="Algebra.SistemaEquacions.from_equacions"><code class="name flex">
<span>def <span class="ident">from_equacions</span></span>(<span>eqs, nombre, prime=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna un sistema d'equacions amb equacions "eqs"</p>
<h2 id="parametres">Paràmetres</h2>
<p>eqs: llista de EquacioLineal
nombre: nombre d'incògnites
prime: nombre de primes que s'escriuran a les incògnites</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_equacions(cls,eqs,nombre,prime=0):
    &#34;&#34;&#34;
    Retorna un sistema d&#39;equacions amb equacions &#34;eqs&#34;
    Paràmetres:
        eqs: llista de EquacioLineal
        nombre: nombre d&#39;incògnites
        prime: nombre de primes que s&#39;escriuran a les incògnites
    &#34;&#34;&#34;
    if nombre &lt;= 4:
        x, y, z, t = symbols(&#39;x y z t&#39;)
        unknowns = [x,y,z,t]
    else:
        x1, x2, x3, x4, x5, x6, x7, x8 = symbols(&#39;x1 x2 x3 x4 x5 x6 x7 x8&#39;)
        unknowns = [x1,x2,x3,x4,x5,x6,x7,x8]
    unknowns = unknowns[0:nombre]
    t = []
    vecs = []
    for e in eqs:
        if isinstance(e,EquacioLineal):
            d = e.equacio.as_coefficients_dict()
        else:
            d = e.as_coefficients_dict()
        c = []
        for k in unknowns:
            c.append(d[k])
        t.append(-d[1])
        vecs.append(Vector(c))
    a = Matriu.from_vectors_fila(vecs)
    b = Vector(t)
    return cls(a,b,prime=prime)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Algebra.SistemaEquacions.matriu_ampliada"><code class="name flex">
<span>def <span class="ident">matriu_ampliada</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la matriu ampliada del sistema d'equacions expressada
en LaTeX</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def matriu_ampliada(self):
    &#34;&#34;&#34;
    Retorna la matriu ampliada del sistema d&#39;equacions expressada
    en LaTeX
    &#34;&#34;&#34;
    c = self.A.inserta_columna(self.A.columnes,self.B)
    return matriu_latex(c.matriu,ampliada=True)</code></pre>
</details>
</dd>
<dt id="Algebra.SistemaEquacions.matriu_incognites"><code class="name flex">
<span>def <span class="ident">matriu_incognites</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la matriu dels coeficients de les incògnites expressada
en LaTeX</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def matriu_incognites(self):
    &#34;&#34;&#34;
    Retorna la matriu dels coeficients de les incògnites expressada
    en LaTeX
    &#34;&#34;&#34;
    return f&#34;{self.A}&#34;</code></pre>
</details>
</dd>
<dt id="Algebra.SistemaEquacions.resol"><code class="name flex">
<span>def <span class="ident">resol</span></span>(<span>self, unknowns=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Resol el sistema d'equacions utilitzant la funció linsolve del sympy.
El resultat és una llista d'expressions on hi poden aparèixer les
incògnites del sistema com a paràmetres</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resol(self,unknowns=None):
    &#34;&#34;&#34;
    Resol el sistema d&#39;equacions utilitzant la funció linsolve del sympy.
    El resultat és una llista d&#39;expressions on hi poden aparèixer les
    incògnites del sistema com a paràmetres
    &#34;&#34;&#34;
    t1, t2, t3, t4, t5, t6, t7, t8 = symbols(&#39;t1 t2 t3 t4 t5 t6 t7 t8&#39;)
    params = [t1,t2,t3,t4,t5,t6,t7,t8]
    count = 0
    subs = {}
    system = (self.A.matriu,Matrix(self.B.dimensio,1,self.B.components))
    X = Vector(self.unknowns)
    system = self.A * X - self.B
    if unknowns is not None:
        s = solve(system.components,*unknowns)
    else:
        s = solve(system.components,*self.unknowns)
    self.solucio = []
    self.parametres = []
    self.secundaries = []
    for k in self.unknowns:
        try:
            self.solucio.append(s[k])
        except:
            self.solucio.append(k)
            subs[k] = params[count]
            self.parametres.append(subs[k])
            self.secundaries.append(k)
            count += 1
    self.parametrica = []
    for k in self.solucio:
        for u, v in subs.items():
            k = k.subs(u,v)
        self.parametrica.append(k)
    return self.solucio</code></pre>
</details>
</dd>
<dt id="Algebra.SistemaEquacions.solucio_latex"><code class="name flex">
<span>def <span class="ident">solucio_latex</span></span>(<span>self, linia=False, unknowns=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna l'expressió en LaTex de la solució del sistema d'equacions</p>
<h2 id="parametres">Paràmetres</h2>
<p>linia: si és True escriu la solució en una línia, en cas contrari
ho fa com un sistema d'equacions</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def solucio_latex(self,linia=False,unknowns=None):
    &#34;&#34;&#34;
    Retorna l&#39;expressió en LaTex de la solució del sistema d&#39;equacions
    Paràmetres:
        linia: si és True escriu la solució en una línia, en cas contrari
               ho fa com un sistema d&#39;equacions
    &#34;&#34;&#34;
    if self.solucio is None:
        self.resol(unknowns)
    if len(self.solucio) == 0:
        return &#34;&#34;
    eqs = []
    for i in range(self.A.columnes):
        if self.solucio[i] == self.unknowns[i]:
            continue
        d = self.solucio[i].as_coefficients_dict()
        l = list(d.values())
        m = []
        for k in range(len(l)):
            if isinstance(l[k],Rational):
                m.append(l[k].q)
            elif isinstance(l[k],int):
                pass
            else:
                return &#34;&#34;
        if len(m) == 0:
            factor = 1
        else:
            factor = mcm_llista(m)
        eq = 0
        for k in d.keys():
            d[k] = factor * d[k]
            eq += d[k] * k
        if factor == 1:
            eqs.append(f&#34;{self.unknowns[i]} &amp;= {mylatex(eq)}&#34;)
        else:
            eqs.append(f&#34;{self.unknowns[i]} &amp;= \\frac{{{mylatex(eq)}}}{{{factor}}}&#34;)
    if len(eqs) == 1:
        return eqs[0].replace(&#39;&#39;,&#39;&#39;)
    if not linia:
        eqs = &#34; \\\\ &#34;.join(eqs)
        return f&#34;\\left.\\aligned {eqs} \\endaligned\\;\\right\\}}&#34;
    eqs = &#34; $, $&#34;.join(eqs)
    eqs = eqs.replace(&#39;&amp;&#39;,&#39;&#39;)
    return f&#34;$ {eqs} $&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Algebra.SubespaiVectorial"><code class="flex name class">
<span>class <span class="ident">SubespaiVectorial</span></span>
<span>(</span><span>vecs, basern=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Classe per treballar amb subespais vectorials</p>
<h2 id="atributs">Atributs</h2>
<p>generadors: generadors del subespai
base: base del subespai
dimensio: dimensio del subespai
espai: n si és un suespai de R^n</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SubespaiVectorial(object):
    &#34;&#34;&#34;
    Classe per treballar amb subespais vectorials
    Atributs:
       generadors: generadors del subespai
       base: base del subespai
       dimensio: dimensio del subespai
       espai: n si és un suespai de R^n
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,vecs,basern=None):
        &#34;&#34;&#34;
        Constructor.
        Retorna el subespai vectorial generat per una llista de vectors
        Paràmetres:
           vecs: llista de vectors
           basern: base en la que estan expressats els vectors
        &#34;&#34;&#34;
        a = Matriu.from_vectors_columna(vecs)
        if a is None:
            return None
        if basern is not None:
            if not isinstance(basern,Base):
                return None
            if basern.dimensio != a.files:
                return None
        return super(SubespaiVectorial,cls).__new__(cls)
    #
    #
    #
    def __init__(self,vecs,basern=None):
        if basern is None:
            for k in vecs:
                k.simplificar()
            self.generadors = [k for k in vecs]
        else:
            v = [basern.vector_de_components(k) for k in vecs]
            for k in v:
                k.simplificar()
            self.generadors = [k for k in v]
        a = Matriu.from_vectors_columna(self.generadors)
        L, U, _ = a.matriu.LUdecomposition()
        files = Matriu(U).vectors_fila()
        self.base = []
        for f in files:
            k = primer_no_nul(f.components)
            if k is not None:
                self.base.append(self.generadors[k])
        self.dimensio = len(self.base)
        self.espai = self.generadors[0].dimensio
    #
    #
    #
    @classmethod
    def from_equacions_implicites(cls,eqs,basern=None):
        &#34;&#34;&#34;
        Retorna el subespai vectorial que té equacions implícites &#34;eqs&#34;
        Paràmetres:
            eqs: equacions implícites (classe SistemaEquacions)
            basern: Base de R^n
        &#34;&#34;&#34;
        if basern is None:
            return cls(eqs.A.nucli())
        c = [basern.vector_de_components(u) for u in eqs.A.nucli()]
        return cls(c)
    #
    #
    #
    @classmethod
    def from_equacio_implicita(cls,eq,basern=None):
        &#34;&#34;&#34;
        Retorna el subespai vectorial que té equació implícita &#34;eq&#34;
        Paràmetres:
            eqs: equació implícita (classe EquacioLineal)
            basern: Base de R^n
        &#34;&#34;&#34;
        if not isinstance(eq,EquacioLineal):
            return None
        s = eq.to_sistema_equacions()
        return cls.from_equacions_implicites(s,basern)
    #
    #
    #
    def es_zero(self):
        &#34;&#34;&#34;
        Retorna True si és el subespai {0}
        &#34;&#34;&#34;
        return len(self.base) == 0
    #
    #
    #
    def es_total(self):
        &#34;&#34;&#34;
        Retorna True si és el subespai R^n
        &#34;&#34;&#34;
        return len(self.base) == self.espai
    #
    #
    #
    def equacions_implicites(self,basern=None,prime=0):
        &#34;&#34;&#34;
        Retorna unes equacions implícites del subespai
        Paràmetres:
            basern: base en la que s&#39;escriuran les equacions implícites
            prime: nombre de primes a les incògnites
        &#34;&#34;&#34;
        if self.es_total():
            return None
        b = Vector.nul(self.espai)
        if basern is None:
            a = Matriu.from_vectors_columna(self.base)
        else:
            c = [v.components_en_base(basern) for v in self.base]
            a = Matriu.from_vectors_columna(c)
        p = EquacionsParametriques(a,b)
        return (p.eliminar_parametres(prime))
    #
    #
    #
    def suplementari_ortogonal(self):
        &#34;&#34;&#34;
        Retorna el suplementari ortogonal
        &#34;&#34;&#34;
        a = Matriu.from_vectors_fila(self.base)
        return SubespaiVectorial(a.nucli())
    #
    #
    #
    def base_ortogonal(self):
        &#34;&#34;&#34;
        Retorna una base ortogonal del subespai
        &#34;&#34;&#34;
        if self.dimensio == 0:
            return None
        if len(self.base) == 1:
            return self.base
        L = []
        for b in self.base:
            a = Matriu.from_vectors_columna([b])
            L.append(a.matriu)
        Q = GramSchmidt(L)
        base = []
        for m in Q:
            m = Matriu(m)
            v = m.vectors_columna()[0]
            v.simplificar()
            base.append(v)
        return base
    #
    #
    #
    def amplia_base(self,unitaria=False):
        &#34;&#34;&#34;
        Retorna una base ortogonal amb orientació positiva de R^n
        que comença amb una base del subespai
        Paràmetres:
            unitaria: si és True, retorna una base ortonormal
        &#34;&#34;&#34;
        if self.es_total():
            b = Base(self.base_ortogonal(),unitaria)
        else:
            h = self.suplementari_ortogonal()
            b = Base(self.base_ortogonal() + h.base_ortogonal(),unitaria)
        b.orientacio_positiva()
        return b
    #
    #
    #
    def amplia_base_suplementari(self,unitaria=False):
        &#34;&#34;&#34;
        Retorna una base ortogonal amb orientació positiva de R^n
        que comença amb una base del suplementari ortogonal del subespai
        Paràmetres:
            unitaria: si és True, retorna una base ortonormal
        &#34;&#34;&#34;
        h = self.suplementari_ortogonal()
        b = Base(h.base_ortogonal() + self.base_ortogonal(),unitaria)
        b.orientacio_positiva()
        return b
    #
    #
    #
    def projeccio_ortogonal(self,u):
        &#34;&#34;&#34;
        Retorna la projeccio ortogonal del vector u sobre el subespai
        Parametres:
          u: Vector
        &#34;&#34;&#34;
        if not isinstance(u,Vector):
            return None
        if u.dimensio != self.espai:
            return None
        base = self.base_ortogonal()
        ts = [Rational(u.dot(v),v.dot(v)) for v in base]
        p = Vector.nul(self.espai)
        for i in range(len(base)):
            p += ts[i]*base[i]
        return p
    #
    #
    #
    def simetric(self,u):
        &#34;&#34;&#34;
        Retorna el simètric del vector u sobre respecte al subespai
        Parametres:
          u: Vector
        &#34;&#34;&#34;
        if not isinstance(u,Vector):
            return None
        if u.dimensio != self.espai:
            return None
        return 2*self.projeccio_ortogonal(u) - u
    #
    #
    #
    def __repr__(self):
        &#34;&#34;&#34;
        Retorna l&#39;expressió en latex del subespai
        &#34;&#34;&#34;
        base = &#34;,&#34;.join([v.latex(False) for v in self.base])
        return f&#34;&lt;{base}&gt;&#34;</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="Algebra.SubespaiVectorial.from_equacio_implicita"><code class="name flex">
<span>def <span class="ident">from_equacio_implicita</span></span>(<span>eq, basern=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el subespai vectorial que té equació implícita "eq"</p>
<h2 id="parametres">Paràmetres</h2>
<p>eqs: equació implícita (classe EquacioLineal)
basern: Base de R^n</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_equacio_implicita(cls,eq,basern=None):
    &#34;&#34;&#34;
    Retorna el subespai vectorial que té equació implícita &#34;eq&#34;
    Paràmetres:
        eqs: equació implícita (classe EquacioLineal)
        basern: Base de R^n
    &#34;&#34;&#34;
    if not isinstance(eq,EquacioLineal):
        return None
    s = eq.to_sistema_equacions()
    return cls.from_equacions_implicites(s,basern)</code></pre>
</details>
</dd>
<dt id="Algebra.SubespaiVectorial.from_equacions_implicites"><code class="name flex">
<span>def <span class="ident">from_equacions_implicites</span></span>(<span>eqs, basern=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el subespai vectorial que té equacions implícites "eqs"</p>
<h2 id="parametres">Paràmetres</h2>
<p>eqs: equacions implícites (classe SistemaEquacions)
basern: Base de R^n</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_equacions_implicites(cls,eqs,basern=None):
    &#34;&#34;&#34;
    Retorna el subespai vectorial que té equacions implícites &#34;eqs&#34;
    Paràmetres:
        eqs: equacions implícites (classe SistemaEquacions)
        basern: Base de R^n
    &#34;&#34;&#34;
    if basern is None:
        return cls(eqs.A.nucli())
    c = [basern.vector_de_components(u) for u in eqs.A.nucli()]
    return cls(c)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Algebra.SubespaiVectorial.amplia_base"><code class="name flex">
<span>def <span class="ident">amplia_base</span></span>(<span>self, unitaria=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna una base ortogonal amb orientació positiva de R^n
que comença amb una base del subespai</p>
<h2 id="parametres">Paràmetres</h2>
<p>unitaria: si és True, retorna una base ortonormal</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def amplia_base(self,unitaria=False):
    &#34;&#34;&#34;
    Retorna una base ortogonal amb orientació positiva de R^n
    que comença amb una base del subespai
    Paràmetres:
        unitaria: si és True, retorna una base ortonormal
    &#34;&#34;&#34;
    if self.es_total():
        b = Base(self.base_ortogonal(),unitaria)
    else:
        h = self.suplementari_ortogonal()
        b = Base(self.base_ortogonal() + h.base_ortogonal(),unitaria)
    b.orientacio_positiva()
    return b</code></pre>
</details>
</dd>
<dt id="Algebra.SubespaiVectorial.amplia_base_suplementari"><code class="name flex">
<span>def <span class="ident">amplia_base_suplementari</span></span>(<span>self, unitaria=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna una base ortogonal amb orientació positiva de R^n
que comença amb una base del suplementari ortogonal del subespai</p>
<h2 id="parametres">Paràmetres</h2>
<p>unitaria: si és True, retorna una base ortonormal</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def amplia_base_suplementari(self,unitaria=False):
    &#34;&#34;&#34;
    Retorna una base ortogonal amb orientació positiva de R^n
    que comença amb una base del suplementari ortogonal del subespai
    Paràmetres:
        unitaria: si és True, retorna una base ortonormal
    &#34;&#34;&#34;
    h = self.suplementari_ortogonal()
    b = Base(h.base_ortogonal() + self.base_ortogonal(),unitaria)
    b.orientacio_positiva()
    return b</code></pre>
</details>
</dd>
<dt id="Algebra.SubespaiVectorial.base_ortogonal"><code class="name flex">
<span>def <span class="ident">base_ortogonal</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna una base ortogonal del subespai</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def base_ortogonal(self):
    &#34;&#34;&#34;
    Retorna una base ortogonal del subespai
    &#34;&#34;&#34;
    if self.dimensio == 0:
        return None
    if len(self.base) == 1:
        return self.base
    L = []
    for b in self.base:
        a = Matriu.from_vectors_columna([b])
        L.append(a.matriu)
    Q = GramSchmidt(L)
    base = []
    for m in Q:
        m = Matriu(m)
        v = m.vectors_columna()[0]
        v.simplificar()
        base.append(v)
    return base</code></pre>
</details>
</dd>
<dt id="Algebra.SubespaiVectorial.equacions_implicites"><code class="name flex">
<span>def <span class="ident">equacions_implicites</span></span>(<span>self, basern=None, prime=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna unes equacions implícites del subespai</p>
<h2 id="parametres">Paràmetres</h2>
<p>basern: base en la que s'escriuran les equacions implícites
prime: nombre de primes a les incògnites</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def equacions_implicites(self,basern=None,prime=0):
    &#34;&#34;&#34;
    Retorna unes equacions implícites del subespai
    Paràmetres:
        basern: base en la que s&#39;escriuran les equacions implícites
        prime: nombre de primes a les incògnites
    &#34;&#34;&#34;
    if self.es_total():
        return None
    b = Vector.nul(self.espai)
    if basern is None:
        a = Matriu.from_vectors_columna(self.base)
    else:
        c = [v.components_en_base(basern) for v in self.base]
        a = Matriu.from_vectors_columna(c)
    p = EquacionsParametriques(a,b)
    return (p.eliminar_parametres(prime))</code></pre>
</details>
</dd>
<dt id="Algebra.SubespaiVectorial.es_total"><code class="name flex">
<span>def <span class="ident">es_total</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna True si és el subespai R^n</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def es_total(self):
    &#34;&#34;&#34;
    Retorna True si és el subespai R^n
    &#34;&#34;&#34;
    return len(self.base) == self.espai</code></pre>
</details>
</dd>
<dt id="Algebra.SubespaiVectorial.es_zero"><code class="name flex">
<span>def <span class="ident">es_zero</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna True si és el subespai {0}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def es_zero(self):
    &#34;&#34;&#34;
    Retorna True si és el subespai {0}
    &#34;&#34;&#34;
    return len(self.base) == 0</code></pre>
</details>
</dd>
<dt id="Algebra.SubespaiVectorial.projeccio_ortogonal"><code class="name flex">
<span>def <span class="ident">projeccio_ortogonal</span></span>(<span>self, u)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la projeccio ortogonal del vector u sobre el subespai</p>
<h2 id="parametres">Parametres</h2>
<p>u: Vector</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def projeccio_ortogonal(self,u):
    &#34;&#34;&#34;
    Retorna la projeccio ortogonal del vector u sobre el subespai
    Parametres:
      u: Vector
    &#34;&#34;&#34;
    if not isinstance(u,Vector):
        return None
    if u.dimensio != self.espai:
        return None
    base = self.base_ortogonal()
    ts = [Rational(u.dot(v),v.dot(v)) for v in base]
    p = Vector.nul(self.espai)
    for i in range(len(base)):
        p += ts[i]*base[i]
    return p</code></pre>
</details>
</dd>
<dt id="Algebra.SubespaiVectorial.simetric"><code class="name flex">
<span>def <span class="ident">simetric</span></span>(<span>self, u)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el simètric del vector u sobre respecte al subespai</p>
<h2 id="parametres">Parametres</h2>
<p>u: Vector</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simetric(self,u):
    &#34;&#34;&#34;
    Retorna el simètric del vector u sobre respecte al subespai
    Parametres:
      u: Vector
    &#34;&#34;&#34;
    if not isinstance(u,Vector):
        return None
    if u.dimensio != self.espai:
        return None
    return 2*self.projeccio_ortogonal(u) - u</code></pre>
</details>
</dd>
<dt id="Algebra.SubespaiVectorial.suplementari_ortogonal"><code class="name flex">
<span>def <span class="ident">suplementari_ortogonal</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el suplementari ortogonal</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def suplementari_ortogonal(self):
    &#34;&#34;&#34;
    Retorna el suplementari ortogonal
    &#34;&#34;&#34;
    a = Matriu.from_vectors_fila(self.base)
    return SubespaiVectorial(a.nucli())</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Algebra.TransformacioAfi"><code class="flex name class">
<span>class <span class="ident">TransformacioAfi</span></span>
<span>(</span><span>p, t)</span>
</code></dt>
<dd>
<div class="desc"><p>Classe per treballar amb transformacions afins T:P^n ----&gt; P^n, on
T(p) = T + A(p)</p>
<h2 id="atributs">Atributs</h2>
<p>transformacio: Transformació lineal donada per la matriu A
translacio: translació de la transformació afí en la referència canònica
dimensio: n
formats: formats LaTeX en que s'escriuen les matrius de la transfornació</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TransformacioAfi:
    &#34;&#34;&#34;
    Classe per treballar amb transformacions afins T:P^n ----&gt; P^n, on
    T(p) = T + A(p)
    Atributs:
        transformacio: Transformació lineal donada per la matriu A
        translacio: translació de la transformació afí en la referència canònica
        dimensio: n
        formats: formats LaTeX en que s&#39;escriuen les matrius de la transfornació
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,p,t):
        &#34;&#34;&#34;
        Contructor:
        Retorna una transformació afí
        Paràmetres:
           p: Punt que representa la translació en la referencia canònica,
              és a dir, el transformat del punt zero
           t: Transformació lineal
        &#34;&#34;&#34;
        if not isinstance(p,Vector):
            return None
        if not isinstance(t,TransformacioLineal):
            return None
        if p.dimensio != t.dimensio:
            return None
        return super(TransformacioAfi,cls).__new__(cls)
    #
    #
    #
    def __init__(self,p,t):
        self.translacio = p
        self.transformacio = t
        self.dimensio = self.transformacio.dimensio
        self.formats = None
    #
    #
    #
    @classmethod
    def aleatoria(cls,ordre=3,maxim=4):
        &#34;&#34;&#34;
        Retorna una transformació afí aleatòria
        Paràmetres:
            ordre: ordre de la matriu corresponent
            maxim: Nombre màqxim que apareix a la matriu en la base
                   canònica de la transformació i en la translació
        &#34;&#34;&#34;
        T = TransformacioLineal.aleatoria(ordre=ordre,maxim=maxim)
        t = Vector.aleatori(l=ordre,maxim=maxim,nuls=False)
        return cls(t,T)
    #
    #
    #
    @classmethod
    def gir(cls,angle,origen,radiants=False):
        &#34;&#34;&#34;
        Retorna el gir d&#39;angle &#34;angle&#34; al voltant del punt &#34;origen&#34;
        Paràmetres:
            origen: centre del gir (classe Punt)
            angle: angle de rotació
            radiants: si és True, l&#39;angle ha d&#39;estar expressat en radiants
        &#34;&#34;&#34;
        if not isinstance(origen,Punt):
            return None
        if origen.dimensio != 2:
            return None
        t = TransformacioLineal.gir(angle,radiants)
        p = - t.transforma(origen) + origen
        return cls(p,t)
    #
    #
    #
    @classmethod
    def simetria(cls,v):
        &#34;&#34;&#34;
        Retorna la simetria respecte a la variatat lineal &#34;v&#34;
        Paràmetres:
            v: varietat lineal (classe VarietatLineal)
        &#34;&#34;&#34;
        if not isinstance(v,VarietatLineal):
            return None
        t = TransformacioLineal.simetria(v.subespai)
        p = - t.transforma(v.punt) + v.punt
        return cls(p,t)
    #
    #
    #
    @classmethod
    def projeccio_ortogonal(cls,v):
        &#34;&#34;&#34;
        Retorna la projecció ortogonal sobre la variatat lineal &#34;v&#34;
        Paràmetres:
            v: varietat lineal (classe VarietatLineal)
        &#34;&#34;&#34;
        if not isinstance(v,VarietatLineal):
            return None
        t = TransformacioLineal.projeccio_ortogonal(v.subespai)
        p = - t.transforma(v.punt) + v.punt
        return cls(p,t)
    #
    #
    #
    @classmethod
    def moviment_helicoidal(cls,recta,angle,radiants=False,alpha=0):
        &#34;&#34;&#34;
        Retorna el moviment helicoidal de P_3 que consisteix en la rotació
        d&#39;angle &#34;angle&#34; al voltant de la recta &#34;recta&#34; seguit d&#39;una translació
        de vector alpha * vector director de la recta.
        Paràmetres:
            recta: eix de rotació
            angle: angle de rotació
            radiants: si és True, l&#39;angle ha d&#39;estar expressat en radiants
            alpha: factor de la translació
        &#34;&#34;&#34;
        if not isinstance(recta,RectaAfi):
            return None
        if not recta.u.dimensio == 3:
            return None
        rotacio = TransformacioLineal.rotacio(recta.u,angle,radiants)
        p = - rotacio.transforma(recta.p) + recta.p + alpha * recta.u
        return cls(p,rotacio)
    #
    #
    #
    @classmethod
    def rotacio(cls,recta,angle,radiants=False):
        &#34;&#34;&#34;
        Retorna la rotació d&#39;angle &#34;angle&#34; al voltant de la recta &#34;recta&#34;
        Paràmetres:
            recta: eix de rotació
            angle: angle de rotació
            radiants: si és True, l&#39;angle ha d&#39;estar expressat en radiants
        &#34;&#34;&#34;
        return cls.moviment_helicoidal(recta,angle,radiants)
    #
    #
    #
    def set_formats(self,f1,f2):
        self.formats = [f1,f2]
    #
    #
    #
    def rang(self):
        &#34;&#34;&#34;
        Retorna el rang de la transfoprmació afí
        &#34;&#34;&#34;
        return self.transformacio.rang()
    #
    #
    #
    def rank(self):
        &#34;&#34;&#34;
        Retorna el rang de la transfoprmació afí
        &#34;&#34;&#34;
        return self.transformacio.rang()
    #
    #
    #
    def __repr__(self):
        &#34;&#34;&#34;
        Restorna en format latex l&#39;expressió de la transformació afí en la
        referència canònica
        &#34;&#34;&#34;
        return self.latex()
    #
    #
    #
    def latex(self,ref=None,prime=0):
        &#34;&#34;&#34;
        Retorna l&#39;expressió en latex de la transformació afí en la referència
        &#34;ref&#34;. Si ref és None, serà en la referència canònica
        Paràmetres:
            base: referència de P^n
            prime: nombre de primes que s&#39;escriuran
        &#34;&#34;&#34;
        if self.dimensio &lt;= 4:
            x, y, z, t = symbols(&#39;x y z t&#39;)
            u, v, w, r = symbols(&#39;u v w r&#39;)
            o = [x,y,z,t]
            d = [u,v,w,r]
        else:
            x1, x2, x3, x4, x5, x6, x7, x8 = symbols(&#39;x1 x2 x3 x4 x5 x6 x7 x8&#39;)
            u1, u2, u3, u4, u5, u6, u7, u8 = symbols(&#39;u1 u2 u3 u4 u5 u6 u7 u8&#39;)
            o = [x1, x2, x3, x4, x5, x6, x7, x8]
            d = [u1, u2, u3, u4, u5, u6, u7, u8]
        o = o[0:self.dimensio]
        d = d[0:self.dimensio]
        p = prime * &#34;&#39;&#34;
        o = &#34; \\\\ &#34;.join([latex(x)+p for x in o])
        d = &#34; \\\\ &#34;.join([latex(x)+p for x in d])
        z = Punt.nul(self.dimensio)
        tz = self.transforma(z,ref)
        if ref is None:
            m = self.transformacio.canonica
        else:
            m = self.transformacio.matriu_en_base(ref.base)
        s = &#34;\\begin{pmatrix}{c} &#34; + d + &#34;\\end{pmatrix} = \n&#34;
        if tz.length() &gt; 0:
            tz = Matriu.matriu_columna(tz)
            if self.formats is not None:
                tz.set_format(self.formats[0])
            s += f&#34;{tz} + \n&#34;
        if self.formats is not None:
            m.set_format(self.formats[1])
        s += f&#34;{m}\n&#34;
        s += &#34;\\begin{pmatrix}{c} &#34; + o + &#34;\\end{pmatrix}&#34;
        return s
    #
    #
    #
    def __eq__(self,other):
        &#34;&#34;&#34;
        Permet comparar transfonacions afins amb ==
        Paràmetres:
            other: una altra transformació afí
        &#34;&#34;&#34;
        return self.canonica == other.canonica and self.translacio == other.translacio
    #
    #
    #
    def __add__(self,other):
        &#34;&#34;&#34;
        Suma de transformacions afins
        Paràmetres:
            other: una altra transformació afi
        &#34;&#34;&#34;
        if other.dimensio != self.dimensio:
            return None
        m = self.canonica + other.canonica
        t = TansformacioLineal(m)
        tr = self.translacio + other.translacio
        return TransformacioAfi(tr,t)
    #
    #
    #
    def __mul__(self,other):
        &#34;&#34;&#34;
        Composició de transformacions afins o càlcul de imatges de punts
        Paràmetres:
            other: transformació afi o punt
        &#34;&#34;&#34;
        if isinstance(other,TransformacioAfi):
            if other.dimensio != self.dimensio:
                return None
            t = self.translacio + self.transformacio * other.translacio
            t = Punt(list(map(simplify,t.components)))
            tr = self.transformacio * other.transformacio
            return TransformacioAfi(t,tr)
        if isinstance(other,Punt):
            if other.dimensio != self.dimensio:
                return None
            t = self.translacio + self.transformacio * other
            return Punt(list(map(simplify,t.components)))
        return None
    #
    #
    #
    def transforma(self,p,ref=None):
        &#34;&#34;&#34;
        Calcula el transformat o imatge del punt &#34;p&#34;. p seran les coordenades
        d&#39;aquest punt en la referència &#34;ref&#34; i el transformat també estarà expressat
        en aquesta referència
        Paràmetres:
            punt: punt (classe Punt)
            ref: referència afí. Si és None, serà la referència canònica
        &#34;&#34;&#34;
        if not isinstance(p,Vector):
            return None
        if self.dimensio != p.dimensio:
            return None
        if ref is None:
            return self.translacio + self.transformacio.transforma(p)
        q = ref.punt_de_coordenades(p)
        p = Punt(self.transforma(q).components)
        return p.coordenades_en_referencia(ref)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="Algebra.TransformacioAfi.aleatoria"><code class="name flex">
<span>def <span class="ident">aleatoria</span></span>(<span>ordre=3, maxim=4)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna una transformació afí aleatòria</p>
<h2 id="parametres">Paràmetres</h2>
<p>ordre: ordre de la matriu corresponent
maxim: Nombre màqxim que apareix a la matriu en la base
canònica de la transformació i en la translació</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def aleatoria(cls,ordre=3,maxim=4):
    &#34;&#34;&#34;
    Retorna una transformació afí aleatòria
    Paràmetres:
        ordre: ordre de la matriu corresponent
        maxim: Nombre màqxim que apareix a la matriu en la base
               canònica de la transformació i en la translació
    &#34;&#34;&#34;
    T = TransformacioLineal.aleatoria(ordre=ordre,maxim=maxim)
    t = Vector.aleatori(l=ordre,maxim=maxim,nuls=False)
    return cls(t,T)</code></pre>
</details>
</dd>
<dt id="Algebra.TransformacioAfi.gir"><code class="name flex">
<span>def <span class="ident">gir</span></span>(<span>angle, origen, radiants=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el gir d'angle "angle" al voltant del punt "origen"</p>
<h2 id="parametres">Paràmetres</h2>
<p>origen: centre del gir (classe Punt)
angle: angle de rotació
radiants: si és True, l'angle ha d'estar expressat en radiants</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def gir(cls,angle,origen,radiants=False):
    &#34;&#34;&#34;
    Retorna el gir d&#39;angle &#34;angle&#34; al voltant del punt &#34;origen&#34;
    Paràmetres:
        origen: centre del gir (classe Punt)
        angle: angle de rotació
        radiants: si és True, l&#39;angle ha d&#39;estar expressat en radiants
    &#34;&#34;&#34;
    if not isinstance(origen,Punt):
        return None
    if origen.dimensio != 2:
        return None
    t = TransformacioLineal.gir(angle,radiants)
    p = - t.transforma(origen) + origen
    return cls(p,t)</code></pre>
</details>
</dd>
<dt id="Algebra.TransformacioAfi.moviment_helicoidal"><code class="name flex">
<span>def <span class="ident">moviment_helicoidal</span></span>(<span>recta, angle, radiants=False, alpha=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el moviment helicoidal de P_3 que consisteix en la rotació
d'angle "angle" al voltant de la recta "recta" seguit d'una translació
de vector alpha * vector director de la recta.</p>
<h2 id="parametres">Paràmetres</h2>
<p>recta: eix de rotació
angle: angle de rotació
radiants: si és True, l'angle ha d'estar expressat en radiants
alpha: factor de la translació</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def moviment_helicoidal(cls,recta,angle,radiants=False,alpha=0):
    &#34;&#34;&#34;
    Retorna el moviment helicoidal de P_3 que consisteix en la rotació
    d&#39;angle &#34;angle&#34; al voltant de la recta &#34;recta&#34; seguit d&#39;una translació
    de vector alpha * vector director de la recta.
    Paràmetres:
        recta: eix de rotació
        angle: angle de rotació
        radiants: si és True, l&#39;angle ha d&#39;estar expressat en radiants
        alpha: factor de la translació
    &#34;&#34;&#34;
    if not isinstance(recta,RectaAfi):
        return None
    if not recta.u.dimensio == 3:
        return None
    rotacio = TransformacioLineal.rotacio(recta.u,angle,radiants)
    p = - rotacio.transforma(recta.p) + recta.p + alpha * recta.u
    return cls(p,rotacio)</code></pre>
</details>
</dd>
<dt id="Algebra.TransformacioAfi.projeccio_ortogonal"><code class="name flex">
<span>def <span class="ident">projeccio_ortogonal</span></span>(<span>v)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la projecció ortogonal sobre la variatat lineal "v"</p>
<h2 id="parametres">Paràmetres</h2>
<p>v: varietat lineal (classe VarietatLineal)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def projeccio_ortogonal(cls,v):
    &#34;&#34;&#34;
    Retorna la projecció ortogonal sobre la variatat lineal &#34;v&#34;
    Paràmetres:
        v: varietat lineal (classe VarietatLineal)
    &#34;&#34;&#34;
    if not isinstance(v,VarietatLineal):
        return None
    t = TransformacioLineal.projeccio_ortogonal(v.subespai)
    p = - t.transforma(v.punt) + v.punt
    return cls(p,t)</code></pre>
</details>
</dd>
<dt id="Algebra.TransformacioAfi.rotacio"><code class="name flex">
<span>def <span class="ident">rotacio</span></span>(<span>recta, angle, radiants=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la rotació d'angle "angle" al voltant de la recta "recta"</p>
<h2 id="parametres">Paràmetres</h2>
<p>recta: eix de rotació
angle: angle de rotació
radiants: si és True, l'angle ha d'estar expressat en radiants</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def rotacio(cls,recta,angle,radiants=False):
    &#34;&#34;&#34;
    Retorna la rotació d&#39;angle &#34;angle&#34; al voltant de la recta &#34;recta&#34;
    Paràmetres:
        recta: eix de rotació
        angle: angle de rotació
        radiants: si és True, l&#39;angle ha d&#39;estar expressat en radiants
    &#34;&#34;&#34;
    return cls.moviment_helicoidal(recta,angle,radiants)</code></pre>
</details>
</dd>
<dt id="Algebra.TransformacioAfi.simetria"><code class="name flex">
<span>def <span class="ident">simetria</span></span>(<span>v)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la simetria respecte a la variatat lineal "v"</p>
<h2 id="parametres">Paràmetres</h2>
<p>v: varietat lineal (classe VarietatLineal)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def simetria(cls,v):
    &#34;&#34;&#34;
    Retorna la simetria respecte a la variatat lineal &#34;v&#34;
    Paràmetres:
        v: varietat lineal (classe VarietatLineal)
    &#34;&#34;&#34;
    if not isinstance(v,VarietatLineal):
        return None
    t = TransformacioLineal.simetria(v.subespai)
    p = - t.transforma(v.punt) + v.punt
    return cls(p,t)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Algebra.TransformacioAfi.latex"><code class="name flex">
<span>def <span class="ident">latex</span></span>(<span>self, ref=None, prime=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna l'expressió en latex de la transformació afí en la referència
"ref". Si ref és None, serà en la referència canònica</p>
<h2 id="parametres">Paràmetres</h2>
<p>base: referència de P^n
prime: nombre de primes que s'escriuran</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def latex(self,ref=None,prime=0):
    &#34;&#34;&#34;
    Retorna l&#39;expressió en latex de la transformació afí en la referència
    &#34;ref&#34;. Si ref és None, serà en la referència canònica
    Paràmetres:
        base: referència de P^n
        prime: nombre de primes que s&#39;escriuran
    &#34;&#34;&#34;
    if self.dimensio &lt;= 4:
        x, y, z, t = symbols(&#39;x y z t&#39;)
        u, v, w, r = symbols(&#39;u v w r&#39;)
        o = [x,y,z,t]
        d = [u,v,w,r]
    else:
        x1, x2, x3, x4, x5, x6, x7, x8 = symbols(&#39;x1 x2 x3 x4 x5 x6 x7 x8&#39;)
        u1, u2, u3, u4, u5, u6, u7, u8 = symbols(&#39;u1 u2 u3 u4 u5 u6 u7 u8&#39;)
        o = [x1, x2, x3, x4, x5, x6, x7, x8]
        d = [u1, u2, u3, u4, u5, u6, u7, u8]
    o = o[0:self.dimensio]
    d = d[0:self.dimensio]
    p = prime * &#34;&#39;&#34;
    o = &#34; \\\\ &#34;.join([latex(x)+p for x in o])
    d = &#34; \\\\ &#34;.join([latex(x)+p for x in d])
    z = Punt.nul(self.dimensio)
    tz = self.transforma(z,ref)
    if ref is None:
        m = self.transformacio.canonica
    else:
        m = self.transformacio.matriu_en_base(ref.base)
    s = &#34;\\begin{pmatrix}{c} &#34; + d + &#34;\\end{pmatrix} = \n&#34;
    if tz.length() &gt; 0:
        tz = Matriu.matriu_columna(tz)
        if self.formats is not None:
            tz.set_format(self.formats[0])
        s += f&#34;{tz} + \n&#34;
    if self.formats is not None:
        m.set_format(self.formats[1])
    s += f&#34;{m}\n&#34;
    s += &#34;\\begin{pmatrix}{c} &#34; + o + &#34;\\end{pmatrix}&#34;
    return s</code></pre>
</details>
</dd>
<dt id="Algebra.TransformacioAfi.rang"><code class="name flex">
<span>def <span class="ident">rang</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el rang de la transfoprmació afí</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rang(self):
    &#34;&#34;&#34;
    Retorna el rang de la transfoprmació afí
    &#34;&#34;&#34;
    return self.transformacio.rang()</code></pre>
</details>
</dd>
<dt id="Algebra.TransformacioAfi.rank"><code class="name flex">
<span>def <span class="ident">rank</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el rang de la transfoprmació afí</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rank(self):
    &#34;&#34;&#34;
    Retorna el rang de la transfoprmació afí
    &#34;&#34;&#34;
    return self.transformacio.rang()</code></pre>
</details>
</dd>
<dt id="Algebra.TransformacioAfi.set_formats"><code class="name flex">
<span>def <span class="ident">set_formats</span></span>(<span>self, f1, f2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_formats(self,f1,f2):
    self.formats = [f1,f2]</code></pre>
</details>
</dd>
<dt id="Algebra.TransformacioAfi.transforma"><code class="name flex">
<span>def <span class="ident">transforma</span></span>(<span>self, p, ref=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calcula el transformat o imatge del punt "p". p seran les coordenades
d'aquest punt en la referència "ref" i el transformat també estarà expressat
en aquesta referència</p>
<h2 id="parametres">Paràmetres</h2>
<p>punt: punt (classe Punt)
ref: referència afí. Si és None, serà la referència canònica</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transforma(self,p,ref=None):
    &#34;&#34;&#34;
    Calcula el transformat o imatge del punt &#34;p&#34;. p seran les coordenades
    d&#39;aquest punt en la referència &#34;ref&#34; i el transformat també estarà expressat
    en aquesta referència
    Paràmetres:
        punt: punt (classe Punt)
        ref: referència afí. Si és None, serà la referència canònica
    &#34;&#34;&#34;
    if not isinstance(p,Vector):
        return None
    if self.dimensio != p.dimensio:
        return None
    if ref is None:
        return self.translacio + self.transformacio.transforma(p)
    q = ref.punt_de_coordenades(p)
    p = Punt(self.transforma(q).components)
    return p.coordenades_en_referencia(ref)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Algebra.TransformacioLineal"><code class="flex name class">
<span>class <span class="ident">TransformacioLineal</span></span>
<span>(</span><span>matriu, base=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Classe per treballar amb transformacions lineals T:R^n ----&gt; R^n</p>
<h2 id="atributs">Atributs</h2>
<p>dimensio: n
canonica: matriu de la transformació en la base canònica
format: format LaTeX per a la matriu</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TransformacioLineal(object):
    &#34;&#34;&#34;
    Classe per treballar amb transformacions lineals T:R^n ----&gt; R^n
    Atributs:
       dimensio: n
       canonica: matriu de la transformació en la base canònica
       format: format LaTeX per a la matriu
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,matriu,base=None):
        &#34;&#34;&#34;
        Constructor.
        Retorna una nova transformació lineal
        Paràmetres:
            matriu: matriu de la transformació lineal en la base &#34;base&#34;
            base: base de R^n. Si és None serà la canònica
        &#34;&#34;&#34;
        if not isinstance(matriu,Matriu):
            return None
        if matriu.files != matriu.columnes:
            return None
        if base is not None:
            if not isinstance(base,Base):
                return None
            if base.dimensio != matriu.files:
                return None
        return super(TransformacioLineal,cls).__new__(cls)
    #
    #
    #
    def __init__(self,matriu,base=None):
        self.dimensio = matriu.files
        if base is None:
            self.canonica = Matriu(matriu.matriu)
        else:
            c = base.matriu()
            m = c.matriu * matriu.matriu * c.matriu**(-1)
            self.canonica = Matriu(m)
        self.format = None
    #
    #
    #
    def set_format(self,format):
        &#34;&#34;&#34;
        Estableix el format LaTeX per a la matriu
        &#34;&#34;&#34;
        self.format = format
    #
    #
    #
    def determinant(self):
        &#34;&#34;&#34;
        Retorna el deterinant de la transformació lineal
        &#34;&#34;&#34;
        return self.canonica.determinant()
    #
    #
    #
    @classmethod
    def aleatoria(cls,ordre=3,maxim=4):
        &#34;&#34;&#34;
        Retorna una transformació lineal aleatòria
        Paràmetres:
            ordre: ordre de la matriu corresponent
            maxim: Nombre màqxim que apareix a la matriu en la base
                   canònica de la transformació
        &#34;&#34;&#34;
        A = Matriu.aleatoria(f=ordre,c=ordre,maxim=maxim,nuls=False)
        return cls(A)
    #
    #
    #
    def es_rotacio(self):
        &#34;&#34;&#34;
        Ens diu si és una rotació tridimensional o no
        &#34;&#34;&#34;
        if self.dimensio != 3:
            return False
        d = self.determinant()
        if abs(N(d) - 1.0) &gt; 10**(-8):
            return False
        m = self.canonica
        u = Matriu()
        k = m.transposada() * m
        for i in range(k.files):
            for j in range(k.columnes):
                p = N(k[i,j])
                if abs(p - u[i,j]) &gt; 10**(-8):
                    return False
        return True
    #
    #
    #
    def eix_angle_rotacio(self,radiants=False):
        &#34;&#34;&#34;
        Retorna l&#39;eix i l&#39;angle de rotació
        Paràmetres:
            radiants: si és True retorna l&#39;angle en radiants, en cas contrari,
            ho fa en graus
        &#34;&#34;&#34;
        if not self.es_rotacio():
            return None
        m = self.canonica - Matriu()
        e = m.nucli()[0]
        e = Vector([radsimp(k.expand()) for k in e.components])
        e.simplificar(positiu=True)
        t = radsimp(self.canonica.matriu.trace().expand())
        t = (t - 1)/2
        alpha = acos(t)
        u = e.perpendicular()[0]
        v = self.transforma(u)
        A = Matriu.from_vectors_columna([e,u,v])
        if A.det() &lt;= 0:
            alpha = 2*pi - alpha
        if not radiants:
            alpha = alpha * 180/pi
        return (e,alpha)
    #
    #
    #
    def quaternio(self):
        &#34;&#34;&#34;
        Retorna un dels quaternions que definieix una rotació. Recordem
        que l&#39;altre és l&#39;oposat
        &#34;&#34;&#34;
        if not self.es_rotacio():
            return None
        w, angle = self.eix_angle_rotacio(radiants=True)
        w.simplificar(positiu=True)
        w.normalitzar()
        w *= sin(angle/2)
        w = Vector([radsimp(x.expand()) for x in w.components])
        return Vector(radsimp(radsimp(cos(angle/2).expand())),w[0],w[1],w[2])
    #
    #
    #
    def angles_euler(self,radiants=False):
        &#34;&#34;&#34;
        Retorna els angles d&#39;Euler de la rotació corresponents a l&#39;ordre &#39;ZXZ&#39;
        Paràmetres:
            radiants: si és True retorna els angles en radiants, en cas contrari,
            ho fa en graus
        &#34;&#34;&#34;
        if not self.es_rotacio():
            return None
        m = self.canonica
        if abs(m[2,2]) != 1:
            theta = acos(m[2,2])
            psi = atan2(m[2,0],m[2,1])
            phi = atan2(m[0,2],-m[1,2])
        else:
            phi = 0
            theta = acos(m[2,2])
            psi = atan2(m[2,2] * m[1,0],m[0,0])
        if psi &lt; 0:
            psi += 2*pi
        if theta &lt; 0:
            theta += 2*pi
        if phi &lt; 0:
            phi += 2*pi
        if not radiants:
            theta *= 180 / pi
            psi *= 180 / pi
            phi *= 180 / pi
        return (psi,theta,phi)
    #
    #
    #
    @classmethod
    def gir(cls,angle,radiants=False):
        &#34;&#34;&#34;
        Retorna el gir d&#39;angle &#34;angle&#34; en dimensió 2
        Paràmetres:
            angle: angle de rotació
            radiants: si l&#39;angle està en radiants, ha de ser True
        &#34;&#34;&#34;
        if not radiants:
            angle *= pi / 180
        m = Matriu.from_vectors_columna([Vector(cos(angle),sin(angle)),Vector(-sin(angle),cos(angle))])
        return cls(m)
    #
    #
    #
    @classmethod
    def rotacio(cls,eix,angle,radiants=False):
        &#34;&#34;&#34;
        Retorna la rotació d&#39;angle &#34;angle&#34; al voltant del vector &#34;eix&#34;
        Paràmetres:
            eix: vector al voltant del qual fem la rotació
            angle: angle de rotació
            radiants: si l&#39;angle està en radiants, ha de ser True
        &#34;&#34;&#34;
        if not radiants:
            angle *= pi / 180
        v = Vector(eix.components)
        v.normalitzar()
        q = Quaternion.from_axis_angle(v.components,angle)
        m = Matriu(q.to_rotation_matrix())
        for i in range(m.files):
            for j in range(m.columnes):
                m[(i,j)] = radsimp(m[(i,j)].expand())
        return cls(m)
    #
    #
    #
    @classmethod
    def rotacio_amb_angles_euler(cls,psi,theta,phi,ordre=&#39;ZXZ&#39;,radiants=False):
        &#34;&#34;&#34;
        Retorna la rotació amb angles d&#39;Euler psi, theta i phi al voltant dels
        dels eixos determinats pel paràmetre ordre
        Paràmetres:
            psi, theta i phi: angles d&#39;Euler
            ordre: eixos al voltant dels que fem les rotacions
            radiants: si l&#39;angle està en radiants, ha de ser True
        &#34;&#34;&#34;
        ordres = [&#39;XYZ&#39;,&#39;XZY&#39;,&#39;YXZ&#39;,&#39;YZX&#39;,&#39;ZXY&#39;,&#39;ZYX&#39;,
                  &#39;XZX&#39;,&#39;XYX&#39;,&#39;YXY&#39;,&#39;YZY&#39;,&#39;ZXZ&#39;,&#39;ZYZ&#39;]
        vectors = {&#39;X&#39; : Vector(1,0,0),
                   &#39;Y&#39; : Vector(0,1,0),
                   &#39;Z&#39; : Vector(0,0,1)}
        ordre = ordre.upper()
        angles = [psi,theta,phi]
        if ordre not in ordres:
            return None
        m = []
        for i, s in enumerate(ordre):
            r = cls.rotacio(vectors[s],angles[i],radiants)
            m.append(r)
        A = m[2].canonica * m[1].canonica * m[0].canonica
        return cls(A)
    #
    #
    #
    @classmethod
    def rotacio_amb_quaternio(cls,q):
        &#34;&#34;&#34;
        Retorna la rotació definida pel quaternio &#34;q&#34;
        Paràmetres:
             q: element de la classe Quaternio
        &#34;&#34;&#34;
        if not isinstance(q,Quaternion):
            return None
        n = (q.norm()**2).expand()
        if n != 1 and abs(N(sqrt(n)) - 1.0) &gt; 10**(-12):
            return None
        m = Matriu(q.to_rotation_matrix())
        for i in range(m.files):
            for j in range(m.columnes):
                m[(i,j)] = radsimp(m[(i,j)].expand())
        return cls(m)
    #
    #
    #
    @classmethod
    def escalat(cls,factors,base=None):
        &#34;&#34;&#34;
        Retorna la transformació lineal que consisteix en escalats de factors
        &#34;factor&#34; en les direccions de la base &#34;base&#34;
        Paràmetres:
            factors: llista de nombres
            base: element de la classe Base
        &#34;&#34;&#34;
        if base is None:
            base = Base.canonica(dimensio=len(factors))
        if len(factors) != base.dimensio:
            return None
        A = Matriu.diagonal(factors)
        return cls(A,base)
    #
    #
    #
    @classmethod
    def projeccio_ortogonal(cls,s):
        &#34;&#34;&#34;
        Retorna la projecció ortogonal sobre el subespai &#34;s&#34;
        Paràmetres:
            s: subespai vectorial (classe SubespaiVectorial)
        &#34;&#34;&#34;
        if not isinstance(s,SubespaiVectorial):
            return None
        n = s.espai
        m = s.dimensio
        uns = [1 for k in range(m)]
        zeros = [0 for k in range(n-m)]
        d = uns + zeros
        b = Base(s.base + s.suplementari_ortogonal().base)
        m = Matriu.diagonal(d)
        return cls(m,b)
    #
    #
    #
    @classmethod
    def simetria(cls,s):
        &#34;&#34;&#34;
        Retorna la simetria respecte al subespai &#34;s&#34;
        Paràmetres:
            s: subespai vectorial (classe SubespaiVectorial)
        &#34;&#34;&#34;
        if not isinstance(s,SubespaiVectorial):
            return None
        n = s.espai
        m = s.dimensio
        uns = [1 for k in range(m)]
        menys = [-1 for k in range(n-m)]
        d = uns + menys
        b = Base(s.base + s.suplementari_ortogonal().base)
        m = Matriu.diagonal(d)
        return cls(m,b)
    #
    #
    #
    def matriu_en_base(self,base):
        &#34;&#34;&#34;
        Retorna la matriu de la transformacio lineal en la base &#34;base&#34;
        Paràmetres:
            base: base de R^n (classe Base)
        &#34;&#34;&#34;
        if base is None:
            return self.canonica
        c = base.matriu()
        m = c.matriu**(-1) * self.canonica.matriu * c.matriu
        return Matriu(m)
    #
    #
    #
    def antiimatges(self,v):
        &#34;&#34;&#34;
        Retorna les antiimages del vector v
        Paràmetres:
            v: element de la classe Vector
        &#34;&#34;&#34;
        if self.dimensio != v.dimensio:
            return None
        s = SistemaEquacions(self.canonica,v)
        s.resol()
        return Vector(s.solucio), s.secundaries
    #
    #
    #
    def latex(self,base=None,prime=0):
        &#34;&#34;&#34;
        Retorna l&#39;expressió en latex de la transformació lineal en la base &#34;base&#34;
        Si base és None, serà en la base canònica
        Paràmetres:
            base: base de R^n
            prime: nombre de primes que s&#39;han d&#39;escriure
        &#34;&#34;&#34;
        if self.dimensio &lt;= 4:
            x, y, z, t = symbols(&#39;x y z t&#39;)
            u, v, w, r = symbols(&#39;u v w r&#39;)
            o = [x,y,z,t]
            d = [u,v,w,r]
        else:
            x1, x2, x3, x4, x5, x6, x7, x8 = symbols(&#39;x1 x2 x3 x4 x5 x6 x7 x8&#39;)
            u1, u2, u3, u4, u5, u6, u7, u8 = symbols(&#39;u1 u2 u3 u4 u5 u6 u7 u8&#39;)
            o = [x1, x2, x3, x4, x5, x6, x7, x8]
            d = [u1, u2, u3, u4, u5, u6, u7, u8]
        o = o[0:self.dimensio]
        d = d[0:self.dimensio]
        p = prime * &#34;&#39;&#34;
        o = &#34; \\\\ &#34;.join([latex(x)+p for x in o])
        d = &#34; \\\\ &#34;.join([latex(x)+p for x in d])
        if base is None:
             m = self.canonica
             m.set_format(self.format)
        else:
            if not isinstance(base,Base):
                return None
            c = base.matriu()
            m = c.matriu**(-1) * self.canonica.matriu * c.matriu
            m = Matriu(m)
            m.set_format(self.format)
        s = &#34;\\begin{pmatrix}{c} &#34; + d + &#34;\\end{pmatrix} = \n&#34;
        s += f&#34;{m}\n&#34;
        s += &#34;\\begin{pmatrix}{c} &#34; + o + &#34;\\end{pmatrix}&#34;
        return s
    #
    #
    #
    def __repr__(self):
        &#34;&#34;&#34;
        Retorna el latex de l&#39;expressió en la base canònica de la transformació lineal
        &#34;&#34;&#34;
        return self.latex()
    #
    #
    #
    def imatges_una_base(self,base):
        &#34;&#34;&#34;
        Retorna l&#39;expressió en LaTeX de les imatges dels vectors de la base &#34;base&#34;
        Paràmetres:
            base: element de la classe Base
        &#34;&#34;&#34;
        if not isinstance(base,Base):
            return None
        if self.dimensio != base.dimensio:
            return None
        ts = []
        for x in base.vecs:
            y = self.transforma(x)
            ts.append(f&#34;T{x} &amp;= {y}&#34;)
        ts = &#34; \\\\ \n&#34;.join(ts)
        str = &#34;\\left.\\begin{aligned}\nIMATGES\n\\end{aligned}\\,\\right\\}&#34;
        return str.replace(&#39;IMATGES&#39;,ts)
    #
    #
    #
    def rang(self):
        &#34;&#34;&#34;
        Retorna el rang de la transfoprmació afí
        &#34;&#34;&#34;
        return self.canonica.rang()
    #
    #
    #
    def rank(self):
        &#34;&#34;&#34;
        Retorna el rang de la transfoprmació afí
        &#34;&#34;&#34;
        return self.canonica.rang()
    #
    #
    #
    def __eq__(self,other):
        &#34;&#34;&#34;
        Permet comparar transfonacions lineals amb ==
        Paràmetres:
            other: una altra transformació lineal
        &#34;&#34;&#34;
        return self.canonica == other.canonica
    #
    #
    #
    def __add__(self,other):
        &#34;&#34;&#34;
        Suma de transformacions lineals
        Paràmetres:
            other: una altra transformació lineal
        &#34;&#34;&#34;
        if other.dimensio != self.dimensio:
            return None
        m = self.canonica + other.canonica
        return TransformacioLineal(m)
    #
    #
    #
    def __mul__(self,other):
        &#34;&#34;&#34;
        Composició de transformacions lineal o càlcul de imatges
        Paràmetres:
            other: transformació lineal o vector
        &#34;&#34;&#34;
        if isinstance(other,TransformacioLineal):
            if other.dimensio != self.dimensio:
                return None
            m = self.canonica * other.canonica
            return TransformacioLineal(m)
        if isinstance(other,Vector):
            if other.dimensio != self.dimensio:
                return None
            return self.canonica * other
        return None
    #
    #
    #
    def es_simetrica(self):
        &#34;&#34;&#34;
        Retorna si la transformació lineal és simètrica
        &#34;&#34;&#34;
        return self.canonica == self.canonica.transposada()
    #
    #
    #
    def transforma(self,vec,base=None):
        &#34;&#34;&#34;
        Calcula el transformat (imatge) del vector &#34;vec&#34;.
        Paràmetres:
            vec: vector
            base: si no és None, vec seran les compoents del vectors en aquesta
            base. El transformat o imatge també estarà expressat en aquesta base
        &#34;&#34;&#34;
        if not isinstance(vec,Vector):
            return None
        if vec.dimensio != self.dimensio:
            return None
        if base is None:
            t = self.canonica * vec
        else:
            if not isinstance(base,Base):
                return None
            c = base.matriu()
            m = c.matriu**(-1) * self.canonica.matriu * c.matriu
            m = Matriu(m)
            t = m * vec
        for k in range(t.dimensio):
            t[k] = simplify(t[k].expand())
        return t
    #
    #
    #
    def polinomi_caracteristic(self):
        &#34;&#34;&#34;
        Retorna el polinomi característic de la transformació lineal
        &#34;&#34;&#34;
        return self.canonica.polinomi_caracteristic()
    #
    #
    #
    def es_vector_propi(self,u):
        &#34;&#34;&#34;
        Retorna si el vector &#34;u&#34; és o no un vector propi
        Paràmetres:
            u: element de la class Vector
        &#34;&#34;&#34;
        if not isinstance(u,Vector):
            return None
        if self.dimensio != u.dimensio:
            return None
        v = self.transforma(u)
        return v.es_proporcional(u)
    #
    #
    #
    def diagonalitza(self,ortogonals=False):
        &#34;&#34;&#34;
            Diagonalitza la matriu de la transformació lineal en la base canònica
        &#34;&#34;&#34;
        self.canonica.diagonalitza(ortogonals)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="Algebra.TransformacioLineal.aleatoria"><code class="name flex">
<span>def <span class="ident">aleatoria</span></span>(<span>ordre=3, maxim=4)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna una transformació lineal aleatòria</p>
<h2 id="parametres">Paràmetres</h2>
<p>ordre: ordre de la matriu corresponent
maxim: Nombre màqxim que apareix a la matriu en la base
canònica de la transformació</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def aleatoria(cls,ordre=3,maxim=4):
    &#34;&#34;&#34;
    Retorna una transformació lineal aleatòria
    Paràmetres:
        ordre: ordre de la matriu corresponent
        maxim: Nombre màqxim que apareix a la matriu en la base
               canònica de la transformació
    &#34;&#34;&#34;
    A = Matriu.aleatoria(f=ordre,c=ordre,maxim=maxim,nuls=False)
    return cls(A)</code></pre>
</details>
</dd>
<dt id="Algebra.TransformacioLineal.escalat"><code class="name flex">
<span>def <span class="ident">escalat</span></span>(<span>factors, base=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la transformació lineal que consisteix en escalats de factors
"factor" en les direccions de la base "base"</p>
<h2 id="parametres">Paràmetres</h2>
<p>factors: llista de nombres
base: element de la classe Base</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def escalat(cls,factors,base=None):
    &#34;&#34;&#34;
    Retorna la transformació lineal que consisteix en escalats de factors
    &#34;factor&#34; en les direccions de la base &#34;base&#34;
    Paràmetres:
        factors: llista de nombres
        base: element de la classe Base
    &#34;&#34;&#34;
    if base is None:
        base = Base.canonica(dimensio=len(factors))
    if len(factors) != base.dimensio:
        return None
    A = Matriu.diagonal(factors)
    return cls(A,base)</code></pre>
</details>
</dd>
<dt id="Algebra.TransformacioLineal.gir"><code class="name flex">
<span>def <span class="ident">gir</span></span>(<span>angle, radiants=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el gir d'angle "angle" en dimensió 2</p>
<h2 id="parametres">Paràmetres</h2>
<p>angle: angle de rotació
radiants: si l'angle està en radiants, ha de ser True</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def gir(cls,angle,radiants=False):
    &#34;&#34;&#34;
    Retorna el gir d&#39;angle &#34;angle&#34; en dimensió 2
    Paràmetres:
        angle: angle de rotació
        radiants: si l&#39;angle està en radiants, ha de ser True
    &#34;&#34;&#34;
    if not radiants:
        angle *= pi / 180
    m = Matriu.from_vectors_columna([Vector(cos(angle),sin(angle)),Vector(-sin(angle),cos(angle))])
    return cls(m)</code></pre>
</details>
</dd>
<dt id="Algebra.TransformacioLineal.projeccio_ortogonal"><code class="name flex">
<span>def <span class="ident">projeccio_ortogonal</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la projecció ortogonal sobre el subespai "s"</p>
<h2 id="parametres">Paràmetres</h2>
<p>s: subespai vectorial (classe SubespaiVectorial)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def projeccio_ortogonal(cls,s):
    &#34;&#34;&#34;
    Retorna la projecció ortogonal sobre el subespai &#34;s&#34;
    Paràmetres:
        s: subespai vectorial (classe SubespaiVectorial)
    &#34;&#34;&#34;
    if not isinstance(s,SubespaiVectorial):
        return None
    n = s.espai
    m = s.dimensio
    uns = [1 for k in range(m)]
    zeros = [0 for k in range(n-m)]
    d = uns + zeros
    b = Base(s.base + s.suplementari_ortogonal().base)
    m = Matriu.diagonal(d)
    return cls(m,b)</code></pre>
</details>
</dd>
<dt id="Algebra.TransformacioLineal.rotacio"><code class="name flex">
<span>def <span class="ident">rotacio</span></span>(<span>eix, angle, radiants=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la rotació d'angle "angle" al voltant del vector "eix"</p>
<h2 id="parametres">Paràmetres</h2>
<p>eix: vector al voltant del qual fem la rotació
angle: angle de rotació
radiants: si l'angle està en radiants, ha de ser True</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def rotacio(cls,eix,angle,radiants=False):
    &#34;&#34;&#34;
    Retorna la rotació d&#39;angle &#34;angle&#34; al voltant del vector &#34;eix&#34;
    Paràmetres:
        eix: vector al voltant del qual fem la rotació
        angle: angle de rotació
        radiants: si l&#39;angle està en radiants, ha de ser True
    &#34;&#34;&#34;
    if not radiants:
        angle *= pi / 180
    v = Vector(eix.components)
    v.normalitzar()
    q = Quaternion.from_axis_angle(v.components,angle)
    m = Matriu(q.to_rotation_matrix())
    for i in range(m.files):
        for j in range(m.columnes):
            m[(i,j)] = radsimp(m[(i,j)].expand())
    return cls(m)</code></pre>
</details>
</dd>
<dt id="Algebra.TransformacioLineal.rotacio_amb_angles_euler"><code class="name flex">
<span>def <span class="ident">rotacio_amb_angles_euler</span></span>(<span>psi, theta, phi, ordre='ZXZ', radiants=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la rotació amb angles d'Euler psi, theta i phi al voltant dels
dels eixos determinats pel paràmetre ordre</p>
<h2 id="parametres">Paràmetres</h2>
<p>psi, theta i phi: angles d'Euler
ordre: eixos al voltant dels que fem les rotacions
radiants: si l'angle està en radiants, ha de ser True</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def rotacio_amb_angles_euler(cls,psi,theta,phi,ordre=&#39;ZXZ&#39;,radiants=False):
    &#34;&#34;&#34;
    Retorna la rotació amb angles d&#39;Euler psi, theta i phi al voltant dels
    dels eixos determinats pel paràmetre ordre
    Paràmetres:
        psi, theta i phi: angles d&#39;Euler
        ordre: eixos al voltant dels que fem les rotacions
        radiants: si l&#39;angle està en radiants, ha de ser True
    &#34;&#34;&#34;
    ordres = [&#39;XYZ&#39;,&#39;XZY&#39;,&#39;YXZ&#39;,&#39;YZX&#39;,&#39;ZXY&#39;,&#39;ZYX&#39;,
              &#39;XZX&#39;,&#39;XYX&#39;,&#39;YXY&#39;,&#39;YZY&#39;,&#39;ZXZ&#39;,&#39;ZYZ&#39;]
    vectors = {&#39;X&#39; : Vector(1,0,0),
               &#39;Y&#39; : Vector(0,1,0),
               &#39;Z&#39; : Vector(0,0,1)}
    ordre = ordre.upper()
    angles = [psi,theta,phi]
    if ordre not in ordres:
        return None
    m = []
    for i, s in enumerate(ordre):
        r = cls.rotacio(vectors[s],angles[i],radiants)
        m.append(r)
    A = m[2].canonica * m[1].canonica * m[0].canonica
    return cls(A)</code></pre>
</details>
</dd>
<dt id="Algebra.TransformacioLineal.rotacio_amb_quaternio"><code class="name flex">
<span>def <span class="ident">rotacio_amb_quaternio</span></span>(<span>q)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la rotació definida pel quaternio "q"</p>
<h2 id="parametres">Paràmetres</h2>
<p>q: element de la classe Quaternio</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def rotacio_amb_quaternio(cls,q):
    &#34;&#34;&#34;
    Retorna la rotació definida pel quaternio &#34;q&#34;
    Paràmetres:
         q: element de la classe Quaternio
    &#34;&#34;&#34;
    if not isinstance(q,Quaternion):
        return None
    n = (q.norm()**2).expand()
    if n != 1 and abs(N(sqrt(n)) - 1.0) &gt; 10**(-12):
        return None
    m = Matriu(q.to_rotation_matrix())
    for i in range(m.files):
        for j in range(m.columnes):
            m[(i,j)] = radsimp(m[(i,j)].expand())
    return cls(m)</code></pre>
</details>
</dd>
<dt id="Algebra.TransformacioLineal.simetria"><code class="name flex">
<span>def <span class="ident">simetria</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la simetria respecte al subespai "s"</p>
<h2 id="parametres">Paràmetres</h2>
<p>s: subespai vectorial (classe SubespaiVectorial)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def simetria(cls,s):
    &#34;&#34;&#34;
    Retorna la simetria respecte al subespai &#34;s&#34;
    Paràmetres:
        s: subespai vectorial (classe SubespaiVectorial)
    &#34;&#34;&#34;
    if not isinstance(s,SubespaiVectorial):
        return None
    n = s.espai
    m = s.dimensio
    uns = [1 for k in range(m)]
    menys = [-1 for k in range(n-m)]
    d = uns + menys
    b = Base(s.base + s.suplementari_ortogonal().base)
    m = Matriu.diagonal(d)
    return cls(m,b)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Algebra.TransformacioLineal.angles_euler"><code class="name flex">
<span>def <span class="ident">angles_euler</span></span>(<span>self, radiants=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna els angles d'Euler de la rotació corresponents a l'ordre 'ZXZ'</p>
<h2 id="parametres">Paràmetres</h2>
<p>radiants: si és True retorna els angles en radiants, en cas contrari,
ho fa en graus</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def angles_euler(self,radiants=False):
    &#34;&#34;&#34;
    Retorna els angles d&#39;Euler de la rotació corresponents a l&#39;ordre &#39;ZXZ&#39;
    Paràmetres:
        radiants: si és True retorna els angles en radiants, en cas contrari,
        ho fa en graus
    &#34;&#34;&#34;
    if not self.es_rotacio():
        return None
    m = self.canonica
    if abs(m[2,2]) != 1:
        theta = acos(m[2,2])
        psi = atan2(m[2,0],m[2,1])
        phi = atan2(m[0,2],-m[1,2])
    else:
        phi = 0
        theta = acos(m[2,2])
        psi = atan2(m[2,2] * m[1,0],m[0,0])
    if psi &lt; 0:
        psi += 2*pi
    if theta &lt; 0:
        theta += 2*pi
    if phi &lt; 0:
        phi += 2*pi
    if not radiants:
        theta *= 180 / pi
        psi *= 180 / pi
        phi *= 180 / pi
    return (psi,theta,phi)</code></pre>
</details>
</dd>
<dt id="Algebra.TransformacioLineal.antiimatges"><code class="name flex">
<span>def <span class="ident">antiimatges</span></span>(<span>self, v)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna les antiimages del vector v</p>
<h2 id="parametres">Paràmetres</h2>
<p>v: element de la classe Vector</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def antiimatges(self,v):
    &#34;&#34;&#34;
    Retorna les antiimages del vector v
    Paràmetres:
        v: element de la classe Vector
    &#34;&#34;&#34;
    if self.dimensio != v.dimensio:
        return None
    s = SistemaEquacions(self.canonica,v)
    s.resol()
    return Vector(s.solucio), s.secundaries</code></pre>
</details>
</dd>
<dt id="Algebra.TransformacioLineal.determinant"><code class="name flex">
<span>def <span class="ident">determinant</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el deterinant de la transformació lineal</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def determinant(self):
    &#34;&#34;&#34;
    Retorna el deterinant de la transformació lineal
    &#34;&#34;&#34;
    return self.canonica.determinant()</code></pre>
</details>
</dd>
<dt id="Algebra.TransformacioLineal.diagonalitza"><code class="name flex">
<span>def <span class="ident">diagonalitza</span></span>(<span>self, ortogonals=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Diagonalitza la matriu de la transformació lineal en la base canònica</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def diagonalitza(self,ortogonals=False):
    &#34;&#34;&#34;
        Diagonalitza la matriu de la transformació lineal en la base canònica
    &#34;&#34;&#34;
    self.canonica.diagonalitza(ortogonals)</code></pre>
</details>
</dd>
<dt id="Algebra.TransformacioLineal.eix_angle_rotacio"><code class="name flex">
<span>def <span class="ident">eix_angle_rotacio</span></span>(<span>self, radiants=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna l'eix i l'angle de rotació</p>
<h2 id="parametres">Paràmetres</h2>
<p>radiants: si és True retorna l'angle en radiants, en cas contrari,
ho fa en graus</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eix_angle_rotacio(self,radiants=False):
    &#34;&#34;&#34;
    Retorna l&#39;eix i l&#39;angle de rotació
    Paràmetres:
        radiants: si és True retorna l&#39;angle en radiants, en cas contrari,
        ho fa en graus
    &#34;&#34;&#34;
    if not self.es_rotacio():
        return None
    m = self.canonica - Matriu()
    e = m.nucli()[0]
    e = Vector([radsimp(k.expand()) for k in e.components])
    e.simplificar(positiu=True)
    t = radsimp(self.canonica.matriu.trace().expand())
    t = (t - 1)/2
    alpha = acos(t)
    u = e.perpendicular()[0]
    v = self.transforma(u)
    A = Matriu.from_vectors_columna([e,u,v])
    if A.det() &lt;= 0:
        alpha = 2*pi - alpha
    if not radiants:
        alpha = alpha * 180/pi
    return (e,alpha)</code></pre>
</details>
</dd>
<dt id="Algebra.TransformacioLineal.es_rotacio"><code class="name flex">
<span>def <span class="ident">es_rotacio</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Ens diu si és una rotació tridimensional o no</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def es_rotacio(self):
    &#34;&#34;&#34;
    Ens diu si és una rotació tridimensional o no
    &#34;&#34;&#34;
    if self.dimensio != 3:
        return False
    d = self.determinant()
    if abs(N(d) - 1.0) &gt; 10**(-8):
        return False
    m = self.canonica
    u = Matriu()
    k = m.transposada() * m
    for i in range(k.files):
        for j in range(k.columnes):
            p = N(k[i,j])
            if abs(p - u[i,j]) &gt; 10**(-8):
                return False
    return True</code></pre>
</details>
</dd>
<dt id="Algebra.TransformacioLineal.es_simetrica"><code class="name flex">
<span>def <span class="ident">es_simetrica</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna si la transformació lineal és simètrica</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def es_simetrica(self):
    &#34;&#34;&#34;
    Retorna si la transformació lineal és simètrica
    &#34;&#34;&#34;
    return self.canonica == self.canonica.transposada()</code></pre>
</details>
</dd>
<dt id="Algebra.TransformacioLineal.es_vector_propi"><code class="name flex">
<span>def <span class="ident">es_vector_propi</span></span>(<span>self, u)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna si el vector "u" és o no un vector propi</p>
<h2 id="parametres">Paràmetres</h2>
<p>u: element de la class Vector</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def es_vector_propi(self,u):
    &#34;&#34;&#34;
    Retorna si el vector &#34;u&#34; és o no un vector propi
    Paràmetres:
        u: element de la class Vector
    &#34;&#34;&#34;
    if not isinstance(u,Vector):
        return None
    if self.dimensio != u.dimensio:
        return None
    v = self.transforma(u)
    return v.es_proporcional(u)</code></pre>
</details>
</dd>
<dt id="Algebra.TransformacioLineal.imatges_una_base"><code class="name flex">
<span>def <span class="ident">imatges_una_base</span></span>(<span>self, base)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna l'expressió en LaTeX de les imatges dels vectors de la base "base"</p>
<h2 id="parametres">Paràmetres</h2>
<p>base: element de la classe Base</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def imatges_una_base(self,base):
    &#34;&#34;&#34;
    Retorna l&#39;expressió en LaTeX de les imatges dels vectors de la base &#34;base&#34;
    Paràmetres:
        base: element de la classe Base
    &#34;&#34;&#34;
    if not isinstance(base,Base):
        return None
    if self.dimensio != base.dimensio:
        return None
    ts = []
    for x in base.vecs:
        y = self.transforma(x)
        ts.append(f&#34;T{x} &amp;= {y}&#34;)
    ts = &#34; \\\\ \n&#34;.join(ts)
    str = &#34;\\left.\\begin{aligned}\nIMATGES\n\\end{aligned}\\,\\right\\}&#34;
    return str.replace(&#39;IMATGES&#39;,ts)</code></pre>
</details>
</dd>
<dt id="Algebra.TransformacioLineal.latex"><code class="name flex">
<span>def <span class="ident">latex</span></span>(<span>self, base=None, prime=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna l'expressió en latex de la transformació lineal en la base "base"
Si base és None, serà en la base canònica</p>
<h2 id="parametres">Paràmetres</h2>
<p>base: base de R^n
prime: nombre de primes que s'han d'escriure</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def latex(self,base=None,prime=0):
    &#34;&#34;&#34;
    Retorna l&#39;expressió en latex de la transformació lineal en la base &#34;base&#34;
    Si base és None, serà en la base canònica
    Paràmetres:
        base: base de R^n
        prime: nombre de primes que s&#39;han d&#39;escriure
    &#34;&#34;&#34;
    if self.dimensio &lt;= 4:
        x, y, z, t = symbols(&#39;x y z t&#39;)
        u, v, w, r = symbols(&#39;u v w r&#39;)
        o = [x,y,z,t]
        d = [u,v,w,r]
    else:
        x1, x2, x3, x4, x5, x6, x7, x8 = symbols(&#39;x1 x2 x3 x4 x5 x6 x7 x8&#39;)
        u1, u2, u3, u4, u5, u6, u7, u8 = symbols(&#39;u1 u2 u3 u4 u5 u6 u7 u8&#39;)
        o = [x1, x2, x3, x4, x5, x6, x7, x8]
        d = [u1, u2, u3, u4, u5, u6, u7, u8]
    o = o[0:self.dimensio]
    d = d[0:self.dimensio]
    p = prime * &#34;&#39;&#34;
    o = &#34; \\\\ &#34;.join([latex(x)+p for x in o])
    d = &#34; \\\\ &#34;.join([latex(x)+p for x in d])
    if base is None:
         m = self.canonica
         m.set_format(self.format)
    else:
        if not isinstance(base,Base):
            return None
        c = base.matriu()
        m = c.matriu**(-1) * self.canonica.matriu * c.matriu
        m = Matriu(m)
        m.set_format(self.format)
    s = &#34;\\begin{pmatrix}{c} &#34; + d + &#34;\\end{pmatrix} = \n&#34;
    s += f&#34;{m}\n&#34;
    s += &#34;\\begin{pmatrix}{c} &#34; + o + &#34;\\end{pmatrix}&#34;
    return s</code></pre>
</details>
</dd>
<dt id="Algebra.TransformacioLineal.matriu_en_base"><code class="name flex">
<span>def <span class="ident">matriu_en_base</span></span>(<span>self, base)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la matriu de la transformacio lineal en la base "base"</p>
<h2 id="parametres">Paràmetres</h2>
<p>base: base de R^n (classe Base)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def matriu_en_base(self,base):
    &#34;&#34;&#34;
    Retorna la matriu de la transformacio lineal en la base &#34;base&#34;
    Paràmetres:
        base: base de R^n (classe Base)
    &#34;&#34;&#34;
    if base is None:
        return self.canonica
    c = base.matriu()
    m = c.matriu**(-1) * self.canonica.matriu * c.matriu
    return Matriu(m)</code></pre>
</details>
</dd>
<dt id="Algebra.TransformacioLineal.polinomi_caracteristic"><code class="name flex">
<span>def <span class="ident">polinomi_caracteristic</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el polinomi característic de la transformació lineal</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def polinomi_caracteristic(self):
    &#34;&#34;&#34;
    Retorna el polinomi característic de la transformació lineal
    &#34;&#34;&#34;
    return self.canonica.polinomi_caracteristic()</code></pre>
</details>
</dd>
<dt id="Algebra.TransformacioLineal.quaternio"><code class="name flex">
<span>def <span class="ident">quaternio</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna un dels quaternions que definieix una rotació. Recordem
que l'altre és l'oposat</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def quaternio(self):
    &#34;&#34;&#34;
    Retorna un dels quaternions que definieix una rotació. Recordem
    que l&#39;altre és l&#39;oposat
    &#34;&#34;&#34;
    if not self.es_rotacio():
        return None
    w, angle = self.eix_angle_rotacio(radiants=True)
    w.simplificar(positiu=True)
    w.normalitzar()
    w *= sin(angle/2)
    w = Vector([radsimp(x.expand()) for x in w.components])
    return Vector(radsimp(radsimp(cos(angle/2).expand())),w[0],w[1],w[2])</code></pre>
</details>
</dd>
<dt id="Algebra.TransformacioLineal.rang"><code class="name flex">
<span>def <span class="ident">rang</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el rang de la transfoprmació afí</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rang(self):
    &#34;&#34;&#34;
    Retorna el rang de la transfoprmació afí
    &#34;&#34;&#34;
    return self.canonica.rang()</code></pre>
</details>
</dd>
<dt id="Algebra.TransformacioLineal.rank"><code class="name flex">
<span>def <span class="ident">rank</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el rang de la transfoprmació afí</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rank(self):
    &#34;&#34;&#34;
    Retorna el rang de la transfoprmació afí
    &#34;&#34;&#34;
    return self.canonica.rang()</code></pre>
</details>
</dd>
<dt id="Algebra.TransformacioLineal.set_format"><code class="name flex">
<span>def <span class="ident">set_format</span></span>(<span>self, format)</span>
</code></dt>
<dd>
<div class="desc"><p>Estableix el format LaTeX per a la matriu</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_format(self,format):
    &#34;&#34;&#34;
    Estableix el format LaTeX per a la matriu
    &#34;&#34;&#34;
    self.format = format</code></pre>
</details>
</dd>
<dt id="Algebra.TransformacioLineal.transforma"><code class="name flex">
<span>def <span class="ident">transforma</span></span>(<span>self, vec, base=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calcula el transformat (imatge) del vector "vec".</p>
<h2 id="parametres">Paràmetres</h2>
<p>vec: vector
base: si no és None, vec seran les compoents del vectors en aquesta
base. El transformat o imatge també estarà expressat en aquesta base</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transforma(self,vec,base=None):
    &#34;&#34;&#34;
    Calcula el transformat (imatge) del vector &#34;vec&#34;.
    Paràmetres:
        vec: vector
        base: si no és None, vec seran les compoents del vectors en aquesta
        base. El transformat o imatge també estarà expressat en aquesta base
    &#34;&#34;&#34;
    if not isinstance(vec,Vector):
        return None
    if vec.dimensio != self.dimensio:
        return None
    if base is None:
        t = self.canonica * vec
    else:
        if not isinstance(base,Base):
            return None
        c = base.matriu()
        m = c.matriu**(-1) * self.canonica.matriu * c.matriu
        m = Matriu(m)
        t = m * vec
    for k in range(t.dimensio):
        t[k] = simplify(t[k].expand())
    return t</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Algebra.VarietatAfi"><code class="flex name class">
<span>class <span class="ident">VarietatAfi</span></span>
<span>(</span><span>p, s, ref=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Classe per treballar amb varietats lineal</p>
<h2 id="atributs">Atributs</h2>
<p>punt: punt de pas
subespai: SubespaiVectorial</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VarietatAfi(object):
    &#34;&#34;&#34;
    Classe per treballar amb varietats lineal
    Atributs:
       punt: punt de pas
       subespai: SubespaiVectorial
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,p,s,ref=None):
        &#34;&#34;&#34;
        Constructor.
        Retorna la varietat lineal que passa per p i té subespai director s
        Paràmetres:
           p: punt de pas
           s: subespai director
           ref: referència afí en la que estan expressats el punt p
        &#34;&#34;&#34;
        if not isinstance(p,Punt):
            return None
        if not isinstance(s,SubespaiVectorial):
            return None
        if p.dimensio != s.espai:
            return None
        if ref is not None:
            if not isinstance(ref,ReferenciaAfi):
                return None
            if ref.dimensio != p.dimensio:
                return None
        return super(VarietatAfi,cls).__new__(cls)
    #
    #
    #
    def __init__(self,p,s,ref=None):
        self.subespai = s
        if ref is None:
            self.punt = p
        else:
            self.punt = ref.punt_de_coordenades(p)
    #
    #
    #
    def es_un_punt(self):
        &#34;&#34;&#34;
        Retorna True si la varietat lineal és un punt
        &#34;&#34;&#34;
        return self.subespai.es_zero()
    #
    #
    #
    def es_total(self):
        &#34;&#34;&#34;
        Retorna True si la varietat lineal és P_n
        &#34;&#34;&#34;
        return self.subespai.es_total()
    #
    #
    #
    def equacions_implicites(self,ref=None,prime=0):
        &#34;&#34;&#34;
        Retorna unes equacions implícites de la varietat lineal
        Paràmetres:
            ref: referència en la que s&#39;escriuran les equacions implícites
            prime: nombre de primes de les incògnites
        &#34;&#34;&#34;
        if self.es_total():
            return None
        if ref is None:
            q = self.punt
            base = self.subespai.base
        else:
            q = self.punt.coordenades_en_referencia(ref)
            base = [v.components_en_base(ref.base) for v in self.subespai.base]
        a = Matriu.from_vectors_columna(base)
        p = EquacionsParametriques(a,q)
        return (p.eliminar_parametres(prime))
    #
    #
    #
    @classmethod
    def from_equacions_implicites(cls,eqs,ref=None):
        &#34;&#34;&#34;
        Retorna la varietat afí que té equacions implícites &#34;eqs&#34;
        en la referència afí &#34;ref&#34;
        Paràmetres:
            eqs: equacions implícites (classe SistemaEquacions)
            ref: Referència de P^n
        &#34;&#34;&#34;
        s = SubespaiVectorial(eqs.A.nucli())
        eqs.resol()
        sol = list(eqs.parametrica)
        for p in eqs.parametres:
            sol = [k.subs(p,0) for k in sol]
        p = Punt(sol)
        return cls(p,s,ref)
    #
    #
    #
    @classmethod
    def from_equacio_implicita(cls,eq,ref=None):
        &#34;&#34;&#34;
        Retorna la varietat afí que té equació implícita &#34;eq&#34;
        en la referència afí &#34;ref&#34;
        Paràmetres:
            eq: equació implícita (classe EquacioLineal)
            ref: Referència de P^n
        &#34;&#34;&#34;
        if not isinstance(eq,EquacioLineal):
            return None
        s = eq.to_sistema_equacions()
        return cls.from_equacions_implicites(s,ref)
    #
    #
    #
    def base_ortogonal(self):
        &#34;&#34;&#34;
        Retorna una base ortogonal del subespai director de la varietat lineal
        &#34;&#34;&#34;
        return self.subespai.base_ortogonal()
    #
    #
    #
    def varietat_ortogonal(self,p):
        &#34;&#34;&#34;
        Retorna la varietat ortogonal a l&#39;actual que passa pel punt p
        &#34;&#34;&#34;
        if not isinstance(p,Punt):
            return None
        if p.dimensio != self.subespai.espai:
            return None
        s = self.subespai.suplementari_ortogonal()
        return VarietatAfi(p,s)
    #
    #
    #
    def projeccio_ortogonal(self,punt):
        &#34;&#34;&#34;
        Retorna la projecció ortogonal del punt &#34;punt&#34; sobre la
        varietat afi
        Paràmetres:
          punt: Punt
        &#34;&#34;&#34;
        if not isinstance(punt,Punt):
            return None
        if punt.dimensio != self.subespai.espai:
            return None
        return (self.punt + self.subespai.projeccio_ortogonal(punt - self.punt)).punt()
    #
    #
    #
    def simetric(self,punt):
        &#34;&#34;&#34;
        Retorna el simètric del punt &#34;punt&#34; respecte a la varietat afí
        Paràmetres:
          punt: Punt
        &#34;&#34;&#34;
        return 2*self.projeccio_ortogonal(punt) - punt
    #
    #
    #
    def __repr__(self):
        &#34;&#34;&#34;
        Retorna l&#39;expressió en latex de la varietat afi
        &#34;&#34;&#34;
        return f&#34;{self.punt}+{self.subespai}&#34;</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="Algebra.VarietatAfi.from_equacio_implicita"><code class="name flex">
<span>def <span class="ident">from_equacio_implicita</span></span>(<span>eq, ref=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la varietat afí que té equació implícita "eq"
en la referència afí "ref"</p>
<h2 id="parametres">Paràmetres</h2>
<p>eq: equació implícita (classe EquacioLineal)
ref: Referència de P^n</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_equacio_implicita(cls,eq,ref=None):
    &#34;&#34;&#34;
    Retorna la varietat afí que té equació implícita &#34;eq&#34;
    en la referència afí &#34;ref&#34;
    Paràmetres:
        eq: equació implícita (classe EquacioLineal)
        ref: Referència de P^n
    &#34;&#34;&#34;
    if not isinstance(eq,EquacioLineal):
        return None
    s = eq.to_sistema_equacions()
    return cls.from_equacions_implicites(s,ref)</code></pre>
</details>
</dd>
<dt id="Algebra.VarietatAfi.from_equacions_implicites"><code class="name flex">
<span>def <span class="ident">from_equacions_implicites</span></span>(<span>eqs, ref=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la varietat afí que té equacions implícites "eqs"
en la referència afí "ref"</p>
<h2 id="parametres">Paràmetres</h2>
<p>eqs: equacions implícites (classe SistemaEquacions)
ref: Referència de P^n</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_equacions_implicites(cls,eqs,ref=None):
    &#34;&#34;&#34;
    Retorna la varietat afí que té equacions implícites &#34;eqs&#34;
    en la referència afí &#34;ref&#34;
    Paràmetres:
        eqs: equacions implícites (classe SistemaEquacions)
        ref: Referència de P^n
    &#34;&#34;&#34;
    s = SubespaiVectorial(eqs.A.nucli())
    eqs.resol()
    sol = list(eqs.parametrica)
    for p in eqs.parametres:
        sol = [k.subs(p,0) for k in sol]
    p = Punt(sol)
    return cls(p,s,ref)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Algebra.VarietatAfi.base_ortogonal"><code class="name flex">
<span>def <span class="ident">base_ortogonal</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna una base ortogonal del subespai director de la varietat lineal</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def base_ortogonal(self):
    &#34;&#34;&#34;
    Retorna una base ortogonal del subespai director de la varietat lineal
    &#34;&#34;&#34;
    return self.subespai.base_ortogonal()</code></pre>
</details>
</dd>
<dt id="Algebra.VarietatAfi.equacions_implicites"><code class="name flex">
<span>def <span class="ident">equacions_implicites</span></span>(<span>self, ref=None, prime=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna unes equacions implícites de la varietat lineal</p>
<h2 id="parametres">Paràmetres</h2>
<p>ref: referència en la que s'escriuran les equacions implícites
prime: nombre de primes de les incògnites</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def equacions_implicites(self,ref=None,prime=0):
    &#34;&#34;&#34;
    Retorna unes equacions implícites de la varietat lineal
    Paràmetres:
        ref: referència en la que s&#39;escriuran les equacions implícites
        prime: nombre de primes de les incògnites
    &#34;&#34;&#34;
    if self.es_total():
        return None
    if ref is None:
        q = self.punt
        base = self.subespai.base
    else:
        q = self.punt.coordenades_en_referencia(ref)
        base = [v.components_en_base(ref.base) for v in self.subespai.base]
    a = Matriu.from_vectors_columna(base)
    p = EquacionsParametriques(a,q)
    return (p.eliminar_parametres(prime))</code></pre>
</details>
</dd>
<dt id="Algebra.VarietatAfi.es_total"><code class="name flex">
<span>def <span class="ident">es_total</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna True si la varietat lineal és P_n</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def es_total(self):
    &#34;&#34;&#34;
    Retorna True si la varietat lineal és P_n
    &#34;&#34;&#34;
    return self.subespai.es_total()</code></pre>
</details>
</dd>
<dt id="Algebra.VarietatAfi.es_un_punt"><code class="name flex">
<span>def <span class="ident">es_un_punt</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna True si la varietat lineal és un punt</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def es_un_punt(self):
    &#34;&#34;&#34;
    Retorna True si la varietat lineal és un punt
    &#34;&#34;&#34;
    return self.subespai.es_zero()</code></pre>
</details>
</dd>
<dt id="Algebra.VarietatAfi.projeccio_ortogonal"><code class="name flex">
<span>def <span class="ident">projeccio_ortogonal</span></span>(<span>self, punt)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la projecció ortogonal del punt "punt" sobre la
varietat afi</p>
<h2 id="parametres">Paràmetres</h2>
<p>punt: Punt</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def projeccio_ortogonal(self,punt):
    &#34;&#34;&#34;
    Retorna la projecció ortogonal del punt &#34;punt&#34; sobre la
    varietat afi
    Paràmetres:
      punt: Punt
    &#34;&#34;&#34;
    if not isinstance(punt,Punt):
        return None
    if punt.dimensio != self.subespai.espai:
        return None
    return (self.punt + self.subespai.projeccio_ortogonal(punt - self.punt)).punt()</code></pre>
</details>
</dd>
<dt id="Algebra.VarietatAfi.simetric"><code class="name flex">
<span>def <span class="ident">simetric</span></span>(<span>self, punt)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el simètric del punt "punt" respecte a la varietat afí</p>
<h2 id="parametres">Paràmetres</h2>
<p>punt: Punt</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simetric(self,punt):
    &#34;&#34;&#34;
    Retorna el simètric del punt &#34;punt&#34; respecte a la varietat afí
    Paràmetres:
      punt: Punt
    &#34;&#34;&#34;
    return 2*self.projeccio_ortogonal(punt) - punt</code></pre>
</details>
</dd>
<dt id="Algebra.VarietatAfi.varietat_ortogonal"><code class="name flex">
<span>def <span class="ident">varietat_ortogonal</span></span>(<span>self, p)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la varietat ortogonal a l'actual que passa pel punt p</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def varietat_ortogonal(self,p):
    &#34;&#34;&#34;
    Retorna la varietat ortogonal a l&#39;actual que passa pel punt p
    &#34;&#34;&#34;
    if not isinstance(p,Punt):
        return None
    if p.dimensio != self.subespai.espai:
        return None
    s = self.subespai.suplementari_ortogonal()
    return VarietatAfi(p,s)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Algebra.Vector"><code class="flex name class">
<span>class <span class="ident">Vector</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><p>Classe que ens permetrà representar vectors i punts</p>
<h2 id="atributs">Atributs</h2>
<p>dimensio: el nombre de components o longitud del vector
components: llista amb les components del vector
big: si ha d'escrire \left( &hellip;
ight)</p>
<p>Constructor.</p>
<h2 id="parametres">Paràmetres</h2>
<p>c: Una única llista de nombres o una llista de paràmetres
que han de ser nombres</p>
<h2 id="exemples">Exemples</h2>
<p>u = Vector([2,3,1,2])
v = Vector(3,1,-2)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Vector(object):
    &#34;&#34;&#34;
    Classe que ens permetrà representar vectors i punts
    Atributs:
        dimensio: el nombre de components o longitud del vector
        components: llista amb les components del vector
        big: si ha d&#39;escrire \left( ... \right)
    &#34;&#34;&#34;
    #
    #
    #
    def __new__(cls,*args):
        if len(args) == 0:
            return None
        if len(args) == 1:
            if isinstance(args[0],list) or isinstance(args[0],tuple):
                return super(Vector,cls).__new__(cls)
        else:
            if isinstance(args[0],list) or isinstance(args[0],tuple):
                return None
            return super(Vector,cls).__new__(cls)
        return None
    #
    #
    #
    def __init__(self,*args):
        &#34;&#34;&#34;
        Constructor.
        Paràmetres:
           c: Una única llista de nombres o una llista de paràmetres
              que han de ser nombres
        Exemples:
           u = Vector([2,3,1,2])
           v = Vector(3,1,-2)
        &#34;&#34;&#34;
        if len(args) == 1:
            c = args[0]
        else:
            c = list(args)
        self.dimensio = len(c)
        self.components = list(c)
        self.big = False
    #
    #
    #
    @classmethod
    def nul(cls,dim):
        &#34;&#34;&#34;
        Retorna el vector nul de longitud dim
        &#34;&#34;&#34;
        l = [0 for i in range(dim)]
        return cls(l)
    #
    #
    #
    @classmethod
    def aleatori(cls,l=3,maxim=5,nuls=True,positius=False):
        &#34;&#34;&#34;
        Retorna un vector aleatori de longitud l
        Paràmetres:
           l: longitud del vector
           maxim: Nombre màxin que pot contenir en valor absolut
           nuls: Si pot contenir el valor 0 o no
           positius: Si els coeficients han de set tots positius
        &#34;&#34;&#34;
        if positius:
            c = [random.randint(1,maxim) for i in range(l)]
            values = [i for i in range(1,maxim + 1)]
            m = maxim
        else:
            c = [random.randint(-maxim,maxim) for i in range(l)]
            values = [i for i in range(1,maxim + 1)] + [-i for i in range(1,maxim + 1)]
            m = 2 * maxim - 1
        if not nuls:
            for i in range(l):
                if c[i] == 0:
                    c[i] = values[random.randint(0,m)]
        return cls(c)
    #
    #
    #
    def set_big(self,big=True):
        &#34;&#34;&#34;
           Activa o desactiva l&#39;opció \left( ... \right)
        &#34;&#34;&#34;
        self.big = big
    #
    #
    #
    def tots_enters(self):
        &#34;&#34;&#34;
        Retorna True si totes les components del vector són nombres enters
        &#34;&#34;&#34;
        for k in self.components:
            if not (isinstance(k,Integer) or isinstance(k,int)):
                return False
        return True
    #
    #
    #
    def factor_comu(self):
        &#34;&#34;&#34;
        En cas que totes les components del vector sigui enteres o racionals,
        torna el racional que es pot treure factor comú i el vector simplificat.
        Si hi ha components que no són ni enteres ni racionals, torna 1 i el mateix
        vector
        &#34;&#34;&#34;
        l = []
        s = []
        square = False
        other = False
        for k in self.components:
            if isinstance(k,Rational):
                l.append(k.q)
                s.append(False)
            elif isinstance(k,int) or isinstance(k,Integer):
                l.append(1)
                s.append(False)
            elif isinstance(k**2,Rational):
                square = True
                k2 = k**2
                l.append(k2.q)
                s.append(True)
            elif isinstance(k,Add):
                for a in k.args:
                    if isinstance(a,Rational):
                        l.append(a.q)
                        s.append(False)
                    elif isinstance(a,int) or isinstance(a,Integer):
                        l.append(1)
                        s.append(False)
                    elif isinstance(a**2,Rational):
                        square = True
                        a2 = a**2
                        l.append(a2.q)
                        s.append(True)
                    elif isinstance(a,Mul):
                        for b in a.args:
                            if isinstance(b,Rational):
                                l.append(b.q)
                                s.append(False)
            elif isinstance(k,Mul):
                for a in k.args:
                    if isinstance(a,Rational):
                        l.append(a.q)
                        s.append(False)
           # elif k in self.incognites:
           #     pass
            else:
                other = True
        if other:
            return 1, self
        if square:
            for k in range(len(l)):
                if not s[k]:
                    l[k] = l[k]**2
        m = mcm_llista(l)
        if square:
            m = sqrt(m)
        if isinstance(self,Punt):
            return m, Punt([m*k for k in self.components])
        return m, Vector([m*k for k in self.components])
    #
    #
    #
    def es_proporcional(self,other):
        &#34;&#34;&#34;
        Retorna si és proporcional al vector &#34;other&#34;
        Paràmetres:
          other: un altre vector
        &#34;&#34;&#34;
        if not isinstance(other,Vector):
            return None
        m = Matriu.from_vectors_columna([self,other])
        return m.rang() == 1
    #
    #
    #
    def __repr__(self):
        &#34;&#34;&#34;
        Retorna l&#39;expressió en latex del vector
        &#34;&#34;&#34;
        x, y, z, t = symbols(&#39;x y z t&#39;)
        x1, x2, x3, x4, x5, x6, x7, x8 = symbols(&#39;x1 x2 x3 x4 x5 x6 x7 x8&#39;)
        incognites = [x,y,z,t,x1,x2,x3,x4,x5,x6,x7,x8]
        l = []
        s = []
        square = False
        other = False
        for k in self.components:
            if isinstance(k,Rational):
                l.append(k.q)
                s.append(False)
            elif isinstance(k,int) or isinstance(k,Integer):
                l.append(1)
                s.append(False)
            elif isinstance(k**2,Rational):
                square = True
                k2 = k**2
                l.append(k2.q)
                s.append(True)
            elif isinstance(k,Add):
                for a in k.args:
                    if isinstance(a,Rational):
                        l.append(a.q)
                        s.append(False)
                    elif isinstance(a,int) or isinstance(a,Integer):
                        l.append(1)
                        s.append(False)
                    elif isinstance(a**2,Rational):
                        square = True
                        a2 = a**2
                        l.append(a2.q)
                        s.append(True)
                    elif isinstance(a,Mul):
                        for b in a.args:
                            if isinstance(b,Rational):
                                l.append(b.q)
                                s.append(False)
            elif isinstance(k,Mul):
                for a in k.args:
                    if isinstance(a,Rational):
                        l.append(a.q)
                        s.append(False)
            elif k in incognites:
                pass
            else:
                other = True
        if other:
            s = &#34;,&#34;.join([latex(k) for k in self.components])
            return f&#34;\\left({s}\\right)&#34;
        if square:
            for k in range(len(l)):
                if not s[k]:
                    l[k] = l[k]**2
        m = mcm_llista(l)
        if square:
            m = sqrt(m)
        l = [m*k for k in self.components]
        s = &#34;&#34;
        if m != 1:
            s = f&#34;\\deufrac{{1}}{{{latex(m)}}}&#34;
        r = &#34;,&#34;.join([latex(k) for k in l])
        if self.big:
            return f&#34;{s}\\left({r}\\right)&#34;
        return f&#34;{s}({r})&#34;
    #
    #
    #
    def __add__(self,other):
        &#34;&#34;&#34;
        Defineix la suma de vectors.
        Paràmetres:
            other: un altre vector
        Exemple:
            u1 = Vector(3,2,1,3)
            u2 = Vector(-2,4,-3,1)
            v = u1 + u2
        &#34;&#34;&#34;
        if not isinstance(other,Vector) and not isinstance(other,Punt):
            return None
        if self.dimensio != other.dimensio:
            return None
        c1 = self.components
        c2 = other.components
        c = []
        for i in range(self.dimensio):
            c.append(c1[i] + c2[i])
        if isinstance(self,Punt) or isinstance(other,Punt):
            return Punt(c)
        return Vector(c)
    #
    #
    #
    def __sub__(self,other):
        &#34;&#34;&#34;
        Defineix la resta de vectors.
        Paràmetres:
            other: un altre vector
        Exemple:
            u1 = Vector(3,2,1,3)
            u2 = Vector(-2,4,-3,1)
            v = u1 - u2
        &#34;&#34;&#34;
        if not isinstance(other,Vector):
            return None
        if self.dimensio != other.dimensio:
            return None
        c1 = self.components
        c2 = other.components
        c = []
        for i in range(self.dimensio):
            c.append(c1[i] - c2[i])
        if isinstance(self,Punt) and isinstance(other,Vector):
            return Punt(c)
        return Vector(c)
    #
    #
    #
    def __neg__(self):
        &#34;&#34;&#34;
        Retorna l&#39;oposat d&#39;un vector.
        Exemple:
            u1 = Vector(3,2,1,3)
            u2 = - u1
        &#34;&#34;&#34;
        p = [-k for k in self.components]
        if isinstance(self,Punt):
            return Punt(p)
        return Vector(p)
    #
    #
    #
    def __mul__(self,other):
        &#34;&#34;&#34;
        Defineix el producte d&#39;un escalar per un vector i el
        producte d&#39;una vector per una matriu.
        També el producte escalar de dos vectors
        Paràmetres:
            other: un escalar, un vector o una matriu (classe Matriu)
        Exemples:
            u1 = Vector(3,2,1,3)
            u2 = Vector(-2,4,-3,1)
            v = 5 * u1 - 4 * u2
            a = Matriu.aleatoria(f=4,c=2)
            u = v * a
            w = Vector(3,3,1,2)
            p = v * w
        &#34;&#34;&#34;
        types = [Rational,float,int,Float,Pow,Add,Mul]
        for t in types:
            if isinstance(other,t):
                if isinstance(self,Punt):
                    return Punt([other * x for x in self.components])
                return Vector([other * x for x in self.components])
        if isinstance(other,Matriu):
            if self.dimensio != other.files:
                return None
            u = Matrix(1,self.dimensio,self.components)
            v = u * other.matriu
            f, c = v.shape
            r = []
            for i in range(c):
                r.append(v[0,i])
            return Vector(r)
        if isinstance(other,Vector):
            if other.dimensio != self.dimensio:
                return None
            l = [self[i]*other[i] for i in range(self.dimensio)]
            return sum(l)
        return None
    #
    #
    #
    __rmul__ = __mul__
    #
    #
    #
    def __getitem__(self,i):
        &#34;&#34;&#34;
        Permet indexar els elements d&#39;un vector.
        Paràmetres:
            i : índex
        Exemple:
            v = Vector(3,2,1,3,5)
            x = v[2] + v[3]
        &#34;&#34;&#34;
        try:
            return self.components[i]
        except:
            return None
    #
    #
    #
    def __setitem__(self,i,value):
        &#34;&#34;&#34;
        Permet assignar valors mitjançant índexs.
        Paràmetres:
            i     : índex
            valor : valor vàlid del sympy
        Exemple:
            v = Vector.aleatori(l=4)
            v[0] = 3
        &#34;&#34;&#34;
        try:
            self.components[i] = value
        except:
            pass
    #
    #
    #
    def __eq__(self,other):
        &#34;&#34;&#34;
        Determina si dos vectors són iguals
        Paràmetres:
            other: un altre vector
        Exemple:
            u = Vector(1,2,3)
            v = Vector(1,2,3)
            if u == v:
                pass
        &#34;&#34;&#34;
        if self.dimensio != other.dimensio:
            return False
        for k in range(self.dimensio):
            if self[k] != other[k]:
                return False
        return True
    #
    #
    #
    def dot(self,other):
        &#34;&#34;&#34;
        Retorna el producte escalar de dos vectors.
        Paràmetres:
            other: un altre vector
        Exemple:
            u = Vector.aleatori(l=3)
            v = Vector.aleatori(l=3)
            p = u.dot(v)
        &#34;&#34;&#34;
        if not isinstance(other,Vector):
            return None
        if self.dimensio != other.dimensio:
            return None
        s = 0
        for i in range(self.dimensio):
            s += self.components[i] * other.components[i]
        return s
    #
    #
    #
    def length(self):
        &#34;&#34;&#34;
        Retorna la longitud o mòdul del vector
        &#34;&#34;&#34;
        s = 0
        for i in range(self.dimensio):
            s += self.components[i]**2
        return sqrt(s)
    #
    #
    #
    def normalitzar(self):
        &#34;&#34;&#34;
        Converteix el vector en unitari
        Exemple:
            u = Vector(1,2,3)
            u.normalitzar()
        &#34;&#34;&#34;
        l = self.length()
        self.components = [k / l for k in self.components]
    #
    #
    #
    def normalitzat(self):
        &#34;&#34;&#34;
        Retorna el vector unitari en la direcció i sentit del vector
        Exemple:
            u = Vector(1,2,3)
            v = u.normalitzat()
        &#34;&#34;&#34;
        l = self.length()
        return Vector([k / l for k in self.components])
    #
    #
    #
    def maxim(self):
        &#34;&#34;&#34;
        Retorna el màxim dels valors absoluts de les seves components
        Exemple:
            u = Vector.aleatori(l=5,maxim=4,nuls=False)
            m = u.maxim()
        &#34;&#34;&#34;
        m = 0
        for k in self.components:
            v = abs(k)
            if v &gt; m:
                m = v
        return m
    #
    #
    #
    def simplificar(self,positiu=False):
        &#34;&#34;&#34;
        Simplifica el vector, és a dir, converteix les seves components en una
        llista d&#39;enters amb mcd igual a 1.
        Només té sentit si totes les components del vector són nombres enters
        o racionals
        Exemple:
            u = Vector(-1,2,2,Rational(3,2))
            u.simplificar()
        &#34;&#34;&#34;
        if self.length() == 0:
            return
        d = []
        for i in range(self.dimensio):
            k = self.components[i]
            if isinstance(k,Rational):
                d.append(k.q)
            elif isinstance(k,int):
                pass
            elif isinstance(k,Integer):
                pass
            else:
                return
        mcm = mcm_llista(d)
        if mcm &lt; 0:
            mcm *= -1
        v = [mcm * x for x in self.components]
        mcd = mcd_llista(v)
        v = [simplify(k // mcd) for k in v]
        k = 0
        while v[k] == 0 and k &lt; len(v) - 1:
            k += 1
        if positiu and v[k] &lt; 0:
            v = [-x for x in v]
        self.components = list(v)
    #
    #
    #
    def radsimplificar(self):
        &#34;&#34;&#34;
        Simplifica el vector quan alguna de les seves components té radicals
        Exemple:
            u = Vector(sqrt(2),-3*sqrt(2),-sqrt(2))
            u.radsimplificar()
        &#34;&#34;&#34;
        r = Radicals()
        for k in self.components:
            r.busca_quadrats(k)
        a, b = r.mcd()
        if abs(b) != 1:
            for k in range(self.dimensio):
                self.components[k] /= b
        if len(r.quadrats) &lt;=  1:
            for k in range(self.dimensio):
                n = sqrt(a) * self.components[k]
                self.components[k] = simplify(n.expand())
            self.simplificar()
            return
        for k in range(self.dimensio):
            n = sqrt(a) * self.components[k] / a
            self.components[k] = simplify(n.expand())
        r = Radicals()
        for k in self.components:
            r.busca_fraccions(k)
        m = r.mcm()
        if m != 1:
            for k in range(self.dimensio):
                self.components[k] *= m
        self.simplificar()
    #
    #
    #
    def cross(self,other,simplificar=False):
        &#34;&#34;&#34;
        Retorna un nou vector que és el producte vectorial de dos vectors:
        Si simplificar és True, simplifica el vector resultant
        Paràmetres:
            other: un altre vector
            simplificar: si es vol simplificar el resultat o no
        Exemple:
            u = Vector.aleatori(l=3)
            v = Vector.aleatori(l=3)
            w = u.cross(v,simplificar=True)
        &#34;&#34;&#34;
        if not isinstance(other,Vector):
            return None
        if self.dimensio != other.dimensio or self.dimensio != 3:
            return None
        v1 = self.components
        v2 = other.components
        v = [v1[1] * v2[2] - v1[2] * v2[1],- v1[0] * v2[2] + v1[2] * v2[0],v1[0] * v2[1] - v1[1] * v2[0]]
        vec = Vector(v)
        if simplificar:
            vec.simplificar()
        return vec
    #
    #
    #
    def latex(self,unitari=False):
        &#34;&#34;&#34;
        Retorna l&#39;expressió en latex del vector.
        Paràmetres:
            unitari: si unitari és True, el retorna dividit per la seva longitud
        &#34;&#34;&#34;
        if unitari:
            f,v = self.factor_comu()
            l = v.length()
            if l == 1:
                return str(v)
            return f&#34;\\deufrac{{1}}{{{latex(l)}}}{str(v)}&#34;
        return str(self)
    #
    #
    #
    def components_en_base(self,base=None):
        &#34;&#34;&#34;
        Retorna un nou vector amb les components del vector (donem per fet
        que estan en la base canònica) en la base &#34;base&#34;
        Paràmetres:
            base: una base (classe Base)
        &#34;&#34;&#34;
        if base is None:
            return Vector(self.components)
        if not isinstance(base,Base):
            return None
        if self.dimensio != base.dimensio:
            return None
        c = base.matriu()
        return c.inversa() * self
    #
    #
    #
    def reordena_aleatoriament(self):
        &#34;&#34;&#34;
        Retorna un nou vector amb les components reordenades aleatoriament
        &#34;&#34;&#34;
        p = list(range(self.dimensio))
        random.shuffle(p)
        r = [self.components[i] for i in p]
        return Vector(r)
    #
    #
    #
    def nzeros(self):
        &#34;&#34;&#34;
        Retorna el nombre de zeros del vector
        &#34;&#34;&#34;
        n = 0
        for i in self.components:
            if i == 0:
                n += 1
        return n
    #
    #
    #
    def punt(self):
        &#34;&#34;&#34;
        Retorna el Punt corresponent a aquest vector
        &#34;&#34;&#34;
        return Punt(self.components)
    #
    #
    #
    def perpendicular(self):
        &#34;&#34;&#34;
        Retorna una llista de vectors perpendiculars linealment independents
        &#34;&#34;&#34;
        A = Matriu.from_vectors_fila([self])
        return A.nucli()
    #
    #
    #
    def as_quaternio(self):
        &#34;&#34;&#34;
        Retorna l&#39;expressió en LaTeX d&#39;un vector de dimensió 4 en format
        quaternió
        &#34;&#34;&#34;
        i, j, k = symbols(&#34;i j k&#34;)
        if self.dimensio != 4:
            return None
        f, v = self.factor_comu()
        s = &#34;&#34;
        if f != 1:
            s = f&#34;\\deufrac{{1}}{{{latex(f)}}}&#34;
        r = latex(v[1]*i + v[2]*j + v[3]*k)
        if v[0] != 0:
            return f&#34;{s}\\left({latex(v[0])} + {r}\\right)&#34;
        return f&#34;{s}\\left({r}\\right)&#34;
    #
    #
    #
    def diff(self,t,n=1):
        &#34;&#34;&#34;
        Retorna l&#39;enèssima derivada del vector
        &#34;&#34;&#34;
        d = [c.diff(t,n) for c in self.components]
        return Vector(d)
    #
    #
    #
    def subs(self,x,y):
        &#34;&#34;&#34;
        Retorna el vector que s&#39;obté substiuint el símbol x per y
        &#34;&#34;&#34;
        d = [c.subs(x,y) for c in self.components]
        return Vector(d)
    #
    #
    #
    def clona(self):
        &#34;&#34;&#34;
        Retorma una còpia del vector
        &#34;&#34;&#34;
        return Vector(self.components)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="Algebra.Punt" href="#Algebra.Punt">Punt</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="Algebra.Vector.aleatori"><code class="name flex">
<span>def <span class="ident">aleatori</span></span>(<span>l=3, maxim=5, nuls=True, positius=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna un vector aleatori de longitud l</p>
<h2 id="parametres">Paràmetres</h2>
<p>l: longitud del vector
maxim: Nombre màxin que pot contenir en valor absolut
nuls: Si pot contenir el valor 0 o no
positius: Si els coeficients han de set tots positius</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def aleatori(cls,l=3,maxim=5,nuls=True,positius=False):
    &#34;&#34;&#34;
    Retorna un vector aleatori de longitud l
    Paràmetres:
       l: longitud del vector
       maxim: Nombre màxin que pot contenir en valor absolut
       nuls: Si pot contenir el valor 0 o no
       positius: Si els coeficients han de set tots positius
    &#34;&#34;&#34;
    if positius:
        c = [random.randint(1,maxim) for i in range(l)]
        values = [i for i in range(1,maxim + 1)]
        m = maxim
    else:
        c = [random.randint(-maxim,maxim) for i in range(l)]
        values = [i for i in range(1,maxim + 1)] + [-i for i in range(1,maxim + 1)]
        m = 2 * maxim - 1
    if not nuls:
        for i in range(l):
            if c[i] == 0:
                c[i] = values[random.randint(0,m)]
    return cls(c)</code></pre>
</details>
</dd>
<dt id="Algebra.Vector.nul"><code class="name flex">
<span>def <span class="ident">nul</span></span>(<span>dim)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el vector nul de longitud dim</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def nul(cls,dim):
    &#34;&#34;&#34;
    Retorna el vector nul de longitud dim
    &#34;&#34;&#34;
    l = [0 for i in range(dim)]
    return cls(l)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Algebra.Vector.as_quaternio"><code class="name flex">
<span>def <span class="ident">as_quaternio</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna l'expressió en LaTeX d'un vector de dimensió 4 en format
quaternió</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_quaternio(self):
    &#34;&#34;&#34;
    Retorna l&#39;expressió en LaTeX d&#39;un vector de dimensió 4 en format
    quaternió
    &#34;&#34;&#34;
    i, j, k = symbols(&#34;i j k&#34;)
    if self.dimensio != 4:
        return None
    f, v = self.factor_comu()
    s = &#34;&#34;
    if f != 1:
        s = f&#34;\\deufrac{{1}}{{{latex(f)}}}&#34;
    r = latex(v[1]*i + v[2]*j + v[3]*k)
    if v[0] != 0:
        return f&#34;{s}\\left({latex(v[0])} + {r}\\right)&#34;
    return f&#34;{s}\\left({r}\\right)&#34;</code></pre>
</details>
</dd>
<dt id="Algebra.Vector.clona"><code class="name flex">
<span>def <span class="ident">clona</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorma una còpia del vector</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clona(self):
    &#34;&#34;&#34;
    Retorma una còpia del vector
    &#34;&#34;&#34;
    return Vector(self.components)</code></pre>
</details>
</dd>
<dt id="Algebra.Vector.components_en_base"><code class="name flex">
<span>def <span class="ident">components_en_base</span></span>(<span>self, base=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna un nou vector amb les components del vector (donem per fet
que estan en la base canònica) en la base "base"</p>
<h2 id="parametres">Paràmetres</h2>
<p>base: una base (classe Base)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def components_en_base(self,base=None):
    &#34;&#34;&#34;
    Retorna un nou vector amb les components del vector (donem per fet
    que estan en la base canònica) en la base &#34;base&#34;
    Paràmetres:
        base: una base (classe Base)
    &#34;&#34;&#34;
    if base is None:
        return Vector(self.components)
    if not isinstance(base,Base):
        return None
    if self.dimensio != base.dimensio:
        return None
    c = base.matriu()
    return c.inversa() * self</code></pre>
</details>
</dd>
<dt id="Algebra.Vector.cross"><code class="name flex">
<span>def <span class="ident">cross</span></span>(<span>self, other, simplificar=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna un nou vector que és el producte vectorial de dos vectors:
Si simplificar és True, simplifica el vector resultant</p>
<h2 id="parametres">Paràmetres</h2>
<p>other: un altre vector
simplificar: si es vol simplificar el resultat o no</p>
<h2 id="exemple">Exemple</h2>
<p>u = Vector.aleatori(l=3)
v = Vector.aleatori(l=3)
w = u.cross(v,simplificar=True)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cross(self,other,simplificar=False):
    &#34;&#34;&#34;
    Retorna un nou vector que és el producte vectorial de dos vectors:
    Si simplificar és True, simplifica el vector resultant
    Paràmetres:
        other: un altre vector
        simplificar: si es vol simplificar el resultat o no
    Exemple:
        u = Vector.aleatori(l=3)
        v = Vector.aleatori(l=3)
        w = u.cross(v,simplificar=True)
    &#34;&#34;&#34;
    if not isinstance(other,Vector):
        return None
    if self.dimensio != other.dimensio or self.dimensio != 3:
        return None
    v1 = self.components
    v2 = other.components
    v = [v1[1] * v2[2] - v1[2] * v2[1],- v1[0] * v2[2] + v1[2] * v2[0],v1[0] * v2[1] - v1[1] * v2[0]]
    vec = Vector(v)
    if simplificar:
        vec.simplificar()
    return vec</code></pre>
</details>
</dd>
<dt id="Algebra.Vector.diff"><code class="name flex">
<span>def <span class="ident">diff</span></span>(<span>self, t, n=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna l'enèssima derivada del vector</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def diff(self,t,n=1):
    &#34;&#34;&#34;
    Retorna l&#39;enèssima derivada del vector
    &#34;&#34;&#34;
    d = [c.diff(t,n) for c in self.components]
    return Vector(d)</code></pre>
</details>
</dd>
<dt id="Algebra.Vector.dot"><code class="name flex">
<span>def <span class="ident">dot</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el producte escalar de dos vectors.</p>
<h2 id="parametres">Paràmetres</h2>
<p>other: un altre vector</p>
<h2 id="exemple">Exemple</h2>
<p>u = Vector.aleatori(l=3)
v = Vector.aleatori(l=3)
p = u.dot(v)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dot(self,other):
    &#34;&#34;&#34;
    Retorna el producte escalar de dos vectors.
    Paràmetres:
        other: un altre vector
    Exemple:
        u = Vector.aleatori(l=3)
        v = Vector.aleatori(l=3)
        p = u.dot(v)
    &#34;&#34;&#34;
    if not isinstance(other,Vector):
        return None
    if self.dimensio != other.dimensio:
        return None
    s = 0
    for i in range(self.dimensio):
        s += self.components[i] * other.components[i]
    return s</code></pre>
</details>
</dd>
<dt id="Algebra.Vector.es_proporcional"><code class="name flex">
<span>def <span class="ident">es_proporcional</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna si és proporcional al vector "other"</p>
<h2 id="parametres">Paràmetres</h2>
<p>other: un altre vector</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def es_proporcional(self,other):
    &#34;&#34;&#34;
    Retorna si és proporcional al vector &#34;other&#34;
    Paràmetres:
      other: un altre vector
    &#34;&#34;&#34;
    if not isinstance(other,Vector):
        return None
    m = Matriu.from_vectors_columna([self,other])
    return m.rang() == 1</code></pre>
</details>
</dd>
<dt id="Algebra.Vector.factor_comu"><code class="name flex">
<span>def <span class="ident">factor_comu</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>En cas que totes les components del vector sigui enteres o racionals,
torna el racional que es pot treure factor comú i el vector simplificat.
Si hi ha components que no són ni enteres ni racionals, torna 1 i el mateix
vector</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def factor_comu(self):
    &#34;&#34;&#34;
    En cas que totes les components del vector sigui enteres o racionals,
    torna el racional que es pot treure factor comú i el vector simplificat.
    Si hi ha components que no són ni enteres ni racionals, torna 1 i el mateix
    vector
    &#34;&#34;&#34;
    l = []
    s = []
    square = False
    other = False
    for k in self.components:
        if isinstance(k,Rational):
            l.append(k.q)
            s.append(False)
        elif isinstance(k,int) or isinstance(k,Integer):
            l.append(1)
            s.append(False)
        elif isinstance(k**2,Rational):
            square = True
            k2 = k**2
            l.append(k2.q)
            s.append(True)
        elif isinstance(k,Add):
            for a in k.args:
                if isinstance(a,Rational):
                    l.append(a.q)
                    s.append(False)
                elif isinstance(a,int) or isinstance(a,Integer):
                    l.append(1)
                    s.append(False)
                elif isinstance(a**2,Rational):
                    square = True
                    a2 = a**2
                    l.append(a2.q)
                    s.append(True)
                elif isinstance(a,Mul):
                    for b in a.args:
                        if isinstance(b,Rational):
                            l.append(b.q)
                            s.append(False)
        elif isinstance(k,Mul):
            for a in k.args:
                if isinstance(a,Rational):
                    l.append(a.q)
                    s.append(False)
       # elif k in self.incognites:
       #     pass
        else:
            other = True
    if other:
        return 1, self
    if square:
        for k in range(len(l)):
            if not s[k]:
                l[k] = l[k]**2
    m = mcm_llista(l)
    if square:
        m = sqrt(m)
    if isinstance(self,Punt):
        return m, Punt([m*k for k in self.components])
    return m, Vector([m*k for k in self.components])</code></pre>
</details>
</dd>
<dt id="Algebra.Vector.latex"><code class="name flex">
<span>def <span class="ident">latex</span></span>(<span>self, unitari=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna l'expressió en latex del vector.</p>
<h2 id="parametres">Paràmetres</h2>
<p>unitari: si unitari és True, el retorna dividit per la seva longitud</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def latex(self,unitari=False):
    &#34;&#34;&#34;
    Retorna l&#39;expressió en latex del vector.
    Paràmetres:
        unitari: si unitari és True, el retorna dividit per la seva longitud
    &#34;&#34;&#34;
    if unitari:
        f,v = self.factor_comu()
        l = v.length()
        if l == 1:
            return str(v)
        return f&#34;\\deufrac{{1}}{{{latex(l)}}}{str(v)}&#34;
    return str(self)</code></pre>
</details>
</dd>
<dt id="Algebra.Vector.length"><code class="name flex">
<span>def <span class="ident">length</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna la longitud o mòdul del vector</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def length(self):
    &#34;&#34;&#34;
    Retorna la longitud o mòdul del vector
    &#34;&#34;&#34;
    s = 0
    for i in range(self.dimensio):
        s += self.components[i]**2
    return sqrt(s)</code></pre>
</details>
</dd>
<dt id="Algebra.Vector.maxim"><code class="name flex">
<span>def <span class="ident">maxim</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el màxim dels valors absoluts de les seves components</p>
<h2 id="exemple">Exemple</h2>
<p>u = Vector.aleatori(l=5,maxim=4,nuls=False)
m = u.maxim()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def maxim(self):
    &#34;&#34;&#34;
    Retorna el màxim dels valors absoluts de les seves components
    Exemple:
        u = Vector.aleatori(l=5,maxim=4,nuls=False)
        m = u.maxim()
    &#34;&#34;&#34;
    m = 0
    for k in self.components:
        v = abs(k)
        if v &gt; m:
            m = v
    return m</code></pre>
</details>
</dd>
<dt id="Algebra.Vector.normalitzar"><code class="name flex">
<span>def <span class="ident">normalitzar</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Converteix el vector en unitari</p>
<h2 id="exemple">Exemple</h2>
<p>u = Vector(1,2,3)
u.normalitzar()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalitzar(self):
    &#34;&#34;&#34;
    Converteix el vector en unitari
    Exemple:
        u = Vector(1,2,3)
        u.normalitzar()
    &#34;&#34;&#34;
    l = self.length()
    self.components = [k / l for k in self.components]</code></pre>
</details>
</dd>
<dt id="Algebra.Vector.normalitzat"><code class="name flex">
<span>def <span class="ident">normalitzat</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el vector unitari en la direcció i sentit del vector</p>
<h2 id="exemple">Exemple</h2>
<p>u = Vector(1,2,3)
v = u.normalitzat()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalitzat(self):
    &#34;&#34;&#34;
    Retorna el vector unitari en la direcció i sentit del vector
    Exemple:
        u = Vector(1,2,3)
        v = u.normalitzat()
    &#34;&#34;&#34;
    l = self.length()
    return Vector([k / l for k in self.components])</code></pre>
</details>
</dd>
<dt id="Algebra.Vector.nzeros"><code class="name flex">
<span>def <span class="ident">nzeros</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el nombre de zeros del vector</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nzeros(self):
    &#34;&#34;&#34;
    Retorna el nombre de zeros del vector
    &#34;&#34;&#34;
    n = 0
    for i in self.components:
        if i == 0:
            n += 1
    return n</code></pre>
</details>
</dd>
<dt id="Algebra.Vector.perpendicular"><code class="name flex">
<span>def <span class="ident">perpendicular</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna una llista de vectors perpendiculars linealment independents</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def perpendicular(self):
    &#34;&#34;&#34;
    Retorna una llista de vectors perpendiculars linealment independents
    &#34;&#34;&#34;
    A = Matriu.from_vectors_fila([self])
    return A.nucli()</code></pre>
</details>
</dd>
<dt id="Algebra.Vector.punt"><code class="name flex">
<span>def <span class="ident">punt</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el Punt corresponent a aquest vector</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def punt(self):
    &#34;&#34;&#34;
    Retorna el Punt corresponent a aquest vector
    &#34;&#34;&#34;
    return Punt(self.components)</code></pre>
</details>
</dd>
<dt id="Algebra.Vector.radsimplificar"><code class="name flex">
<span>def <span class="ident">radsimplificar</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Simplifica el vector quan alguna de les seves components té radicals</p>
<h2 id="exemple">Exemple</h2>
<p>u = Vector(sqrt(2),-3*sqrt(2),-sqrt(2))
u.radsimplificar()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def radsimplificar(self):
    &#34;&#34;&#34;
    Simplifica el vector quan alguna de les seves components té radicals
    Exemple:
        u = Vector(sqrt(2),-3*sqrt(2),-sqrt(2))
        u.radsimplificar()
    &#34;&#34;&#34;
    r = Radicals()
    for k in self.components:
        r.busca_quadrats(k)
    a, b = r.mcd()
    if abs(b) != 1:
        for k in range(self.dimensio):
            self.components[k] /= b
    if len(r.quadrats) &lt;=  1:
        for k in range(self.dimensio):
            n = sqrt(a) * self.components[k]
            self.components[k] = simplify(n.expand())
        self.simplificar()
        return
    for k in range(self.dimensio):
        n = sqrt(a) * self.components[k] / a
        self.components[k] = simplify(n.expand())
    r = Radicals()
    for k in self.components:
        r.busca_fraccions(k)
    m = r.mcm()
    if m != 1:
        for k in range(self.dimensio):
            self.components[k] *= m
    self.simplificar()</code></pre>
</details>
</dd>
<dt id="Algebra.Vector.reordena_aleatoriament"><code class="name flex">
<span>def <span class="ident">reordena_aleatoriament</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna un nou vector amb les components reordenades aleatoriament</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reordena_aleatoriament(self):
    &#34;&#34;&#34;
    Retorna un nou vector amb les components reordenades aleatoriament
    &#34;&#34;&#34;
    p = list(range(self.dimensio))
    random.shuffle(p)
    r = [self.components[i] for i in p]
    return Vector(r)</code></pre>
</details>
</dd>
<dt id="Algebra.Vector.set_big"><code class="name flex">
<span>def <span class="ident">set_big</span></span>(<span>self, big=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Activa o desactiva l'opció \left( &hellip;
ight)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_big(self,big=True):
    &#34;&#34;&#34;
       Activa o desactiva l&#39;opció \left( ... \right)
    &#34;&#34;&#34;
    self.big = big</code></pre>
</details>
</dd>
<dt id="Algebra.Vector.simplificar"><code class="name flex">
<span>def <span class="ident">simplificar</span></span>(<span>self, positiu=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Simplifica el vector, és a dir, converteix les seves components en una
llista d'enters amb mcd igual a 1.
Només té sentit si totes les components del vector són nombres enters
o racionals</p>
<h2 id="exemple">Exemple</h2>
<p>u = Vector(-1,2,2,Rational(3,2))
u.simplificar()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simplificar(self,positiu=False):
    &#34;&#34;&#34;
    Simplifica el vector, és a dir, converteix les seves components en una
    llista d&#39;enters amb mcd igual a 1.
    Només té sentit si totes les components del vector són nombres enters
    o racionals
    Exemple:
        u = Vector(-1,2,2,Rational(3,2))
        u.simplificar()
    &#34;&#34;&#34;
    if self.length() == 0:
        return
    d = []
    for i in range(self.dimensio):
        k = self.components[i]
        if isinstance(k,Rational):
            d.append(k.q)
        elif isinstance(k,int):
            pass
        elif isinstance(k,Integer):
            pass
        else:
            return
    mcm = mcm_llista(d)
    if mcm &lt; 0:
        mcm *= -1
    v = [mcm * x for x in self.components]
    mcd = mcd_llista(v)
    v = [simplify(k // mcd) for k in v]
    k = 0
    while v[k] == 0 and k &lt; len(v) - 1:
        k += 1
    if positiu and v[k] &lt; 0:
        v = [-x for x in v]
    self.components = list(v)</code></pre>
</details>
</dd>
<dt id="Algebra.Vector.subs"><code class="name flex">
<span>def <span class="ident">subs</span></span>(<span>self, x, y)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el vector que s'obté substiuint el símbol x per y</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subs(self,x,y):
    &#34;&#34;&#34;
    Retorna el vector que s&#39;obté substiuint el símbol x per y
    &#34;&#34;&#34;
    d = [c.subs(x,y) for c in self.components]
    return Vector(d)</code></pre>
</details>
</dd>
<dt id="Algebra.Vector.tots_enters"><code class="name flex">
<span>def <span class="ident">tots_enters</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna True si totes les components del vector són nombres enters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tots_enters(self):
    &#34;&#34;&#34;
    Retorna True si totes les components del vector són nombres enters
    &#34;&#34;&#34;
    for k in self.components:
        if not (isinstance(k,Integer) or isinstance(k,int)):
            return False
    return True</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="Algebra.matriu_latex" href="#Algebra.matriu_latex">matriu_latex</a></code></li>
<li><code><a title="Algebra.matriu_mathematica" href="#Algebra.matriu_mathematica">matriu_mathematica</a></code></li>
<li><code><a title="Algebra.mcd_llista" href="#Algebra.mcd_llista">mcd_llista</a></code></li>
<li><code><a title="Algebra.mcm_llista" href="#Algebra.mcm_llista">mcm_llista</a></code></li>
<li><code><a title="Algebra.mti" href="#Algebra.mti">mti</a></code></li>
<li><code><a title="Algebra.mts" href="#Algebra.mts">mts</a></code></li>
<li><code><a title="Algebra.mylatex" href="#Algebra.mylatex">mylatex</a></code></li>
<li><code><a title="Algebra.nnegatius" href="#Algebra.nnegatius">nnegatius</a></code></li>
<li><code><a title="Algebra.norma_maxim" href="#Algebra.norma_maxim">norma_maxim</a></code></li>
<li><code><a title="Algebra.nzeros" href="#Algebra.nzeros">nzeros</a></code></li>
<li><code><a title="Algebra.primer_no_nul" href="#Algebra.primer_no_nul">primer_no_nul</a></code></li>
<li><code><a title="Algebra.vaps_veps" href="#Algebra.vaps_veps">vaps_veps</a></code></li>
<li><code><a title="Algebra.vaps_veps_amb_signe" href="#Algebra.vaps_veps_amb_signe">vaps_veps_amb_signe</a></code></li>
<li><code><a title="Algebra.vectors_latex" href="#Algebra.vectors_latex">vectors_latex</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="Algebra.Base" href="#Algebra.Base">Base</a></code></h4>
<ul class="">
<li><code><a title="Algebra.Base.aleatoria" href="#Algebra.Base.aleatoria">aleatoria</a></code></li>
<li><code><a title="Algebra.Base.canonica" href="#Algebra.Base.canonica">canonica</a></code></li>
<li><code><a title="Algebra.Base.canvi_de_base_a_la_base" href="#Algebra.Base.canvi_de_base_a_la_base">canvi_de_base_a_la_base</a></code></li>
<li><code><a title="Algebra.Base.components_del_vector" href="#Algebra.Base.components_del_vector">components_del_vector</a></code></li>
<li><code><a title="Algebra.Base.es_ortogonal" href="#Algebra.Base.es_ortogonal">es_ortogonal</a></code></li>
<li><code><a title="Algebra.Base.es_unitaria" href="#Algebra.Base.es_unitaria">es_unitaria</a></code></li>
<li><code><a title="Algebra.Base.from_matriu" href="#Algebra.Base.from_matriu">from_matriu</a></code></li>
<li><code><a title="Algebra.Base.matriu" href="#Algebra.Base.matriu">matriu</a></code></li>
<li><code><a title="Algebra.Base.orientacio_positiva" href="#Algebra.Base.orientacio_positiva">orientacio_positiva</a></code></li>
<li><code><a title="Algebra.Base.ortogonal" href="#Algebra.Base.ortogonal">ortogonal</a></code></li>
<li><code><a title="Algebra.Base.quadrats_longituds" href="#Algebra.Base.quadrats_longituds">quadrats_longituds</a></code></li>
<li><code><a title="Algebra.Base.set_unitaria" href="#Algebra.Base.set_unitaria">set_unitaria</a></code></li>
<li><code><a title="Algebra.Base.te_orientacio_positiva" href="#Algebra.Base.te_orientacio_positiva">te_orientacio_positiva</a></code></li>
<li><code><a title="Algebra.Base.vector_de_components" href="#Algebra.Base.vector_de_components">vector_de_components</a></code></li>
<li><code><a title="Algebra.Base.vectors" href="#Algebra.Base.vectors">vectors</a></code></li>
<li><code><a title="Algebra.Base.vectors_latex" href="#Algebra.Base.vectors_latex">vectors_latex</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Algebra.CilindreElliptic" href="#Algebra.CilindreElliptic">CilindreElliptic</a></code></h4>
<ul class="two-column">
<li><code><a title="Algebra.CilindreElliptic.aleatoria" href="#Algebra.CilindreElliptic.aleatoria">aleatoria</a></code></li>
<li><code><a title="Algebra.CilindreElliptic.centre" href="#Algebra.CilindreElliptic.centre">centre</a></code></li>
<li><code><a title="Algebra.CilindreElliptic.centres" href="#Algebra.CilindreElliptic.centres">centres</a></code></li>
<li><code><a title="Algebra.CilindreElliptic.equacio_reduida" href="#Algebra.CilindreElliptic.equacio_reduida">equacio_reduida</a></code></li>
<li><code><a title="Algebra.CilindreElliptic.semieixos" href="#Algebra.CilindreElliptic.semieixos">semieixos</a></code></li>
<li><code><a title="Algebra.CilindreElliptic.semieixos_quadrats" href="#Algebra.CilindreElliptic.semieixos_quadrats">semieixos_quadrats</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Algebra.CilindreHiperbolic" href="#Algebra.CilindreHiperbolic">CilindreHiperbolic</a></code></h4>
<ul class="two-column">
<li><code><a title="Algebra.CilindreHiperbolic.aleatoria" href="#Algebra.CilindreHiperbolic.aleatoria">aleatoria</a></code></li>
<li><code><a title="Algebra.CilindreHiperbolic.centre" href="#Algebra.CilindreHiperbolic.centre">centre</a></code></li>
<li><code><a title="Algebra.CilindreHiperbolic.centres" href="#Algebra.CilindreHiperbolic.centres">centres</a></code></li>
<li><code><a title="Algebra.CilindreHiperbolic.equacio_reduida" href="#Algebra.CilindreHiperbolic.equacio_reduida">equacio_reduida</a></code></li>
<li><code><a title="Algebra.CilindreHiperbolic.semieixos" href="#Algebra.CilindreHiperbolic.semieixos">semieixos</a></code></li>
<li><code><a title="Algebra.CilindreHiperbolic.semieixos_quadrats" href="#Algebra.CilindreHiperbolic.semieixos_quadrats">semieixos_quadrats</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Algebra.CilindreParabolic" href="#Algebra.CilindreParabolic">CilindreParabolic</a></code></h4>
<ul class="">
<li><code><a title="Algebra.CilindreParabolic.aleatoria" href="#Algebra.CilindreParabolic.aleatoria">aleatoria</a></code></li>
<li><code><a title="Algebra.CilindreParabolic.equacio_reduida" href="#Algebra.CilindreParabolic.equacio_reduida">equacio_reduida</a></code></li>
<li><code><a title="Algebra.CilindreParabolic.parametre" href="#Algebra.CilindreParabolic.parametre">parametre</a></code></li>
<li><code><a title="Algebra.CilindreParabolic.vertex" href="#Algebra.CilindreParabolic.vertex">vertex</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Algebra.Con" href="#Algebra.Con">Con</a></code></h4>
<ul class="">
<li><code><a title="Algebra.Con.aleatoria" href="#Algebra.Con.aleatoria">aleatoria</a></code></li>
<li><code><a title="Algebra.Con.centre" href="#Algebra.Con.centre">centre</a></code></li>
<li><code><a title="Algebra.Con.equacio_reduida" href="#Algebra.Con.equacio_reduida">equacio_reduida</a></code></li>
<li><code><a title="Algebra.Con.semieixos" href="#Algebra.Con.semieixos">semieixos</a></code></li>
<li><code><a title="Algebra.Con.semieixos_quadrats" href="#Algebra.Con.semieixos_quadrats">semieixos_quadrats</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Algebra.Conica" href="#Algebra.Conica">Conica</a></code></h4>
<ul class="">
<li><code><a title="Algebra.Conica.aleatoria" href="#Algebra.Conica.aleatoria">aleatoria</a></code></li>
<li><code><a title="Algebra.Conica.eix_principal" href="#Algebra.Conica.eix_principal">eix_principal</a></code></li>
<li><code><a title="Algebra.Conica.eix_secundari" href="#Algebra.Conica.eix_secundari">eix_secundari</a></code></li>
<li><code><a title="Algebra.Conica.ellipse" href="#Algebra.Conica.ellipse">ellipse</a></code></li>
<li><code><a title="Algebra.Conica.equacio" href="#Algebra.Conica.equacio">equacio</a></code></li>
<li><code><a title="Algebra.Conica.from_equacio" href="#Algebra.Conica.from_equacio">from_equacio</a></code></li>
<li><code><a title="Algebra.Conica.hiperbola" href="#Algebra.Conica.hiperbola">hiperbola</a></code></li>
<li><code><a title="Algebra.Conica.parabola" href="#Algebra.Conica.parabola">parabola</a></code></li>
<li><code><a title="Algebra.Conica.referencia_principal" href="#Algebra.Conica.referencia_principal">referencia_principal</a></code></li>
<li><code><a title="Algebra.Conica.tipus" href="#Algebra.Conica.tipus">tipus</a></code></li>
<li><code><a title="Algebra.Conica.vectors" href="#Algebra.Conica.vectors">vectors</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Algebra.Ellipse" href="#Algebra.Ellipse">Ellipse</a></code></h4>
<ul class="two-column">
<li><code><a title="Algebra.Ellipse.aleatoria" href="#Algebra.Ellipse.aleatoria">aleatoria</a></code></li>
<li><code><a title="Algebra.Ellipse.centre" href="#Algebra.Ellipse.centre">centre</a></code></li>
<li><code><a title="Algebra.Ellipse.equacio_reduida" href="#Algebra.Ellipse.equacio_reduida">equacio_reduida</a></code></li>
<li><code><a title="Algebra.Ellipse.focus" href="#Algebra.Ellipse.focus">focus</a></code></li>
<li><code><a title="Algebra.Ellipse.maxim_origen" href="#Algebra.Ellipse.maxim_origen">maxim_origen</a></code></li>
<li><code><a title="Algebra.Ellipse.semidistancia_focal" href="#Algebra.Ellipse.semidistancia_focal">semidistancia_focal</a></code></li>
<li><code><a title="Algebra.Ellipse.semieix_major" href="#Algebra.Ellipse.semieix_major">semieix_major</a></code></li>
<li><code><a title="Algebra.Ellipse.semieix_menor" href="#Algebra.Ellipse.semieix_menor">semieix_menor</a></code></li>
<li><code><a title="Algebra.Ellipse.to_asy" href="#Algebra.Ellipse.to_asy">to_asy</a></code></li>
<li><code><a title="Algebra.Ellipse.vertexs" href="#Algebra.Ellipse.vertexs">vertexs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Algebra.Ellipsoide" href="#Algebra.Ellipsoide">Ellipsoide</a></code></h4>
<ul class="">
<li><code><a title="Algebra.Ellipsoide.aleatoria" href="#Algebra.Ellipsoide.aleatoria">aleatoria</a></code></li>
<li><code><a title="Algebra.Ellipsoide.centre" href="#Algebra.Ellipsoide.centre">centre</a></code></li>
<li><code><a title="Algebra.Ellipsoide.equacio_reduida" href="#Algebra.Ellipsoide.equacio_reduida">equacio_reduida</a></code></li>
<li><code><a title="Algebra.Ellipsoide.semieixos" href="#Algebra.Ellipsoide.semieixos">semieixos</a></code></li>
<li><code><a title="Algebra.Ellipsoide.semieixos_quadrats" href="#Algebra.Ellipsoide.semieixos_quadrats">semieixos_quadrats</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Algebra.EquacioLineal" href="#Algebra.EquacioLineal">EquacioLineal</a></code></h4>
<ul class="">
<li><code><a title="Algebra.EquacioLineal.coeficients" href="#Algebra.EquacioLineal.coeficients">coeficients</a></code></li>
<li><code><a title="Algebra.EquacioLineal.resol" href="#Algebra.EquacioLineal.resol">resol</a></code></li>
<li><code><a title="Algebra.EquacioLineal.set_coeficient_positiu" href="#Algebra.EquacioLineal.set_coeficient_positiu">set_coeficient_positiu</a></code></li>
<li><code><a title="Algebra.EquacioLineal.terme_independent" href="#Algebra.EquacioLineal.terme_independent">terme_independent</a></code></li>
<li><code><a title="Algebra.EquacioLineal.to_sistema_equacions" href="#Algebra.EquacioLineal.to_sistema_equacions">to_sistema_equacions</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Algebra.EquacioParametrica" href="#Algebra.EquacioParametrica">EquacioParametrica</a></code></h4>
<ul class="">
<li><code><a title="Algebra.EquacioParametrica.coeficients" href="#Algebra.EquacioParametrica.coeficients">coeficients</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Algebra.EquacionsParametriques" href="#Algebra.EquacionsParametriques">EquacionsParametriques</a></code></h4>
<ul class="">
<li><code><a title="Algebra.EquacionsParametriques.eliminar_parametres" href="#Algebra.EquacionsParametriques.eliminar_parametres">eliminar_parametres</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Algebra.FormaQuadratica" href="#Algebra.FormaQuadratica">FormaQuadratica</a></code></h4>
<ul class="">
<li><code><a title="Algebra.FormaQuadratica.aleatoria" href="#Algebra.FormaQuadratica.aleatoria">aleatoria</a></code></li>
<li><code><a title="Algebra.FormaQuadratica.classificacio" href="#Algebra.FormaQuadratica.classificacio">classificacio</a></code></li>
<li><code><a title="Algebra.FormaQuadratica.expressio_euclidiana" href="#Algebra.FormaQuadratica.expressio_euclidiana">expressio_euclidiana</a></code></li>
<li><code><a title="Algebra.FormaQuadratica.latex" href="#Algebra.FormaQuadratica.latex">latex</a></code></li>
<li><code><a title="Algebra.FormaQuadratica.polinomi_caracteristic" href="#Algebra.FormaQuadratica.polinomi_caracteristic">polinomi_caracteristic</a></code></li>
<li><code><a title="Algebra.FormaQuadratica.rank" href="#Algebra.FormaQuadratica.rank">rank</a></code></li>
<li><code><a title="Algebra.FormaQuadratica.signatura" href="#Algebra.FormaQuadratica.signatura">signatura</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Algebra.Hiperbola" href="#Algebra.Hiperbola">Hiperbola</a></code></h4>
<ul class="">
<li><code><a title="Algebra.Hiperbola.aleatoria" href="#Algebra.Hiperbola.aleatoria">aleatoria</a></code></li>
<li><code><a title="Algebra.Hiperbola.centre" href="#Algebra.Hiperbola.centre">centre</a></code></li>
<li><code><a title="Algebra.Hiperbola.equacio_continua_asimptota" href="#Algebra.Hiperbola.equacio_continua_asimptota">equacio_continua_asimptota</a></code></li>
<li><code><a title="Algebra.Hiperbola.equacio_reduida" href="#Algebra.Hiperbola.equacio_reduida">equacio_reduida</a></code></li>
<li><code><a title="Algebra.Hiperbola.focus" href="#Algebra.Hiperbola.focus">focus</a></code></li>
<li><code><a title="Algebra.Hiperbola.maxim_origen" href="#Algebra.Hiperbola.maxim_origen">maxim_origen</a></code></li>
<li><code><a title="Algebra.Hiperbola.semidistancia_focal" href="#Algebra.Hiperbola.semidistancia_focal">semidistancia_focal</a></code></li>
<li><code><a title="Algebra.Hiperbola.semieix_imaginari" href="#Algebra.Hiperbola.semieix_imaginari">semieix_imaginari</a></code></li>
<li><code><a title="Algebra.Hiperbola.semieix_real" href="#Algebra.Hiperbola.semieix_real">semieix_real</a></code></li>
<li><code><a title="Algebra.Hiperbola.to_asy" href="#Algebra.Hiperbola.to_asy">to_asy</a></code></li>
<li><code><a title="Algebra.Hiperbola.vectors_directors_asimptotes" href="#Algebra.Hiperbola.vectors_directors_asimptotes">vectors_directors_asimptotes</a></code></li>
<li><code><a title="Algebra.Hiperbola.vertexs" href="#Algebra.Hiperbola.vertexs">vertexs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Algebra.HiperboloideDuesFulles" href="#Algebra.HiperboloideDuesFulles">HiperboloideDuesFulles</a></code></h4>
<ul class="">
<li><code><a title="Algebra.HiperboloideDuesFulles.aleatoria" href="#Algebra.HiperboloideDuesFulles.aleatoria">aleatoria</a></code></li>
<li><code><a title="Algebra.HiperboloideDuesFulles.centre" href="#Algebra.HiperboloideDuesFulles.centre">centre</a></code></li>
<li><code><a title="Algebra.HiperboloideDuesFulles.equacio_reduida" href="#Algebra.HiperboloideDuesFulles.equacio_reduida">equacio_reduida</a></code></li>
<li><code><a title="Algebra.HiperboloideDuesFulles.semieixos" href="#Algebra.HiperboloideDuesFulles.semieixos">semieixos</a></code></li>
<li><code><a title="Algebra.HiperboloideDuesFulles.semieixos_quadrats" href="#Algebra.HiperboloideDuesFulles.semieixos_quadrats">semieixos_quadrats</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Algebra.HiperboloideUnaFulla" href="#Algebra.HiperboloideUnaFulla">HiperboloideUnaFulla</a></code></h4>
<ul class="">
<li><code><a title="Algebra.HiperboloideUnaFulla.aleatoria" href="#Algebra.HiperboloideUnaFulla.aleatoria">aleatoria</a></code></li>
<li><code><a title="Algebra.HiperboloideUnaFulla.centre" href="#Algebra.HiperboloideUnaFulla.centre">centre</a></code></li>
<li><code><a title="Algebra.HiperboloideUnaFulla.equacio_reduida" href="#Algebra.HiperboloideUnaFulla.equacio_reduida">equacio_reduida</a></code></li>
<li><code><a title="Algebra.HiperboloideUnaFulla.semieixos" href="#Algebra.HiperboloideUnaFulla.semieixos">semieixos</a></code></li>
<li><code><a title="Algebra.HiperboloideUnaFulla.semieixos_quadrats" href="#Algebra.HiperboloideUnaFulla.semieixos_quadrats">semieixos_quadrats</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Algebra.Impresora" href="#Algebra.Impresora">Impresora</a></code></h4>
<ul class="">
<li><code><a title="Algebra.Impresora.printmethod" href="#Algebra.Impresora.printmethod">printmethod</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Algebra.Matriu" href="#Algebra.Matriu">Matriu</a></code></h4>
<ul class="">
<li><code><a title="Algebra.Matriu.adjunta" href="#Algebra.Matriu.adjunta">adjunta</a></code></li>
<li><code><a title="Algebra.Matriu.aleatoria" href="#Algebra.Matriu.aleatoria">aleatoria</a></code></li>
<li><code><a title="Algebra.Matriu.amb_rang" href="#Algebra.Matriu.amb_rang">amb_rang</a></code></li>
<li><code><a title="Algebra.Matriu.anula_coeficient_amb_pivot" href="#Algebra.Matriu.anula_coeficient_amb_pivot">anula_coeficient_amb_pivot</a></code></li>
<li><code><a title="Algebra.Matriu.clona" href="#Algebra.Matriu.clona">clona</a></code></li>
<li><code><a title="Algebra.Matriu.det" href="#Algebra.Matriu.det">det</a></code></li>
<li><code><a title="Algebra.Matriu.determinant" href="#Algebra.Matriu.determinant">determinant</a></code></li>
<li><code><a title="Algebra.Matriu.diagonal" href="#Algebra.Matriu.diagonal">diagonal</a></code></li>
<li><code><a title="Algebra.Matriu.diagonalitza" href="#Algebra.Matriu.diagonalitza">diagonalitza</a></code></li>
<li><code><a title="Algebra.Matriu.diagonalitzable" href="#Algebra.Matriu.diagonalitzable">diagonalitzable</a></code></li>
<li><code><a title="Algebra.Matriu.es_diagonal" href="#Algebra.Matriu.es_diagonal">es_diagonal</a></code></li>
<li><code><a title="Algebra.Matriu.es_simetrica" href="#Algebra.Matriu.es_simetrica">es_simetrica</a></code></li>
<li><code><a title="Algebra.Matriu.factor_comu" href="#Algebra.Matriu.factor_comu">factor_comu</a></code></li>
<li><code><a title="Algebra.Matriu.from_vectors_columna" href="#Algebra.Matriu.from_vectors_columna">from_vectors_columna</a></code></li>
<li><code><a title="Algebra.Matriu.from_vectors_fila" href="#Algebra.Matriu.from_vectors_fila">from_vectors_fila</a></code></li>
<li><code><a title="Algebra.Matriu.gram" href="#Algebra.Matriu.gram">gram</a></code></li>
<li><code><a title="Algebra.Matriu.identitat" href="#Algebra.Matriu.identitat">identitat</a></code></li>
<li><code><a title="Algebra.Matriu.inserta_columna" href="#Algebra.Matriu.inserta_columna">inserta_columna</a></code></li>
<li><code><a title="Algebra.Matriu.inserta_fila" href="#Algebra.Matriu.inserta_fila">inserta_fila</a></code></li>
<li><code><a title="Algebra.Matriu.intercanvia_columnes" href="#Algebra.Matriu.intercanvia_columnes">intercanvia_columnes</a></code></li>
<li><code><a title="Algebra.Matriu.inversa" href="#Algebra.Matriu.inversa">inversa</a></code></li>
<li><code><a title="Algebra.Matriu.invertible" href="#Algebra.Matriu.invertible">invertible</a></code></li>
<li><code><a title="Algebra.Matriu.latex" href="#Algebra.Matriu.latex">latex</a></code></li>
<li><code><a title="Algebra.Matriu.matriu_columna" href="#Algebra.Matriu.matriu_columna">matriu_columna</a></code></li>
<li><code><a title="Algebra.Matriu.matriu_fila" href="#Algebra.Matriu.matriu_fila">matriu_fila</a></code></li>
<li><code><a title="Algebra.Matriu.max_diagonal" href="#Algebra.Matriu.max_diagonal">max_diagonal</a></code></li>
<li><code><a title="Algebra.Matriu.nnegatius" href="#Algebra.Matriu.nnegatius">nnegatius</a></code></li>
<li><code><a title="Algebra.Matriu.norma_maxim" href="#Algebra.Matriu.norma_maxim">norma_maxim</a></code></li>
<li><code><a title="Algebra.Matriu.nucli" href="#Algebra.Matriu.nucli">nucli</a></code></li>
<li><code><a title="Algebra.Matriu.nzeros" href="#Algebra.Matriu.nzeros">nzeros</a></code></li>
<li><code><a title="Algebra.Matriu.polinomi_caracteristic" href="#Algebra.Matriu.polinomi_caracteristic">polinomi_caracteristic</a></code></li>
<li><code><a title="Algebra.Matriu.rang" href="#Algebra.Matriu.rang">rang</a></code></li>
<li><code><a title="Algebra.Matriu.rank" href="#Algebra.Matriu.rank">rank</a></code></li>
<li><code><a title="Algebra.Matriu.reordena_aleatoriament_columnes" href="#Algebra.Matriu.reordena_aleatoriament_columnes">reordena_aleatoriament_columnes</a></code></li>
<li><code><a title="Algebra.Matriu.reordena_aleatoriament_files" href="#Algebra.Matriu.reordena_aleatoriament_files">reordena_aleatoriament_files</a></code></li>
<li><code><a title="Algebra.Matriu.set_format" href="#Algebra.Matriu.set_format">set_format</a></code></li>
<li><code><a title="Algebra.Matriu.set_vaps" href="#Algebra.Matriu.set_vaps">set_vaps</a></code></li>
<li><code><a title="Algebra.Matriu.set_veps" href="#Algebra.Matriu.set_veps">set_veps</a></code></li>
<li><code><a title="Algebra.Matriu.simplificar" href="#Algebra.Matriu.simplificar">simplificar</a></code></li>
<li><code><a title="Algebra.Matriu.sistema_propi" href="#Algebra.Matriu.sistema_propi">sistema_propi</a></code></li>
<li><code><a title="Algebra.Matriu.submatriu" href="#Algebra.Matriu.submatriu">submatriu</a></code></li>
<li><code><a title="Algebra.Matriu.subs" href="#Algebra.Matriu.subs">subs</a></code></li>
<li><code><a title="Algebra.Matriu.transformacio_elemental" href="#Algebra.Matriu.transformacio_elemental">transformacio_elemental</a></code></li>
<li><code><a title="Algebra.Matriu.transposada" href="#Algebra.Matriu.transposada">transposada</a></code></li>
<li><code><a title="Algebra.Matriu.vectors_columna" href="#Algebra.Matriu.vectors_columna">vectors_columna</a></code></li>
<li><code><a title="Algebra.Matriu.vectors_fila" href="#Algebra.Matriu.vectors_fila">vectors_fila</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Algebra.Parabola" href="#Algebra.Parabola">Parabola</a></code></h4>
<ul class="two-column">
<li><code><a title="Algebra.Parabola.aleatoria" href="#Algebra.Parabola.aleatoria">aleatoria</a></code></li>
<li><code><a title="Algebra.Parabola.equacio_reduida" href="#Algebra.Parabola.equacio_reduida">equacio_reduida</a></code></li>
<li><code><a title="Algebra.Parabola.focus" href="#Algebra.Parabola.focus">focus</a></code></li>
<li><code><a title="Algebra.Parabola.maxim_origen" href="#Algebra.Parabola.maxim_origen">maxim_origen</a></code></li>
<li><code><a title="Algebra.Parabola.parametre" href="#Algebra.Parabola.parametre">parametre</a></code></li>
<li><code><a title="Algebra.Parabola.recta_directriu" href="#Algebra.Parabola.recta_directriu">recta_directriu</a></code></li>
<li><code><a title="Algebra.Parabola.to_asy" href="#Algebra.Parabola.to_asy">to_asy</a></code></li>
<li><code><a title="Algebra.Parabola.vertex" href="#Algebra.Parabola.vertex">vertex</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Algebra.ParaboloideElliptic" href="#Algebra.ParaboloideElliptic">ParaboloideElliptic</a></code></h4>
<ul class="">
<li><code><a title="Algebra.ParaboloideElliptic.aleatoria" href="#Algebra.ParaboloideElliptic.aleatoria">aleatoria</a></code></li>
<li><code><a title="Algebra.ParaboloideElliptic.equacio_reduida" href="#Algebra.ParaboloideElliptic.equacio_reduida">equacio_reduida</a></code></li>
<li><code><a title="Algebra.ParaboloideElliptic.semieixos" href="#Algebra.ParaboloideElliptic.semieixos">semieixos</a></code></li>
<li><code><a title="Algebra.ParaboloideElliptic.semieixos_quadrats" href="#Algebra.ParaboloideElliptic.semieixos_quadrats">semieixos_quadrats</a></code></li>
<li><code><a title="Algebra.ParaboloideElliptic.vertex" href="#Algebra.ParaboloideElliptic.vertex">vertex</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Algebra.ParaboloideHiperbolic" href="#Algebra.ParaboloideHiperbolic">ParaboloideHiperbolic</a></code></h4>
<ul class="">
<li><code><a title="Algebra.ParaboloideHiperbolic.aleatoria" href="#Algebra.ParaboloideHiperbolic.aleatoria">aleatoria</a></code></li>
<li><code><a title="Algebra.ParaboloideHiperbolic.equacio_reduida" href="#Algebra.ParaboloideHiperbolic.equacio_reduida">equacio_reduida</a></code></li>
<li><code><a title="Algebra.ParaboloideHiperbolic.semieixos" href="#Algebra.ParaboloideHiperbolic.semieixos">semieixos</a></code></li>
<li><code><a title="Algebra.ParaboloideHiperbolic.semieixos_quadrats" href="#Algebra.ParaboloideHiperbolic.semieixos_quadrats">semieixos_quadrats</a></code></li>
<li><code><a title="Algebra.ParaboloideHiperbolic.vertex" href="#Algebra.ParaboloideHiperbolic.vertex">vertex</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Algebra.PlaAfi" href="#Algebra.PlaAfi">PlaAfi</a></code></h4>
<ul class="">
<li><code><a title="Algebra.PlaAfi.aleatori" href="#Algebra.PlaAfi.aleatori">aleatori</a></code></li>
<li><code><a title="Algebra.PlaAfi.amb_associat" href="#Algebra.PlaAfi.amb_associat">amb_associat</a></code></li>
<li><code><a title="Algebra.PlaAfi.associat" href="#Algebra.PlaAfi.associat">associat</a></code></li>
<li><code><a title="Algebra.PlaAfi.base_ortogonal" href="#Algebra.PlaAfi.base_ortogonal">base_ortogonal</a></code></li>
<li><code><a title="Algebra.PlaAfi.conte" href="#Algebra.PlaAfi.conte">conte</a></code></li>
<li><code><a title="Algebra.PlaAfi.distancia" href="#Algebra.PlaAfi.distancia">distancia</a></code></li>
<li><code><a title="Algebra.PlaAfi.equacio_implicita" href="#Algebra.PlaAfi.equacio_implicita">equacio_implicita</a></code></li>
<li><code><a title="Algebra.PlaAfi.from_equacio_implicita" href="#Algebra.PlaAfi.from_equacio_implicita">from_equacio_implicita</a></code></li>
<li><code><a title="Algebra.PlaAfi.interseccio" href="#Algebra.PlaAfi.interseccio">interseccio</a></code></li>
<li><code><a title="Algebra.PlaAfi.projeccio_ortogonal" href="#Algebra.PlaAfi.projeccio_ortogonal">projeccio_ortogonal</a></code></li>
<li><code><a title="Algebra.PlaAfi.punt_de_coordenades_enteres" href="#Algebra.PlaAfi.punt_de_coordenades_enteres">punt_de_coordenades_enteres</a></code></li>
<li><code><a title="Algebra.PlaAfi.simetric" href="#Algebra.PlaAfi.simetric">simetric</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Algebra.PlaVectorial" href="#Algebra.PlaVectorial">PlaVectorial</a></code></h4>
<ul class="two-column">
<li><code><a title="Algebra.PlaVectorial.amb_associat" href="#Algebra.PlaVectorial.amb_associat">amb_associat</a></code></li>
<li><code><a title="Algebra.PlaVectorial.associat" href="#Algebra.PlaVectorial.associat">associat</a></code></li>
<li><code><a title="Algebra.PlaVectorial.base_ortogonal" href="#Algebra.PlaVectorial.base_ortogonal">base_ortogonal</a></code></li>
<li><code><a title="Algebra.PlaVectorial.conte" href="#Algebra.PlaVectorial.conte">conte</a></code></li>
<li><code><a title="Algebra.PlaVectorial.equacio_implicita" href="#Algebra.PlaVectorial.equacio_implicita">equacio_implicita</a></code></li>
<li><code><a title="Algebra.PlaVectorial.es_associat" href="#Algebra.PlaVectorial.es_associat">es_associat</a></code></li>
<li><code><a title="Algebra.PlaVectorial.from_matriu" href="#Algebra.PlaVectorial.from_matriu">from_matriu</a></code></li>
<li><code><a title="Algebra.PlaVectorial.ortogonal" href="#Algebra.PlaVectorial.ortogonal">ortogonal</a></code></li>
<li><code><a title="Algebra.PlaVectorial.projeccio_ortogonal" href="#Algebra.PlaVectorial.projeccio_ortogonal">projeccio_ortogonal</a></code></li>
<li><code><a title="Algebra.PlaVectorial.simetric" href="#Algebra.PlaVectorial.simetric">simetric</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Algebra.Punt" href="#Algebra.Punt">Punt</a></code></h4>
<ul class="">
<li><code><a title="Algebra.Punt.coordenades_en_referencia" href="#Algebra.Punt.coordenades_en_referencia">coordenades_en_referencia</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Algebra.Quadrica" href="#Algebra.Quadrica">Quadrica</a></code></h4>
<ul class="">
<li><code><a title="Algebra.Quadrica.aleatoria" href="#Algebra.Quadrica.aleatoria">aleatoria</a></code></li>
<li><code><a title="Algebra.Quadrica.cilindreelliptic" href="#Algebra.Quadrica.cilindreelliptic">cilindreelliptic</a></code></li>
<li><code><a title="Algebra.Quadrica.cilindrehiperbolic" href="#Algebra.Quadrica.cilindrehiperbolic">cilindrehiperbolic</a></code></li>
<li><code><a title="Algebra.Quadrica.cilindreparabolic" href="#Algebra.Quadrica.cilindreparabolic">cilindreparabolic</a></code></li>
<li><code><a title="Algebra.Quadrica.con" href="#Algebra.Quadrica.con">con</a></code></li>
<li><code><a title="Algebra.Quadrica.ellipsoide" href="#Algebra.Quadrica.ellipsoide">ellipsoide</a></code></li>
<li><code><a title="Algebra.Quadrica.equacio" href="#Algebra.Quadrica.equacio">equacio</a></code></li>
<li><code><a title="Algebra.Quadrica.from_equacio" href="#Algebra.Quadrica.from_equacio">from_equacio</a></code></li>
<li><code><a title="Algebra.Quadrica.hiperboloideduesfulles" href="#Algebra.Quadrica.hiperboloideduesfulles">hiperboloideduesfulles</a></code></li>
<li><code><a title="Algebra.Quadrica.hiperboloideunafulla" href="#Algebra.Quadrica.hiperboloideunafulla">hiperboloideunafulla</a></code></li>
<li><code><a title="Algebra.Quadrica.paraboloideelliptic" href="#Algebra.Quadrica.paraboloideelliptic">paraboloideelliptic</a></code></li>
<li><code><a title="Algebra.Quadrica.paraboloidehiperbolic" href="#Algebra.Quadrica.paraboloidehiperbolic">paraboloidehiperbolic</a></code></li>
<li><code><a title="Algebra.Quadrica.referencia_principal" href="#Algebra.Quadrica.referencia_principal">referencia_principal</a></code></li>
<li><code><a title="Algebra.Quadrica.tipus" href="#Algebra.Quadrica.tipus">tipus</a></code></li>
<li><code><a title="Algebra.Quadrica.vectors" href="#Algebra.Quadrica.vectors">vectors</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Algebra.Radicals" href="#Algebra.Radicals">Radicals</a></code></h4>
<ul class="">
<li><code><a title="Algebra.Radicals.busca_fraccions" href="#Algebra.Radicals.busca_fraccions">busca_fraccions</a></code></li>
<li><code><a title="Algebra.Radicals.busca_quadrats" href="#Algebra.Radicals.busca_quadrats">busca_quadrats</a></code></li>
<li><code><a title="Algebra.Radicals.mcd" href="#Algebra.Radicals.mcd">mcd</a></code></li>
<li><code><a title="Algebra.Radicals.mcm" href="#Algebra.Radicals.mcm">mcm</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Algebra.RectaAfi" href="#Algebra.RectaAfi">RectaAfi</a></code></h4>
<ul class="">
<li><code><a title="Algebra.RectaAfi.aleatoria" href="#Algebra.RectaAfi.aleatoria">aleatoria</a></code></li>
<li><code><a title="Algebra.RectaAfi.conte" href="#Algebra.RectaAfi.conte">conte</a></code></li>
<li><code><a title="Algebra.RectaAfi.distancia" href="#Algebra.RectaAfi.distancia">distancia</a></code></li>
<li><code><a title="Algebra.RectaAfi.equacio_continua" href="#Algebra.RectaAfi.equacio_continua">equacio_continua</a></code></li>
<li><code><a title="Algebra.RectaAfi.equacions_implicites" href="#Algebra.RectaAfi.equacions_implicites">equacions_implicites</a></code></li>
<li><code><a title="Algebra.RectaAfi.from_equacions_implicites" href="#Algebra.RectaAfi.from_equacions_implicites">from_equacions_implicites</a></code></li>
<li><code><a title="Algebra.RectaAfi.interseccio" href="#Algebra.RectaAfi.interseccio">interseccio</a></code></li>
<li><code><a title="Algebra.RectaAfi.projeccio_ortogonal" href="#Algebra.RectaAfi.projeccio_ortogonal">projeccio_ortogonal</a></code></li>
<li><code><a title="Algebra.RectaAfi.punt" href="#Algebra.RectaAfi.punt">punt</a></code></li>
<li><code><a title="Algebra.RectaAfi.punt_de_coordenades_enteres" href="#Algebra.RectaAfi.punt_de_coordenades_enteres">punt_de_coordenades_enteres</a></code></li>
<li><code><a title="Algebra.RectaAfi.simetric" href="#Algebra.RectaAfi.simetric">simetric</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Algebra.RectaRegressio" href="#Algebra.RectaRegressio">RectaRegressio</a></code></h4>
<ul class="">
<li><code><a title="Algebra.RectaRegressio.aleatoria" href="#Algebra.RectaRegressio.aleatoria">aleatoria</a></code></li>
<li><code><a title="Algebra.RectaRegressio.equacio" href="#Algebra.RectaRegressio.equacio">equacio</a></code></li>
<li><code><a title="Algebra.RectaRegressio.error_quadratic" href="#Algebra.RectaRegressio.error_quadratic">error_quadratic</a></code></li>
<li><code><a title="Algebra.RectaRegressio.llista_punts" href="#Algebra.RectaRegressio.llista_punts">llista_punts</a></code></li>
<li><code><a title="Algebra.RectaRegressio.taula_punts" href="#Algebra.RectaRegressio.taula_punts">taula_punts</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Algebra.RectaVectorial" href="#Algebra.RectaVectorial">RectaVectorial</a></code></h4>
<ul class="">
<li><code><a title="Algebra.RectaVectorial.equacio_continua" href="#Algebra.RectaVectorial.equacio_continua">equacio_continua</a></code></li>
<li><code><a title="Algebra.RectaVectorial.equacions_implicites" href="#Algebra.RectaVectorial.equacions_implicites">equacions_implicites</a></code></li>
<li><code><a title="Algebra.RectaVectorial.ortogonal" href="#Algebra.RectaVectorial.ortogonal">ortogonal</a></code></li>
<li><code><a title="Algebra.RectaVectorial.projeccio_ortogonal" href="#Algebra.RectaVectorial.projeccio_ortogonal">projeccio_ortogonal</a></code></li>
<li><code><a title="Algebra.RectaVectorial.simetric" href="#Algebra.RectaVectorial.simetric">simetric</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Algebra.ReferenciaAfi" href="#Algebra.ReferenciaAfi">ReferenciaAfi</a></code></h4>
<ul class="">
<li><code><a title="Algebra.ReferenciaAfi.aleatoria" href="#Algebra.ReferenciaAfi.aleatoria">aleatoria</a></code></li>
<li><code><a title="Algebra.ReferenciaAfi.canonica" href="#Algebra.ReferenciaAfi.canonica">canonica</a></code></li>
<li><code><a title="Algebra.ReferenciaAfi.canvi_coordenades" href="#Algebra.ReferenciaAfi.canvi_coordenades">canvi_coordenades</a></code></li>
<li><code><a title="Algebra.ReferenciaAfi.canvi_de_referencia_a_la_referencia" href="#Algebra.ReferenciaAfi.canvi_de_referencia_a_la_referencia">canvi_de_referencia_a_la_referencia</a></code></li>
<li><code><a title="Algebra.ReferenciaAfi.coordenades_del_punt" href="#Algebra.ReferenciaAfi.coordenades_del_punt">coordenades_del_punt</a></code></li>
<li><code><a title="Algebra.ReferenciaAfi.punt_de_coordenades" href="#Algebra.ReferenciaAfi.punt_de_coordenades">punt_de_coordenades</a></code></li>
<li><code><a title="Algebra.ReferenciaAfi.referencia_inversa" href="#Algebra.ReferenciaAfi.referencia_inversa">referencia_inversa</a></code></li>
<li><code><a title="Algebra.ReferenciaAfi.vectors" href="#Algebra.ReferenciaAfi.vectors">vectors</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Algebra.SistemaEquacions" href="#Algebra.SistemaEquacions">SistemaEquacions</a></code></h4>
<ul class="">
<li><code><a title="Algebra.SistemaEquacions.from_equacions" href="#Algebra.SistemaEquacions.from_equacions">from_equacions</a></code></li>
<li><code><a title="Algebra.SistemaEquacions.matriu_ampliada" href="#Algebra.SistemaEquacions.matriu_ampliada">matriu_ampliada</a></code></li>
<li><code><a title="Algebra.SistemaEquacions.matriu_incognites" href="#Algebra.SistemaEquacions.matriu_incognites">matriu_incognites</a></code></li>
<li><code><a title="Algebra.SistemaEquacions.resol" href="#Algebra.SistemaEquacions.resol">resol</a></code></li>
<li><code><a title="Algebra.SistemaEquacions.solucio_latex" href="#Algebra.SistemaEquacions.solucio_latex">solucio_latex</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Algebra.SubespaiVectorial" href="#Algebra.SubespaiVectorial">SubespaiVectorial</a></code></h4>
<ul class="">
<li><code><a title="Algebra.SubespaiVectorial.amplia_base" href="#Algebra.SubespaiVectorial.amplia_base">amplia_base</a></code></li>
<li><code><a title="Algebra.SubespaiVectorial.amplia_base_suplementari" href="#Algebra.SubespaiVectorial.amplia_base_suplementari">amplia_base_suplementari</a></code></li>
<li><code><a title="Algebra.SubespaiVectorial.base_ortogonal" href="#Algebra.SubespaiVectorial.base_ortogonal">base_ortogonal</a></code></li>
<li><code><a title="Algebra.SubespaiVectorial.equacions_implicites" href="#Algebra.SubespaiVectorial.equacions_implicites">equacions_implicites</a></code></li>
<li><code><a title="Algebra.SubespaiVectorial.es_total" href="#Algebra.SubespaiVectorial.es_total">es_total</a></code></li>
<li><code><a title="Algebra.SubespaiVectorial.es_zero" href="#Algebra.SubespaiVectorial.es_zero">es_zero</a></code></li>
<li><code><a title="Algebra.SubespaiVectorial.from_equacio_implicita" href="#Algebra.SubespaiVectorial.from_equacio_implicita">from_equacio_implicita</a></code></li>
<li><code><a title="Algebra.SubespaiVectorial.from_equacions_implicites" href="#Algebra.SubespaiVectorial.from_equacions_implicites">from_equacions_implicites</a></code></li>
<li><code><a title="Algebra.SubespaiVectorial.projeccio_ortogonal" href="#Algebra.SubespaiVectorial.projeccio_ortogonal">projeccio_ortogonal</a></code></li>
<li><code><a title="Algebra.SubespaiVectorial.simetric" href="#Algebra.SubespaiVectorial.simetric">simetric</a></code></li>
<li><code><a title="Algebra.SubespaiVectorial.suplementari_ortogonal" href="#Algebra.SubespaiVectorial.suplementari_ortogonal">suplementari_ortogonal</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Algebra.TransformacioAfi" href="#Algebra.TransformacioAfi">TransformacioAfi</a></code></h4>
<ul class="two-column">
<li><code><a title="Algebra.TransformacioAfi.aleatoria" href="#Algebra.TransformacioAfi.aleatoria">aleatoria</a></code></li>
<li><code><a title="Algebra.TransformacioAfi.gir" href="#Algebra.TransformacioAfi.gir">gir</a></code></li>
<li><code><a title="Algebra.TransformacioAfi.latex" href="#Algebra.TransformacioAfi.latex">latex</a></code></li>
<li><code><a title="Algebra.TransformacioAfi.moviment_helicoidal" href="#Algebra.TransformacioAfi.moviment_helicoidal">moviment_helicoidal</a></code></li>
<li><code><a title="Algebra.TransformacioAfi.projeccio_ortogonal" href="#Algebra.TransformacioAfi.projeccio_ortogonal">projeccio_ortogonal</a></code></li>
<li><code><a title="Algebra.TransformacioAfi.rang" href="#Algebra.TransformacioAfi.rang">rang</a></code></li>
<li><code><a title="Algebra.TransformacioAfi.rank" href="#Algebra.TransformacioAfi.rank">rank</a></code></li>
<li><code><a title="Algebra.TransformacioAfi.rotacio" href="#Algebra.TransformacioAfi.rotacio">rotacio</a></code></li>
<li><code><a title="Algebra.TransformacioAfi.set_formats" href="#Algebra.TransformacioAfi.set_formats">set_formats</a></code></li>
<li><code><a title="Algebra.TransformacioAfi.simetria" href="#Algebra.TransformacioAfi.simetria">simetria</a></code></li>
<li><code><a title="Algebra.TransformacioAfi.transforma" href="#Algebra.TransformacioAfi.transforma">transforma</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Algebra.TransformacioLineal" href="#Algebra.TransformacioLineal">TransformacioLineal</a></code></h4>
<ul class="">
<li><code><a title="Algebra.TransformacioLineal.aleatoria" href="#Algebra.TransformacioLineal.aleatoria">aleatoria</a></code></li>
<li><code><a title="Algebra.TransformacioLineal.angles_euler" href="#Algebra.TransformacioLineal.angles_euler">angles_euler</a></code></li>
<li><code><a title="Algebra.TransformacioLineal.antiimatges" href="#Algebra.TransformacioLineal.antiimatges">antiimatges</a></code></li>
<li><code><a title="Algebra.TransformacioLineal.determinant" href="#Algebra.TransformacioLineal.determinant">determinant</a></code></li>
<li><code><a title="Algebra.TransformacioLineal.diagonalitza" href="#Algebra.TransformacioLineal.diagonalitza">diagonalitza</a></code></li>
<li><code><a title="Algebra.TransformacioLineal.eix_angle_rotacio" href="#Algebra.TransformacioLineal.eix_angle_rotacio">eix_angle_rotacio</a></code></li>
<li><code><a title="Algebra.TransformacioLineal.es_rotacio" href="#Algebra.TransformacioLineal.es_rotacio">es_rotacio</a></code></li>
<li><code><a title="Algebra.TransformacioLineal.es_simetrica" href="#Algebra.TransformacioLineal.es_simetrica">es_simetrica</a></code></li>
<li><code><a title="Algebra.TransformacioLineal.es_vector_propi" href="#Algebra.TransformacioLineal.es_vector_propi">es_vector_propi</a></code></li>
<li><code><a title="Algebra.TransformacioLineal.escalat" href="#Algebra.TransformacioLineal.escalat">escalat</a></code></li>
<li><code><a title="Algebra.TransformacioLineal.gir" href="#Algebra.TransformacioLineal.gir">gir</a></code></li>
<li><code><a title="Algebra.TransformacioLineal.imatges_una_base" href="#Algebra.TransformacioLineal.imatges_una_base">imatges_una_base</a></code></li>
<li><code><a title="Algebra.TransformacioLineal.latex" href="#Algebra.TransformacioLineal.latex">latex</a></code></li>
<li><code><a title="Algebra.TransformacioLineal.matriu_en_base" href="#Algebra.TransformacioLineal.matriu_en_base">matriu_en_base</a></code></li>
<li><code><a title="Algebra.TransformacioLineal.polinomi_caracteristic" href="#Algebra.TransformacioLineal.polinomi_caracteristic">polinomi_caracteristic</a></code></li>
<li><code><a title="Algebra.TransformacioLineal.projeccio_ortogonal" href="#Algebra.TransformacioLineal.projeccio_ortogonal">projeccio_ortogonal</a></code></li>
<li><code><a title="Algebra.TransformacioLineal.quaternio" href="#Algebra.TransformacioLineal.quaternio">quaternio</a></code></li>
<li><code><a title="Algebra.TransformacioLineal.rang" href="#Algebra.TransformacioLineal.rang">rang</a></code></li>
<li><code><a title="Algebra.TransformacioLineal.rank" href="#Algebra.TransformacioLineal.rank">rank</a></code></li>
<li><code><a title="Algebra.TransformacioLineal.rotacio" href="#Algebra.TransformacioLineal.rotacio">rotacio</a></code></li>
<li><code><a title="Algebra.TransformacioLineal.rotacio_amb_angles_euler" href="#Algebra.TransformacioLineal.rotacio_amb_angles_euler">rotacio_amb_angles_euler</a></code></li>
<li><code><a title="Algebra.TransformacioLineal.rotacio_amb_quaternio" href="#Algebra.TransformacioLineal.rotacio_amb_quaternio">rotacio_amb_quaternio</a></code></li>
<li><code><a title="Algebra.TransformacioLineal.set_format" href="#Algebra.TransformacioLineal.set_format">set_format</a></code></li>
<li><code><a title="Algebra.TransformacioLineal.simetria" href="#Algebra.TransformacioLineal.simetria">simetria</a></code></li>
<li><code><a title="Algebra.TransformacioLineal.transforma" href="#Algebra.TransformacioLineal.transforma">transforma</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Algebra.VarietatAfi" href="#Algebra.VarietatAfi">VarietatAfi</a></code></h4>
<ul class="">
<li><code><a title="Algebra.VarietatAfi.base_ortogonal" href="#Algebra.VarietatAfi.base_ortogonal">base_ortogonal</a></code></li>
<li><code><a title="Algebra.VarietatAfi.equacions_implicites" href="#Algebra.VarietatAfi.equacions_implicites">equacions_implicites</a></code></li>
<li><code><a title="Algebra.VarietatAfi.es_total" href="#Algebra.VarietatAfi.es_total">es_total</a></code></li>
<li><code><a title="Algebra.VarietatAfi.es_un_punt" href="#Algebra.VarietatAfi.es_un_punt">es_un_punt</a></code></li>
<li><code><a title="Algebra.VarietatAfi.from_equacio_implicita" href="#Algebra.VarietatAfi.from_equacio_implicita">from_equacio_implicita</a></code></li>
<li><code><a title="Algebra.VarietatAfi.from_equacions_implicites" href="#Algebra.VarietatAfi.from_equacions_implicites">from_equacions_implicites</a></code></li>
<li><code><a title="Algebra.VarietatAfi.projeccio_ortogonal" href="#Algebra.VarietatAfi.projeccio_ortogonal">projeccio_ortogonal</a></code></li>
<li><code><a title="Algebra.VarietatAfi.simetric" href="#Algebra.VarietatAfi.simetric">simetric</a></code></li>
<li><code><a title="Algebra.VarietatAfi.varietat_ortogonal" href="#Algebra.VarietatAfi.varietat_ortogonal">varietat_ortogonal</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Algebra.Vector" href="#Algebra.Vector">Vector</a></code></h4>
<ul class="">
<li><code><a title="Algebra.Vector.aleatori" href="#Algebra.Vector.aleatori">aleatori</a></code></li>
<li><code><a title="Algebra.Vector.as_quaternio" href="#Algebra.Vector.as_quaternio">as_quaternio</a></code></li>
<li><code><a title="Algebra.Vector.clona" href="#Algebra.Vector.clona">clona</a></code></li>
<li><code><a title="Algebra.Vector.components_en_base" href="#Algebra.Vector.components_en_base">components_en_base</a></code></li>
<li><code><a title="Algebra.Vector.cross" href="#Algebra.Vector.cross">cross</a></code></li>
<li><code><a title="Algebra.Vector.diff" href="#Algebra.Vector.diff">diff</a></code></li>
<li><code><a title="Algebra.Vector.dot" href="#Algebra.Vector.dot">dot</a></code></li>
<li><code><a title="Algebra.Vector.es_proporcional" href="#Algebra.Vector.es_proporcional">es_proporcional</a></code></li>
<li><code><a title="Algebra.Vector.factor_comu" href="#Algebra.Vector.factor_comu">factor_comu</a></code></li>
<li><code><a title="Algebra.Vector.latex" href="#Algebra.Vector.latex">latex</a></code></li>
<li><code><a title="Algebra.Vector.length" href="#Algebra.Vector.length">length</a></code></li>
<li><code><a title="Algebra.Vector.maxim" href="#Algebra.Vector.maxim">maxim</a></code></li>
<li><code><a title="Algebra.Vector.normalitzar" href="#Algebra.Vector.normalitzar">normalitzar</a></code></li>
<li><code><a title="Algebra.Vector.normalitzat" href="#Algebra.Vector.normalitzat">normalitzat</a></code></li>
<li><code><a title="Algebra.Vector.nul" href="#Algebra.Vector.nul">nul</a></code></li>
<li><code><a title="Algebra.Vector.nzeros" href="#Algebra.Vector.nzeros">nzeros</a></code></li>
<li><code><a title="Algebra.Vector.perpendicular" href="#Algebra.Vector.perpendicular">perpendicular</a></code></li>
<li><code><a title="Algebra.Vector.punt" href="#Algebra.Vector.punt">punt</a></code></li>
<li><code><a title="Algebra.Vector.radsimplificar" href="#Algebra.Vector.radsimplificar">radsimplificar</a></code></li>
<li><code><a title="Algebra.Vector.reordena_aleatoriament" href="#Algebra.Vector.reordena_aleatoriament">reordena_aleatoriament</a></code></li>
<li><code><a title="Algebra.Vector.set_big" href="#Algebra.Vector.set_big">set_big</a></code></li>
<li><code><a title="Algebra.Vector.simplificar" href="#Algebra.Vector.simplificar">simplificar</a></code></li>
<li><code><a title="Algebra.Vector.subs" href="#Algebra.Vector.subs">subs</a></code></li>
<li><code><a title="Algebra.Vector.tots_enters" href="#Algebra.Vector.tots_enters">tots_enters</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>